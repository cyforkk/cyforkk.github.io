[{"title":"CentOS7网络配置失败？从报错到解决的完整指南","url":"/2025/07/26/CentOS7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5%EF%BC%9F%E4%BB%8E%E6%8A%A5%E9%94%99%E5%88%B0%E8%A7%A3%E5%86%B3%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","content":"CentOS 7 网络配置失败？从报错到解决的完整指南在使用 CentOS 7 时，网络配置是日常操作的基础，但偶尔会遇到「重启网络服务失败」的问题。本文结合实际场景，详细讲解如何排查网络服务报错（Job for network.service failed），从配置文件到服务依赖，一步步定位问题并解决，适用于新手和有一定经验的用户。\n一、问题现象：网络服务重启失败执行重启网络服务的命令后，出现如下错误：\n[root@server01 ~]# systemctl restart networkJob for network.service failed because the control process exited with error code. See &quot;systemctl status network.service&quot; and &quot;journalctl -xe&quot; for details.\n\n此时网络可能完全不可用，或配置不生效。这种情况多由 配置文件错误 或 服务冲突 导致，无需慌张，按步骤排查即可解决。\n二、核心排查步骤1. 先看配置文件：语法错误是重灾区网络配置文件是最容易出错的地方，路径为：\n&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-&lt;网卡名&gt;（如 ifcfg-ens33）\n检查配置文件内容执行命令查看当前配置：\ncat /etc/sysconfig/network-scripts/ifcfg-ens33\n\n以静态 IP 配置为例，正确的格式应类似这样（关键参数已标注）：\nTYPE=Ethernet         # 网络类型：以太网BOOTPROTO=static      # 启动协议：静态IP（手动配置）NAME=ens33            # 连接名称（需与网卡名对应）DEVICE=ens33          # 网卡设备名（必须与实际网卡一致）ONBOOT=yes            # 开机自动激活网卡IPADDR=192.168.10.101 # 静态IP地址（根据实际网段修改）NETMASK=255.255.255.0 # 子网掩码（或用 PREFIX=24 表示）GATEWAY=192.168.10.2  # 网关地址（通常是路由器IP）DNS1=192.168.10.2     # DNS服务器（可填公共DNS如114.114.114.114）\n\n配置文件常见错误\n参数拼写错误：如 IPADRR（少打一个 D）、GATEWY（少打 A），这类错误会直接导致服务启动失败。\n\n网卡名不匹配：DEVICE&#x3D;ens33 需与实际网卡名一致，可通过 ip link show 查看真实网卡名（可能是 ens37 等）。\n\n重复参数：同时存在 NETMASK 和 PREFIX 且值冲突（如 NETMASK&#x3D;255.255.255.0 与 PREFIX&#x3D;23 不匹配）。\n\n多余空格：参数值前后有空格（如 IPADDR&#x3D; 192.168.10.101），会被识别为无效值。\n\n\n2. 服务冲突：NetworkManager 与 network 的 “恩怨”CentOS 7 中有两个网络管理服务：\n\nnetwork：传统网络服务，配置文件驱动。\n\nNetworkManager：现代网络管理工具，图形化界面和命令行均支持，默认启用。\n\n\n两者同时运行时可能冲突，导致 network 服务启动失败。\n检查服务状态# 查看 NetworkManager 状态systemctl status NetworkManager# 查看 network 服务状态（包含错误日志）systemctl status network -l\n\n若输出中包含 conflict（冲突）或 dependency failed（依赖失败），大概率是服务冲突导致。\n3. 特殊场景：克隆虚拟机的 “隐藏坑”如果你的系统是从其他虚拟机克隆而来，可能会遇到 网卡硬件信息冲突：\n\n克隆会复制原虚拟机的 UUID（网络连接唯一标识）和 MAC 地址，导致新系统无法识别网卡。\n\n表现为：ip addr 中看不到网卡（如 ens33 缺失），或 lspci 检测不到网络硬件。\n\n\n三、解决方案：分场景处理场景 1：配置文件错误导致的启动失败修复配置文件直接编辑配置文件，修正错误参数：\nvim /etc/sysconfig/network-scripts/ifcfg-ens33\n\n确保关键参数正确（以静态 IP 为例）：\nTYPE=EthernetBOOTPROTO=staticNAME=ens33DEVICE=ens33ONBOOT=yesIPADDR=192.168.10.101 #替换为自己的ipPREFIX=24GATEWAY=192.168.10.2 #替换为自己的网关DNS1=192.168.10.2 #替换为自己的DNS\n\n保存后重启网络服务：\nsystemctl restart network\n\n场景 2：服务冲突导致的启动失败方案 A：禁用 NetworkManager（仅用 network 服务）适合纯命令行环境，或习惯用配置文件管理网络：\n 重复上面场景一的操作（在末尾加上）\nNM_CONTROLLED=no  # 关键：禁用 NetworkManager 管理\n\n# 停止并禁用 NetworkManagersystemctl stop NetworkManagersystemctl disable NetworkManager# 启用并重启 network 服务systemctl enable networksystemctl restart network\n\n场景 3：克隆虚拟机的网卡识别问题克隆后系统未识别网卡，表现为 ip addr 中无 ens33，且 lspci | grep -i network 无输出。\n解决步骤：\n检查虚拟机网络适配器（以 VMware 为例）：\n\n关闭虚拟机 → 右键「设置」→「网络适配器」→ 确认「已连接」和「启动时连接」已勾选，网络模式选择「NAT」或「桥接」。\n\n重建网卡配置：\n\n# 删除原网卡配置文件rm -f /etc/sysconfig/network-scripts/ifcfg-ens33# 删除 udev 规则（克隆残留的硬件信息）rm -f /etc/udev/rules.d/70-persistent-net.rules# 重启系统（自动生成新配置）reboot\n\n\n重启后，用 ip link show 确认网卡已识别（如 ens33），再按场景 1 配置网络即可。\n\n四、验证网络是否正常配置完成后，通过以下命令验证：\n# 查看IP是否生效ip addr show ens33  # 应显示配置的静态IP# 查看路由是否正确（默认网关是否生效）ip route show       # 应包含 &quot;default via 网关IP dev ens33&quot;# 测试连通性ping 网关IP -c 3    # 如 ping 192.168.10.2 -c 3ping 114.114.114.114 -c 3  # 测试公网连通性\n\n若均正常，说明网络配置已生效。\n五、总结：避坑指南\n配置文件是基础：仔细检查参数拼写、网卡名匹配，避免多余空格。\n\n服务二选一：要么用 network 服务（禁用 NetworkManager），要么用 NetworkManager（禁用 network），不要同时启用。\n\n克隆虚拟机注意：必须删除原网卡配置和 udev 规则，否则会因硬件信息冲突导致网卡不识别。\n\n公共 DNS 更可靠：配置 DNS1&#x3D;114.114.114.114 或 8.8.8.8，避免依赖网关 DNS。\n\n\n通过以上步骤，90% 以上的网络服务启动失败问题都能解决。如果仍有问题，可通过 journalctl -xe | grep network 查看详细错误日志，针对性排查即可。\n","categories":["VMWare"]},{"title":"Git基本使用（Windows版）","url":"/2025/07/19/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"Git基本使用（Windows版）参考Git教程 - 廖雪峰的官方网站\n\n安装gitgit\n测试是否安装成功\n方式一\n\nwin + r 打开控制台输入\ngit --version\n\n\n方式二\n\n右击&#x3D;&#x3D;》显示更多选项&#x3D;&#x3D;》git bash here\n或快捷键（shift + f10）\n\n配置Git$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;\n\n注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n创建版本库新建文件夹$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit\n\n注意：如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n\n$ mkdir learngit 创建一个空目录 为learngit\n$ cd learngit 进入目录 \n$ pwd 显示当前目录的路径\n$ cd  返回上一级目录 \ncd d:cyfor\\\\ggg\n$ ls 列出当前文件夹的所有文件或文件夹(不包括隐藏的文件)\n$ ls -ah 列出当前文件夹的所有文件或文件夹(包括隐藏的文件)\n\n变为Git仓库（将当前目录变成git可以管理的仓库）$ git init\n\n当前目录会多一个.git的目录\n\n$ git init          \tgit仓库初始化，把这个目录变成Git可以管理的仓库\n\n小结初始化一个Git仓库，使用git init命令。\n添加文件到Git仓库，分两步：\n\n使用命令git add ，注意，可反复多次使用，添加多个文件；\n如果有多个文件夹可以用 git add . 命令\n使用命令git commit -m ，完成。\n\n\n把文件添加到版本库$ git add 文件名/目录名（文件夹名）$ git commit -m &quot;本次提交的说明&quot;\n\n\n$ git add readme.txt\n 把文件添加到仓库\n$ git commit -m “wrote a readme file”\n 把文件提交到仓库 -m后面输入的是本次提交的说明\n$ git add . \t\n当前目录所有元素都加入（文件和文件夹）\n\n$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot;\n\ncommit可以一次提交很多文件，所以你可以多次add不同的文件\n查看仓库当前的状态$ git status\n\n查看具体修改的内容$ git diff\n\n\n时光穿梭显示所有日志提交$ git log 显示从最近到最远的提交日志$ git log --pretty=oneline 简朴显示\n\n版本回退首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n$ git reset --hard HEAD^\n\n--hard参数有啥意义？--hard会回退到上个版本的已提交状态，而--soft会回退到上个版本的未提交状态，--mixed会回退到上个版本已添加但未提交的状态。现在，先放心使用--hard。\n版本恢复方式一：知道版本号恢复\n办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：\n$ git reset --hard 1094a\n\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n方式二：寻找版本号恢复\n$ git reflog\n\n小结\nHEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。\n穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。\n要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。\n\n\n工作区和暂存区电脑中可以看到的目录（文件夹） &#x3D;&#x3D; 工作区\n版本库（工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库）\n版本库有stage和master（分支）、head（头指针）组成\n$ git status 是对工作区的情况$ git add xxx 是将工作区的内容提交到stage中$ git commit -m &quot;xxx&quot; 是将stage的内容提交到master分支中\n\n总结\n每次修改完文件，就add 放入stage中，再commit到分支，因为commit只会提交stage中的文件\n\n\n撤销修改情况一（未添加到stage中）：直接撤销\n$ git checkout -- readme.txt\n\n情况二（放入到stage中）：撤销到工作区再直接撤销\n用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区\n$ git reset HEAD readme.txt\n\n情况三（commit到分支中）：直接回退版本（前提是没有将本地版本库推送到远程）小结场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](##### 版本恢复)一节，不过前提是没有推送到远程库。\n\n删除文件流程：\n\n先删除工作区的文件（命令或手动）\n使用git rm 和git add\n\n删除工作区的文件\n$ rm test.txt\n\n删除版本库中的文件\n$ git rm test.txt$ git commit -m &quot;remove test.txt&quot;\n\n删错文件，从版本库中恢复\ngit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n$ git checkout -- test.txt\n\n 注意\n从来没有被添加到版本库就被删除的文件，是无法恢复的！\n小结\n命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。\n\n远程仓库添加远程仓库第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n第2步：登陆GitHub，点击右上角的头像，settings，SSH与GPG公钥\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n第3步：在主页右上角找到“Create a new repo”按钮，创建一个新的仓库\n第4步：连接对应的仓库\n$ git remote add origin git@github.com:michaelliao/learngit.git\n\n添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n第5步：把本地库的所有内容推送到远程库上\n$ git push -u origin master\n\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n从现在起，只要本地作了提交，就可以通过命令：\n$ git push origin master\n\nSSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：\nThe authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?\n\n这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。\nGit会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：\nWarning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.\n\n这个警告只会出现一次，后面的操作就不会有任何警告了。\n如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。\n查看远程库信息如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm &lt;name&gt;命令。使用前，建议先用git remote -v查看远程库信息：\n$ git remote -v\n\n删除远程库根据名字删除，比如删除origin：\n$ git remote rm origin\n\n此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。\n小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；\n关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；\n关联后，使用命令git push -u origin master第一次推送master分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n从远程库克隆git clone 目标地址.git\n$ git clone git@github.com:michaelliao/gitskills.git\n\n你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n小结要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。\nGit支持多种协议，包括https，但ssh协议速度最快。\n\n分支处理创建dev分支，然后切换到dev分支$ git checkout -b devSwitched to a new branch &#x27;dev&#x27;\n\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n$ git branch dev$ git checkout devSwitched to branch &#x27;dev&#x27;\n\ngit branch&#96;命令查看当前分支$ git branch* dev  master\n\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n切换分支git checkout 分支名\n$ git checkout master\n\n现在，我们把dev分支的工作成果合并到master分支上：\n合并分支$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+)\n\ngit merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n合并完成后，就可以放心地删除dev分支了：\n删除分支$ git branch -d devDeleted branch dev (was b17d20e).\n\n删除后，查看branch，就只剩下master分支了：\n查看分支$ git branch* master\n\n小结Git鼓励大量使用分支：\n查看分支：git branch\n创建分支：git branch &lt;name&gt;\n切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;\n创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;\n合并某分支到当前分支：git merge &lt;name&gt;\n删除分支：git branch -d &lt;name&gt;\n\n冲突分支修改的当行，commit后。主分支有修改当行，commit。会有冲突。\n解决方案（修改再提交）\n我们可以直接查看readme.txt的内容：\nGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1\n\nGit用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：\nGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.Creating a new branch is quick and simple.\n\n其他用带参数的git log也可以看到分支的合并情况：\n$ git log --graph --pretty=oneline --abbrev-commit\n\n尝试拉取远程更改时允许合并不相关的提交历史：\ngit pull origin master --allow-unrelated-histories\n\n\n\ncd(Change directory)    改变文件夹\nmkdir(Make directory)    新建文件夹\npwd(Print working directory)   显示当前目录\ninit(Initialization)    初始化\nstatus    情况\ncommit    提交\nstage\t暂存区\n添加某个文件时，该文件必须在当前目录下存在，用ls或者dir命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名\n$ git remote add origin git@github.com:michaelliao&#x2F;learngit.git\n请千万注意，把上面的michaelliao替换成你自己的GitHub账户名\n添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n$ git push -u origin master\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n只要本地作了提交，就可以通过命令：\n$ git push origin master\ngit remote rm 命令。使用前，建议先用git remote -v查看远程库信息：\n$ git remote -v\n根据名字删除，比如删除origin：\n$ git remote rm origin\n此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。\n要关联一个远程库，使用命令git remote add origin git@server-name:path&#x2F;repo-name.git；\n关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；\n关联后，使用命令git push -u origin master第一次推送master分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；\n","categories":["计算机"],"tags":["Git"]},{"title":"Day 1-3: Java SE核心概念复习详细可执行步骤","url":"/2025/08/21/Day-1-3-Java-SE%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%A4%8D%E4%B9%A0%E8%AF%A6%E7%BB%86%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4/","content":"Day 1-3: Java SE核心概念复习详细可执行步骤总体目标：夯实Java基础，为后续学习打下坚实基础每日学习时间：2-3小时（建议分为上午1小时理论，晚上2小时实践）学习方式：理论学习 + 代码实践 + 练习题巩固\n\nDay 1: 集合框架深度复习上午理论学习（1小时）第一步：回顾集合框架整体架构（15分钟）学习内容：\n\n 绘制集合框架继承关系图\n 理解Collection和Map两大体系\n 掌握List、Set、Queue接口的特点\n\n具体操作：\n\n打开记事本，手绘集合框架UML图\n标记每个接口和实现类的特点\n记录各个集合的使用场景\n\n检验方式：能够不看资料画出完整的集合框架图\n第二步：ArrayList vs LinkedList 原理分析（20分钟）学习内容：\n\n ArrayList底层数组实现原理\n LinkedList双向链表结构\n 时间复杂度对比分析\n 使用场景选择策略\n\n具体操作：\n\n阅读ArrayList源码中的add、get、remove方法\n分析LinkedList的Node结构和双向指针\n制作时间复杂度对比表格\n\n检验方式：能够解释为什么ArrayList查找快，LinkedList插入删除快\n第三步：HashMap深入理解（25分钟）学习内容：\n\n HashMap底层数组+链表+红黑树结构\n hash函数和扩容机制\n 解决哈希冲突的方法\n HashMap线程安全问题\n\n具体操作：\n\n画出HashMap内部结构示意图\n分析put方法的执行流程\n理解负载因子0.75的意义\n学习红黑树转换条件（链表长度&gt;8）\n\n检验方式：能够手绘HashMap结构图并解释put过程\n晚上实践编程（2小时）第一步：手写ArrayList实现（45分钟）任务目标：实现基础的动态数组功能\n// 创建文件：MyArrayList.javapublic class MyArrayList&lt;E&gt; &#123;    private Object[] elementData;    private int size;    private static final int DEFAULT_CAPACITY = 10;        // 待实现方法：    // 1. 构造函数    // 2. add(E element)    // 3. get(int index)    // 4. remove(int index)    // 5. size()    // 6. 扩容方法 grow()&#125;\n\n具体步骤：\n\n创建MyArrayList.java文件\n实现无参构造函数，初始化数组\n实现add方法，包含扩容逻辑\n实现get方法，包含边界检查\n实现remove方法，数组元素前移\n编写测试用例验证功能\n\n检验标准：\n\n 能够正确添加元素\n 自动扩容功能正常\n 能够获取和删除指定位置元素\n 边界条件处理正确\n\n第二步：手写HashMap核心功能（45分钟）任务目标：实现基础的键值对存储功能\n// 创建文件：MyHashMap.javapublic class MyHashMap&lt;K, V&gt; &#123;    private Node&lt;K, V&gt;[] table;    private int size;    private static final int DEFAULT_CAPACITY = 16;        static class Node&lt;K, V&gt; &#123;        K key;        V value;        Node&lt;K, V&gt; next;        // 构造函数    &#125;        // 待实现方法：    // 1. hash(Object key)    // 2. put(K key, V value)    // 3. get(Object key)    // 4. resize()&#125;\n\n具体步骤：\n\n定义Node内部类表示键值对节点\n实现简单的hash函数\n实现put方法，处理哈希冲突（链表法）\n实现get方法，遍历链表查找\n实现基础的扩容逻辑\n编写测试用例\n\n检验标准：\n\n 能够存储和获取键值对\n 正确处理哈希冲突\n key为null的情况处理\n 基本的扩容功能\n\n第三步：集合API熟练度练习（30分钟）练习内容：\n\nArrayList练习：\n\n// 练习题1：移除ArrayList中的重复元素List&lt;Integer&gt; list = Arrays.asList(1, 2, 2, 3, 3, 4);// 要求：保持原有顺序，移除重复元素\n\n\nHashMap练习：\n\n// 练习题2：统计字符串中每个字符的出现次数String str = &quot;hello world&quot;;// 要求：使用HashMap统计字符频率\n\n\nLinkedList练习：\n\n// 练习题3：使用LinkedList实现简单的队列操作// 要求：入队、出队、查看队首元素\n\n具体步骤：\n\n独立完成每个练习题\n对比不同集合类的性能\n记录解题思路和代码\n\n检验标准：30分钟内完成所有练习，代码可运行\n\nDay 2: IO流系统掌握上午理论学习（1小时）第一步：IO流体系结构梳理（20分钟）学习内容：\n\n 字节流和字符流的区别\n 输入流和输出流的分类\n 节点流和处理流的概念\n 常用IO类的继承关系\n\n具体操作：\n\n绘制IO流的分类思维导图\n列出常用的IO类：FileInputStream、BufferedReader等\n理解装饰器模式在IO中的应用\n\n检验方式：能够根据需求选择合适的IO流类\n第二步：文件操作核心API学习（20分钟）学习内容：\n\n File类的常用方法\n 文件和目录的创建、删除、重命名\n 文件属性的获取和设置\n 路径处理的最佳实践\n\n具体操作：\n\n学习File类的构造方法和常用API\n掌握相对路径和绝对路径的使用\n了解文件分隔符的跨平台处理\n\n检验方式：能够熟练使用File类进行文件操作\n第三步：NIO基础概念入门（20分钟）学习内容：\n\n NIO与传统IO的区别\n Buffer、Channel、Selector核心概念\n 同步非阻塞IO的原理\n NIO的适用场景\n\n具体操作：\n\n理解NIO的三大核心组件\n学习ByteBuffer的基本使用\n了解FileChannel的文件操作方式\n\n检验方式：能够解释NIO相比传统IO的优势\n晚上实践编程（2小时）第一步：基础文件操作实现（40分钟）任务目标：掌握文件的读写操作\n练习1：文本文件复制程序\n// 创建文件：FileCopyDemo.javapublic class FileCopyDemo &#123;    // 方法1：使用字节流复制任意类型文件    public static void copyWithByteStream(String src, String dest) &#123;        // 实现逻辑    &#125;        // 方法2：使用字符流复制文本文件    public static void copyWithCharStream(String src, String dest) &#123;        // 实现逻辑    &#125;        // 方法3：使用缓冲流提升性能    public static void copyWithBufferedStream(String src, String dest) &#123;        // 实现逻辑    &#125;&#125;\n\n具体步骤：\n\n创建测试文件（文本文件和图片文件）\n实现三种不同的文件复制方法\n比较复制速度和资源占用\n添加异常处理和资源关闭\n\n检验标准：\n\n 能够正确复制各种类型的文件\n 缓冲流版本性能明显优于普通流\n 正确处理异常和关闭资源\n 代码符合try-with-resources规范\n\n第二步：文件处理工具类开发（50分钟）任务目标：开发实用的文件操作工具类\n// 创建文件：FileUtils.javapublic class FileUtils &#123;    // 读取文件全部内容为字符串    public static String readFileToString(String filePath) &#123;        // 实现逻辑    &#125;        // 将字符串写入文件    public static void writeStringToFile(String content, String filePath) &#123;        // 实现逻辑    &#125;        // 按行读取文件    public static List&lt;String&gt; readLines(String filePath) &#123;        // 实现逻辑    &#125;        // 递归删除目录    public static boolean deleteDirectory(File directory) &#123;        // 实现逻辑    &#125;        // 获取文件大小（支持目录）    public static long getFileSize(File file) &#123;        // 实现逻辑    &#125;        // 查找指定扩展名的所有文件    public static List&lt;File&gt; findFilesByExtension(String directory, String extension) &#123;        // 实现逻辑    &#125;&#125;\n\n具体步骤：\n\n实现文件读写的便捷方法\n添加目录递归处理功能\n实现文件搜索和过滤功能\n编写完整的测试用例\n添加详细的异常处理\n\n检验标准：\n\n 所有方法功能正确\n 能够处理大文件（内存优化）\n 异常处理完善\n 测试覆盖各种场景\n\n第三步：网络IO编程入门（30分钟）任务目标：实现简单的网络通信程序\n练习：简单的Echo服务器和客户端\n// 创建文件：EchoServer.javapublic class EchoServer &#123;    public static void main(String[] args) &#123;        // 实现服务器端逻辑        // 监听端口，接收客户端连接        // 读取客户端消息并原样返回    &#125;&#125;// 创建文件：EchoClient.javapublic class EchoClient &#123;    public static void main(String[] args) &#123;        // 实现客户端逻辑        // 连接服务器        // 发送消息并接收回复    &#125;&#125;\n\n具体步骤：\n\n实现单线程Echo服务器\n实现对应的客户端程序\n测试连接和消息传递\n优化为多线程版本（时间允许）\n\n检验标准：\n\n 服务器能够正常启动和监听\n 客户端能够连接并通信\n 正确处理连接异常\n 资源正确释放\n\n\nDay 3: 多线程编程深入上午理论学习（1小时）第一步：线程基础概念复习（20分钟）学习内容：\n\n 进程与线程的区别\n 线程的生命周期状态\n Thread类和Runnable接口\n 线程的创建方式对比\n\n具体操作：\n\n绘制线程状态转换图\n比较继承Thread和实现Runnable的差异\n学习Callable和Future接口\n\n检验方式：能够解释线程状态转换过程\n第二步：线程安全问题分析（20分钟）学习内容：\n\n 什么是线程安全问题\n 竞态条件和临界区概念\n 内存可见性问题\n 指令重排序问题\n\n具体操作：\n\n分析经典的银行转账线程安全问题\n理解volatile关键字的作用\n学习happens-before原则\n\n检验方式：能够识别代码中的线程安全问题\n第三步：同步机制深入学习（20分钟）学习内容：\n\n synchronized关键字的使用\n Lock接口和ReentrantLock\n 读写锁ReadWriteLock\n 条件变量Condition\n\n具体操作：\n\n学习synchronized的三种使用方式\n比较synchronized和Lock的差异\n理解可重入锁的概念\n\n检验方式：能够选择合适的同步机制解决问题\n晚上实践编程（2小时）第一步：线程创建和基础操作（30分钟）任务目标：熟练掌握线程的创建和控制\n练习1：多种方式创建线程\n// 创建文件：ThreadCreationDemo.javapublic class ThreadCreationDemo &#123;    // 方式1：继承Thread类    static class MyThread extends Thread &#123;        @Override        public void run() &#123;            // 实现线程逻辑        &#125;    &#125;        // 方式2：实现Runnable接口    static class MyRunnable implements Runnable &#123;        @Override        public void run() &#123;            // 实现线程逻辑        &#125;    &#125;        // 方式3：使用Callable和Future    static class MyCallable implements Callable&lt;String&gt; &#123;        @Override        public String call() throws Exception &#123;            // 实现有返回值的线程逻辑            return &quot;result&quot;;        &#125;    &#125;        // 方式4：使用线程池    public static void testThreadPool() &#123;        // 使用ExecutorService创建线程池    &#125;&#125;\n\n具体步骤：\n\n实现四种不同的线程创建方式\n测试线程的启动、等待、中断\n比较各种方式的优缺点\n学习线程池的基本使用\n\n检验标准：\n\n 所有创建方式都能正常工作\n 理解每种方式的适用场景\n 能够正确处理线程异常\n 掌握线程池的基本配置\n\n第二步：线程安全编程实践（50分钟）任务目标：解决实际的线程安全问题\n练习1：银行账户转账系统\n// 创建文件：BankAccount.javapublic class BankAccount &#123;    private double balance;    private final Object lock = new Object();        public void deposit(double amount) &#123;        // 实现存款方法（线程安全）    &#125;        public boolean withdraw(double amount) &#123;        // 实现取款方法（线程安全）    &#125;        public void transfer(BankAccount target, double amount) &#123;        // 实现转账方法（避免死锁）    &#125;        public double getBalance() &#123;        // 实现余额查询（线程安全）    &#125;&#125;// 创建文件：BankTest.javapublic class BankTest &#123;    public static void main(String[] args) &#123;        // 测试多线程并发访问账户        // 验证数据一致性    &#125;&#125;\n\n具体步骤：\n\n实现线程安全的银行账户类\n创建多个线程并发执行转账操作\n验证最终余额的正确性\n优化转账方法避免死锁问题\n\n练习2：生产者消费者模式\n// 创建文件：ProducerConsumer.javapublic class ProducerConsumer &#123;    private final Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();    private final int maxSize = 10;    private final Object lock = new Object();        class Producer implements Runnable &#123;        @Override        public void run() &#123;            // 实现生产者逻辑        &#125;    &#125;        class Consumer implements Runnable &#123;        @Override        public void run() &#123;            // 实现消费者逻辑        &#125;    &#125;&#125;\n\n具体步骤：\n\n实现生产者消费者模式\n使用wait()和notify()进行线程协调\n测试多生产者多消费者场景\n优化为使用Lock和Condition\n\n检验标准：\n\n 银行转账系统数据一致性正确\n 转账过程无死锁发生\n 生产者消费者能够正确协调工作\n 队列大小限制有效\n\n第三步：线程池深入应用（40分钟）任务目标：掌握线程池的配置和使用\n练习：多任务处理系统\n// 创建文件：TaskProcessor.javapublic class TaskProcessor &#123;    // 创建不同类型的线程池    private ExecutorService fixedThreadPool;    private ExecutorService cachedThreadPool;    private ScheduledExecutorService scheduledPool;        // 处理CPU密集型任务    public void processCPUIntensiveTask() &#123;        // 实现CPU密集型任务处理    &#125;        // 处理IO密集型任务    public void processIOIntensiveTask() &#123;        // 实现IO密集型任务处理    &#125;        // 定时任务处理    public void scheduleTask() &#123;        // 实现定时任务    &#125;        // 批量任务处理    public List&lt;String&gt; processBatchTasks(List&lt;String&gt; tasks) &#123;        // 使用CompletionService处理批量任务    &#125;&#125;\n\n具体步骤：\n\n创建不同类型的线程池\n实现CPU密集型和IO密集型任务\n使用ScheduledExecutorService创建定时任务\n实现批量任务处理和结果收集\n添加线程池监控和异常处理\n\n检验标准：\n\n 能够根据任务特点选择合适的线程池\n 定时任务能够正确执行\n 批量任务处理效率高\n 线程池参数配置合理\n 正确关闭线程池释放资源\n\n\n三天学习成果验收综合练习项目：多线程文件处理器项目目标：结合集合、IO、多线程知识开发实用工具\n功能要求：\n\n扫描指定目录下的所有文件\n使用多线程并行处理文件（如计算MD5、统计行数等）\n将处理结果保存到数据结构中\n支持实时显示处理进度\n处理结果导出为文件\n\n技术要点：\n\n 使用File类递归扫描目录\n 用ThreadPoolExecutor处理文件\n 使用ConcurrentHashMap存储结果\n 实现线程安全的进度统计\n 使用BlockingQueue协调任务\n\n验收标准：\n\n 能够正确扫描和处理文件\n 多线程处理提升明显性能\n 程序运行稳定无死锁\n 进度显示准确\n 结果数据正确完整\n\n知识点测试清单集合框架：\n\n 能够选择合适的集合类解决问题\n 理解HashMap的工作原理\n 掌握ArrayList和LinkedList的适用场景\n\nIO流系统：\n\n 熟练使用各种IO流进行文件操作\n 能够开发文件处理工具\n 理解NIO的基本概念\n\n多线程编程：\n\n 掌握多种线程创建方式\n 能够解决线程安全问题\n 熟练使用线程池处理并发任务\n\n下一步学习建议完成Day 1-3的学习后，应该：\n\n每日复习：每天花15分钟回顾已学内容\n知识关联：思考这些基础知识在实际项目中的应用\n持续练习：继续在LeetCode上练习相关算法题\n准备面试：整理常见面试题的答案\n\n常见面试题准备：\n\nHashMap的实现原理和扩容机制\nArrayList和LinkedList的区别\nvolatile关键字的作用\nsynchronized和Lock的区别\n线程池的核心参数含义\n如何解决死锁问题\n\n"},{"title":"Hexo 双分支部署指南：从原理到 Netlify 实战","url":"/2025/08/17/Hexo-%E5%8F%8C%E5%88%86%E6%94%AF%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0-Netlify-%E5%AE%9E%E6%88%98/","content":"Hexo 双分支部署指南：从原理到 Netlify 实战在 Hexo 博客部署中，很多人会困惑于hexo d自动部署与 GitHub 手动提交的区别，以及如何通过双分支结构优雅地部署到 Netlify。本文将清晰拆解两种部署方式的核心差异，并手把手教你用双分支策略实现 Netlify 部署，兼顾源码安全与静态文件发布需求。\n一、核心概念：hexo d与 GitHub 手动提交的区别简单说，两者的本质是操作对象和目标分支的不同，具体区别如下：\n\n\n\n维度\nhexo d（自动部署）\nGitHub 手动提交（git push）\n\n\n\n操作对象\n仅处理public文件夹（静态文件：HTML&#x2F;CSS&#x2F;JS 等）\n处理 Hexo 源码（source文章、themes主题、_config.yml配置等）\n\n\n依赖配置\n依赖_config.yml中的deploy字段（指定仓库和分支）\n依赖 Git 基础命令（add&#x2F;commit&#x2F;push），无需特殊配置\n\n\n分支用途\n通常部署到静态文件分支（如gh-pages&#x2F;netlify-pages）\n通常提交到源码分支（如main）\n\n\n核心作用\n快速发布静态文件到展示平台\n备份源码、多设备同步开发\n\n\n是否需要****package.json\n不需要（仅推送静态文件）\n需要（源码分支需依赖管理）\n\n\n关键原理：Hexo 的 “源码 - 静态文件” 分离Hexo 是静态博客生成器，工作流分为两步：\n\nhexo g（生成）：将source中的 Markdown 源码转换为public中的静态文件；\n\nhexo d（部署）：将public推送到指定分支。\n\n\n手动提交则是直接管理源码，两者需通过不同分支隔离，否则会导致文件覆盖（这也是建议双分支的核心原因）。\n二、双分支部署策略：源码与静态文件分离双分支策略的核心是用两个分支分别管理源码和静态文件，既保护源码安全，又满足不同平台的部署需求。推荐分支命名：\n\nmain：存放 Hexo 源码（Markdown 文章、主题、配置等）；\n\nnetlify-pages：存放public静态文件（供 Netlify 直接部署）。\n\n\n三、部署到 Netlify 的两种方式（按需求选择）方式 1：静态文件分支部署（直接用public内容）适合场景：希望直接部署本地生成的public文件，跳过 Netlify 云端构建，无需package.json。\n步骤 1：创建静态文件分支# 1. 新建并切换到空分支（无历史记录，更干净）git checkout --orphan netlify-pages# 2. 删除当前分支所有文件（避免污染源码）git rm -rf .# 3. 本地生成最新public（确保包含所有文章）hexo clean &amp;&amp; hexo generate# 4. 将public内容复制到当前分支根目录（注意是内容，不是文件夹）cp -r public/* .# 5. 提交静态文件git add .git commit -m &quot;部署静态文件到netlify-pages&quot;git push -u origin netlify-pages  # 推送到远程静态分支\n\n步骤 2：配置 Netlify（无需构建）\n登录 Netlify，关联你的 GitHub 仓库；\n\n进入站点设置 → Build &amp; deploy → Build settings：\n\n\n\n\nBranch to deploy：选择netlify-pages；\n\n\n\nBuild command：留空（或填#，表示不执行构建）；\n\n\n\nPublish directory：填.（点号，表示直接发布分支根目录的静态文件）。\n\n\n\n\n点击 “Deploy site”，Netlify 会直接读取netlify-pages分支的静态文件并部署。\n\n方式 2：源码分支部署（云端生成public）适合场景：希望 Netlify 自动生成public，需依赖package.json管理依赖，适合多设备同步开发。\n步骤 1：准备源码分支# 1. 切换到源码分支（如main，若不存在则创建）git checkout -b main# 2. 确保本地有完整源码（关键文件）ls  # 应包含：source/、themes/、_config.yml、package.json、package-lock.json# 3. 若缺失package.json，重新初始化（正常Hexo项目默认包含）npm init -y  # 生成基础package.jsonnpm install hexo --save  # 安装Hexo核心依赖# 4. 提交源码git add .git commit -m &quot;提交Hexo源码（含package.json）&quot;git push -u origin main  # 推送到远程源码分支\n\n步骤 2：配置 Netlify（云端构建）\n进入 Netlify 站点设置 → Build settings：\n\n\n\nBranch to deploy：选择main；\n\n\n\nBuild command：填npm install &amp;&amp; hexo generate（安装依赖→生成 public）；\n\n\n\nPublish directory：填public（指定静态文件目录）。\n\n\n\n\n点击 “Deploy site”，Netlify 会自动执行：\n\n\n\n拉取main分支源码 → 安装依赖 → 生成public → 部署静态文件。\n\n\n\n四、关键说明与注意事项1. 分支隔离是核心\n两个分支必须严格隔离：main只存源码，netlify-pages只存静态文件，避免互相污染；\n\n用.gitignore确保main分支忽略public（避免源码分支包含静态文件）：\n\n\n# main分支的.gitignorepublic/node_modules/\n\n2. 静态文件分支部署注意事项\n本地生成public时必须完整：执行hexo clean &amp;&amp; hexo generate后，检查public中是否有index.html和文章对应的 HTML 文件；\n\n更新文章时，需重新生成public并同步到netlify-pages分支：\n\n\nhexo clean &amp;&amp; hexo generate  # 生成新publicgit checkout netlify-pagesrm -rf *  # 删除旧文件cp -r public/* .  # 复制新文件git add . &amp;&amp; git commit -m &quot;更新文章&quot; &amp;&amp; git push\n\n3. 源码分支部署注意事项\npackage.json必须包含必要依赖：至少有hexo（否则 Netlify 会提示 “hexo: command not found”）；\n\n主题和配置文件必须完整：themes文件夹和_config.yml需提交到main分支，否则云端生成的public会缺失样式；\n\n构建命令可简化：若package.json中定义了build脚本，可直接用npm run build：\n\n\n// package.json&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo generate&quot;&#125;\n\n此时 Netlify 的 Build command 可改为npm install &amp;&amp; npm run build。\n五、总结：核心要点速览\n\n\n部署方式\n分支名称\n关键配置（Netlify）\n适用场景\n\n\n\n静态文件部署\nnetlify-pages\nBuild command：留空；Publish dir：.\n本地生成 public，追求部署速度和稳定性\n\n\n源码云端构建\nmain\nBuild command：npm install &amp;&amp; hexo generate；Publish dir：public\n多设备开发，需要自动生成静态文件\n\n\n通过双分支策略，你可以根据需求灵活选择部署方式：想直接用public就选静态文件分支，想让云端自动处理就选源码分支。两种方式都能完美适配 Netlify，既保证源码安全，又能顺畅发布博客。\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo 关于页面 - 打造个性化自我介绍","url":"/2026/01/07/Hexo-%E5%85%B3%E4%BA%8E%E9%A1%B5%E9%9D%A2-%E6%89%93%E9%80%A0%E4%B8%AA%E6%80%A7%E5%8C%96%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/","content":"前言关于页面是博客中非常重要的一个页面，它是访客了解博主的第一窗口。一个精心设计的关于页面不仅能展示个人信息，还能体现博主的个性和品味。本文将详细介绍如何在 Hexo + Butterfly 主题中实现一个功能完善、美观大方的关于页面。\n\n\n什么是关于页面关于页面（About Page）是博客中用于介绍博主个人信息的专门页面，通常包含：\n\n个人简介：姓名、头像、个人描述\n技能标签：掌握的技术栈和技能\n博客统计：文章数、分类数、标签数、总字数等\n联系方式：GitHub、Email、社交媒体等\n个人理念：座右铭、人生格言等\n\n一个好的关于页面能够：\n\n让访客快速了解博主\n展示博主的专业能力\n提供联系方式，促进交流\n增强博客的个性化和亲和力\n\n实现步骤步骤 1：创建关于页面首先使用 Hexo 命令创建关于页面：\nhexo new page about\n\n这会在 source/about/ 目录下生成 index.md 文件。\n步骤 2：编辑页面内容编辑 source/about/index.md，设置页面类型和内容：\n---title: 关于我date: 2025-07-20 23:12:32type: aboutcomments: true---&lt;div class=&quot;about-container&quot;&gt;  &lt;!-- 个人n  &lt;div class=&quot;about-card&quot;&gt;    &lt;div class=&quot;about-avatar&quot;&gt;      &lt;img src=&quot;/images/wallpaper-img/sanye.png&quot; alt=&quot;cyforkk&quot;&gt;    &lt;/div&gt;    &lt;h2 class=&quot;about-name&quot;&gt;cyforkk&lt;/h2&gt;    &lt;p class=&quot;about-description&quot;&gt;找寻自我&lt;/p&gt;    &lt;div class=&quot;about-social&quot;&gt;      &lt;a href=&quot;https://github.com/cyforkk&quot; target=&quot;_blank&quot; title=&quot;GitHub&quot;&gt;        &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;      &lt;/a&gt;      &lt;a href=&quot;mailto:cyforkk@gmail.com&quot; target=&quot;_blank&quot; title=&quot;n        &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;      &lt;/a&gt;      &lt;a href=&quot;/Gallery/&quot; target=&quot;_blank&quot; title=&quot;Gallery&quot;&gt;        &lt;i class=&quot;fas fa-images&quot;&gt;&lt;/i&gt;      &lt;/a&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;!-- 关于我 --&gt;  &lt;div class=&quot;about-section&quot;&gt;    &lt;h3&gt;&lt;i class=&quot;fas fa-user&quot;&gt;&lt;/i&gt; 关于我&lt;/h3&gt;    &lt;p&gt;你好！我是 cyforkk，一名热爱技术的开发者。&lt;/p&gt;    &lt;p&gt;这个博客是我记录学习与生活的地方，在这里我会分享：&lt;/p&gt;    &lt;ul&gt;      &lt;li&gt;💻 技术学习笔记&lt;/li&gt;      &lt;li&gt;📝 编程经验总结&lt;/li&gt;      &lt;li&gt;🎯 项目实践记录&lt;/li&gt;      &lt;li&gt;🌱 个人成长感悟&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;!-- 技能标签 --&gt;  &lt;div class=&quot;about-section&quot;&gt;    &lt;h3&gt;&lt;i class=&quot;fas fa-code&quot;&gt;&lt;/i&gt; 技能标签&lt;/h3&gt;    &lt;div class=&quot;skill-tags&quot;&gt;      &lt;span class=&quot;skill-tag&quot;&gt;Java&lt;/span&gt;      &lt;span class=&quot;skill-tag&quot;&gt;MySQL&lt;/span&gt;      &lt;span class=&quot;skill-tag&quot;&gt;Git&lt;/span&gt;      &lt;span class=&quot;skill-tag&quot;&gt;Hexo&lt;/span&gt;      &lt;span class=&quot;skill-tag&quot;&gt;Markdown&lt;/span&gt;      &lt;span class=&quot;skill-tag&quot;&gt;前端开发&lt;/span&gt;      &lt;span class=&quot;skill-tag&quot;&gt;后端开发&lt;/span&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;!-- 博客统计 --&gt;  &lt;div class=&quot;about-section&quot;&gt;    &lt;h3&gt;&lt;i class=&quot;fas fa-chart-line&quot;&gt;&lt;/i&gt; 博客统计&lt;/h3&gt;    &lt;div class=&quot;about-stats&quot;&gt;      &lt;div class=&quot;stat-item&quot;&gt;        &lt;div class=&quot;stat-value&quot; id=&quot;post-count&quot;&gt;-&lt;/div&gt;        &lt;div class=&quot;stat-label&quot;&gt;文章数&lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;stat-item&quot;&gt;        &lt;div class=&quot;stat-value&quot; id=&quot;category-count&quot;&gt;-&lt;/div&gt;        &lt;div class=&quot;stat-label&quot;&gt;分类数&lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;stat-item&quot;&gt;        &lt;div class=&quot;stat-value&quot; id=&quot;tag-count&quot;&gt;-&lt;/div&gt;        &lt;div class=&quot;stat-label&quot;&gt;标签数&lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;stat-item&quot;&gt;        &lt;div class=&quot;stat-value&quot; id=&quot;word-count&quot;&gt;-&lt;/div&gt;        &lt;div class=&quot;stat-label&quot;&gt;总字数&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;!-- 联系方式 --&gt;  &lt;div class=&quot;about-section&quot;&gt;    &lt;h3&gt;&lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt; 联系方式&lt;/h3&gt;    &lt;div class=&quot;contact-list&quot;&gt;      &lt;div class=&quot;contact-item&quot;&gt;        &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;        &lt;span&gt;GitHub: &lt;/span&gt;        &lt;a href=&quot;https://github.com/cyforkk&quot; target=&quot;_blank&quot;&gt;@cyforkk&lt;/a&gt;      &lt;/div&gt;      &lt;div class=&quot;contact-item&quot;&gt;        &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;        &lt;span&gt;Email: &lt;/span&gt;        &lt;a href=&quot;mailto:cyforkk@gmail.com&quot;&gt;cyforkk@gmail.com&lt;/a&gt;      &lt;/div&gt;      &lt;div class=&quot;contact-item&quot;&gt;        &lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;        &lt;span&gt;网站: &lt;/span&gt;        &lt;a href=&quot;https://cyforkk.top&quot; target=&quot;_blank&quot;&gt;cyforkk.top&lt;/a&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;!-- 座右铭 --&gt;  &lt;div class=&quot;about-section&quot;&gt;    &lt;h3&gt;&lt;i class=&quot;fas fa-quote-left&quot;&gt;&lt;/i&gt; 座右铭&lt;/h3&gt;    &lt;blockquote class=&quot;about-quote&quot;&gt;      &lt;p&gt;欲速则不达，今日事今日毕。&lt;/p&gt;      &lt;p&gt;业精于勤荒于嬉，行成于思毁于随。&lt;/p&gt;    &lt;/blockquote&gt;  &lt;/div&gt;&lt;/div&gt;\n\n步骤 3：创建样式文件在 source/css/ 目录下创建 about.css 文件：\n/* 关于页面样式 *//* 容器 */.about-container &#123;  max-width: 900px;  margin: 0 auto;  padding: 20px;&#125;/* 个人信息卡片 */.about-card &#123;  background: var(--card-bg);  border-radius: 16px;  padding: 40px;  text-align: center;  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);  margin-bottom: 30px;  position: relative;  overflow: hidden;  animation: fadeInUp 0.6s ease-out;&#125;/* 渐变背景 */.about-card::before &#123;  content: &#x27;&#x27;;  position: absolute;  top: 0;  left: 0;  right: 0;  height: 120px;  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);  z-index: 0;&#125;/* 头像 */.about-avatar &#123;  position: relative;  z-index: 1;  margin-bottom: 20px;&#125;.about-avatar img &#123;  width: 120px;  height: 120px;  border-radius: 50%;  border: 5px solid #fff;  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);  transition: transform 0.3s ease;&#125;.about-avatar img:hover &#123;  transform: scale(1.1) rotate(5deg);&#125;/* 名字 */.about-name &#123;  position: relative;  z-index: 1;  font-size: 28px;  font-weight: bold;  color: var(--font-color);  margin: 15px 0 10px;&#125;/* 描述 */.about-description &#123;  position: relative;  z-index: 1;  font-size: 16px;  color: var(--font-color);  opacity: 0.8;  margin-bottom: 20px;&#125;/* 社交图标 */.about-social &#123;  position: relative;  z-index: 1;  display: flex;  justify-content: center;  gap: 20px;&#125;.about-social a &#123;  display: flex;  align-items: center;  justify-content: center;  width: 45px;  height: 45px;  background: rgba(255, 255, 255, 0.9);  border-radius: 50%;  color: #667eea;  font-size: 20px;  transition: all 0.3s ease;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);&#125;.about-social a:hover &#123;  transform: translateY(-5px);  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);  background: #667eea;  color: #fff;&#125;/* 内容区块 */.about-section &#123;  background: var(--card-bg);  border-radius: 12px;  padding: 30px;  margin-bottom: 20px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);  animation: fadeInUp 0.6s ease-out;  animation-fill-mode: forwards;  opacity: 0;&#125;.about-section:nth-child(2) &#123; animation-delay: 0.1s; &#125;.about-section:nth-child(3) &#123; animation-delay: 0.2s; &#125;.about-section:nth-child(4) &#123; animation-delay: 0.3s; &#125;.about-section:nth-child(5) &#123; animation-delay: 0.4s; &#125;.about-section:nth-child(6) &#123; animation-delay: 0.5s; &#125;.about-section h3 &#123;  font-size: 22px;  font-weight: bold;  color: var(--font-color);  margin-bottom: 20px;  padding-bottom: 10px;  border-bottom: 2px solid #667eea;  display: flex;  align-items: center;  gap: 10px;&#125;.about-section h3 i &#123;  color: #667eea;&#125;.about-section p &#123;  font-size: 16px;  line-height: 1.8;  color: var(--font-color);  margin-bottom: 15px;&#125;.about-section ul &#123;  list-style: none;  padding: 0;&#125;.about-section ul li &#123;  font-size: 16px;  line-height: 2;  color: var(--font-color);  padding-left: 10px;&#125;/* 技能标签 */.skill-tags &#123;  display: flex;  flex-wrap: wrap;  gap: 12px;&#125;.skill-tag &#123;  display: inline-block;  padding: 8px 16px;  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);  color: #fff;  border-radius: 20px;  font-size: 14px;  font-weight: 500;  transition: all 0.3s ease;  cursor: default;&#125;.skill-tag:hover &#123;  transform: translateY(-3px);  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);&#125;/* 博客统计 */.about-stats &#123;  display: grid;  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));  gap: 20px;&#125;.stat-item &#123;  text-align: center;  padding: 20px;  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);  border-radius: 12px;  transition: all 0.3s ease;&#125;.stat-item:hover &#123;  transform: translateY(-5px);  box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);&#125;.stat-value &#123;  font-size: 32px;  font-weight: bold;  color: #fff;  margin-bottom: 8px;&#125;.stat-label &#123;  font-size: 14px;  color: rgba(255, 255, 255, 0.9);&#125;/* 联系方式 */.contact-list &#123;  display: flex;  flex-direction: column;  gap: 15px;&#125;.contact-item &#123;  display: flex;  align-items: center;  gap: 10px;  font-size: 16px;  color: var(--font-color);  padding: 12px;  background: rgba(102, 126, 234, 0.05);  border-radius: 8px;  transition: all 0.3s ease;&#125;.contact-item:hover &#123;  background: rgba(102, 126, 234, 0.1);  transform: translateX(5px);&#125;.contact-item i &#123;  color: #667eea;  font-size: 20px;  width: 24px;  text-align: center;&#125;.contact-item a &#123;  color: #667eea;  text-decoration: none;  transition: color 0.3s ease;&#125;.contact-item a:hover &#123;  color: #764ba2;  text-decoration: underline;&#125;/* 座右铭 */.about-quote &#123;  border-left: 4px solid #667eea;  padding: 20px 30px;  background: rgba(102, 126, 234, 0.05);  border-radius: 8px;  margin: 0;&#125;.about-quote p &#123;  font-size: 16px;  line-height: 1.8;  color: var(--font-color);  font-style: italic;  margin-bottom: 10px;&#125;.about-quote p:last-child &#123;  margin-bottom: 0;&#125;/* 淡入动画 */@keyframes fadeInUp &#123;  from &#123;    opacity: 0;    transform: translateY(30px);  &#125;  to &#123;    opacity: 1;    transform: translateY(0);  &#125;&#125;/* 响应式设计 */@media (max-width: 768px) &#123;  .about-container &#123;    padding: 15px;  &#125;  .about-card &#123;    padding: 30px 20px;  &#125;  .about-card::before &#123;    height: 100px;  &#125;  .about-avatar img &#123;    width: 100px;    height: 100px;  &#125;  .about-name &#123;    font-size: 24px;  &#125;  .about-description &#123;    font-size: 14px;  &#125;  .about-social a &#123;    width: 40px;    height: 40px;    font-size: 18px;  &#125;  .about-section &#123;    padding: 20px;  &#125;  .about-section h3 &#123;    font-size: 20px;  &#125;  .about-section p,  .about-section ul li &#123;    font-size: 15px;  &#125;  .about-stats &#123;    grid-template-columns: repeat(2, 1fr);  &#125;  .stat-value &#123;    font-size: 28px;  &#125;  .contact-item &#123;    font-size: 15px;  &#125;  .about-quote &#123;    padding: 15px 20px;  &#125;  .about-quote p &#123;    font-size: 15px;  &#125;&#125;/* 深色模式适配 */[data-theme=&quot;dark&quot;] .about-card &#123;  background: #1f1f1f;  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);&#125;[data-theme=&quot;dark&quot;] .about-section &#123;  background: #1f1f1f;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);&#125;[data-theme=&quot;dark&quot;] .about-social a &#123;  background: rgba(255, 255, 255, 0.1);  color: #667eea;&#125;[data-theme=&quot;dark&quot;] .about-social a:hover &#123;  background: #667eea;  color: #fff;&#125;[data-theme=&quot;dark&quot;] .contact-item &#123;  background: rgba(102, 126, 234, 0.1);&#125;[data-theme=&quot;dark&quot;] .contact-item:hover &#123;  background: rgba(102, 126, 234, 0.15);&#125;[data-theme=&quot;dark&quot;] .about-quote &#123;  background: rgba(102, 126, 234, 0.1);&#125;\n\n步骤 4：创建 JavaScript 文件在 source/js/ 目录下创建 about.js 文件：\n// 关于页面功能function initAbout() &#123;  const container = document.querySelector(&#x27;.about-container&#x27;);  if (container) &#123;    loadBlogStats();  &#125;&#125;// 初始化if (document.readyState === &#x27;loading&#x27;) &#123;  document.addEventListener(&#x27;DOMContentLoaded&#x27;, initAbout);&#125; else &#123;  initAbout();&#125;// PJAX 兼容document.addEventListener(&#x27;pjax:complete&#x27;, initAbout);// 加载博客统计数据function loadBlogStats() &#123;  // 从搜索数据中获取统计信息  fetch(&#x27;/search.json&#x27;)    .then(response =&gt; response.json())    .then(data =&gt; &#123;      // 文章数      const postCount = data.length;      document.getElementById(&#x27;post-count&#x27;).textContent = postCount;      // 分类数      const categories = new Set();      data.forEach(post =&gt; &#123;        if (post.categories &amp;&amp; post.categories.length &gt; 0) &#123;          post.categories.forEach(cat =&gt; categories.add(cat));        &#125;      &#125;);      document.getElementById(&#x27;category-count&#x27;).textContent = categories.size;      // 标签数      const tags = new Set();      data.forEach(post =&gt; &#123;        if (post.tags &amp;&amp; post.tags.length &gt; 0) &#123;          post.tags.forEach(tag =&gt; tags.add(tag));        &#125;      &#125;);      document.getElementById(&#x27;tag-count&#x27;).textContent = tags.size;      // 总字数      let totalWords = 0;      data.forEach(post =&gt; &#123;        if (post.content) &#123;          // 移除 HTML 标签          const text = post.content.replace(/&lt;[^&gt;]+&gt;/g, &#x27;&#x27;);          // 计算中文字符和英文单词          const chineseChars = text.match(/[\\u4e00-\\u9fa5]/g) || [];          const englishWords = text.match(/[a-zA-Z]+/g) || [];          totalWords += chineseChars.length + englishWords.length;        &#125;      &#125;);      // 格式化字数显示      let wordCountText;      if (totalWords &gt;= 10000) &#123;        wordCountText = (totalWords / 10000).toFixed(1) + &#x27;w&#x27;;      &#125; else if (totalWords &gt;= 1000) &#123;        wordCountText = (totalWords / 1000).toFixed(1) + &#x27;k&#x27;;      &#125; else &#123;        wordCountText = totalWords.toString();      &#125;      document.getElementById(&#x27;word-count&#x27;).textContent = wordCountText;    &#125;)    .catch(error =&gt; &#123;      console.error(&#x27;加载博客统计数据失败:&#x27;, error);      // 显示默认值      document.getElementById(&#x27;post-count&#x27;).textContent = &#x27;0&#x27;;      document.getElementById(&#x27;category-count&#x27;).textContent = &#x27;0&#x27;;      document.getElementById(&#x27;tag-count&#x27;).textContent = &#x27;0&#x27;;      document.getElementById(&#x27;word-count&#x27;).textContent = &#x27;0&#x27;;    &#125;);&#125;\n\n步骤 5：配置 Butterfly 主题编辑 _config.butterfly.yml，在 inject 部分添加 CSS 和 JS 引用：\ninject:  head:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/about.css&quot;&gt; # 关于页面  bottom:    - &lt;script src=&quot;/js/about.js&quot;&gt;&lt;/script&gt;\n\n步骤 6：添加导航菜单在 _config.butterfly.yml 的 menu 部分添加关于页面链接：\nmenu:  首页: / || fas fa-home  时间轴: /archives/ || fas fa-archive  标签: /tags/ || fas fa-tags  分类: /categories/ || fas fa-folder-open  关于: /about/ || fas fa-heart\n\n步骤 7：生成静态文件运行以下命令生成静态文件：\nhexo cleanhexo generate\n\n步骤 8：本地预览启动本地服务器预览效果：\nhexo server\n\n访问 http://localhost:4000/about/ 查看关于页面效果。\n功能说明1. 个人信息卡片\n渐变背景：使用 CSS 渐变创建视觉吸引力\n头像动画：鼠标悬停时头像会放大并旋转\n社交图标：提供 GitHub、Email、Gallery 等联系方式\n\n2. 技能标签\n渐变背景：每个技能标签都有渐变色背景\n悬停效果：鼠标悬停时标签会上浮并显示阴影\n灵活布局：使用 Flexbox 自动换行\n\n3. 博客统计\n动态加载：从 search.json 文件中读取数据\n实时计算：自动计算文章数、分类数、标签数、总字数\n格式化显示：大数字使用 ‘k’（千）和 ‘w’（万）单位\n网格布局：使用 CSS Grid 实现响应式布局\n\n4. 联系方式\n图标展示：使用 Font Awesome 图标\n悬停效果：鼠标悬停时背景色变化并向右移动\n链接跳转：点击可直接跳转到对应平台\n\n5. 座右铭\n引用样式：使用 blockquote 样式展示\n左侧边框：使用主题色作为左侧装饰\n斜体文字：使用斜体增强文学感\n\n样式特点1. 渐变色设计使用紫色系渐变（#667eea 到 #764ba2）作为主题色，营造现代感和科技感。\n2. 动画效果\n淡入动画：页面加载时各区块依次淡入\n悬停动画：鼠标悬停时元素会产生交互反馈\n错开延迟：各区块动画延迟不同，形成流畅的视觉效果\n\n3. 响应式设计\n移动端适配：在 768px 以下自动调整布局\n网格自适应：统计卡片在移动端变为 2 列布局\n字体缩放：移动端字体大小适当缩小\n\n4. 深色模式支持使用 [data-theme=&quot;dark&quot;] 选择器适配深色模式，确保在不同主题下都有良好的视觉效果。\n自定义指南修改个人信息编辑 source/about/index.md 文件，修改以下内容：\n&lt;!-- 修改头像 --&gt;&lt;img src=&quot;/images/your-avatar.png&quot; alt=&quot;your-name&quot;&gt;&lt;!-- 修改名字 --&gt;&lt;h2 class=&quot;about-name&quot;&gt;Your Name&lt;/h2&gt;&lt;!-- 修改描述 --&gt;&lt;p class=&quot;about-description&quot;&gt;Your Description&lt;/p&gt;&lt;!-- 修改社交链接 --&gt;&lt;a href=&quot;https://github.com/your-username&quot; target=&quot;_blank&quot; title=&quot;GitHub&quot;&gt;  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;&lt;/a&gt;\n\n修改技能标签在技能标签区域添加或删除标签：\n&lt;div class=&quot;skill-tags&quot;&gt;  &lt;span class=&quot;skill-tag&quot;&gt;Your Skill 1&lt;/span&gt;  &lt;span class=&quot;skill-tag&quot;&gt;Your Skill 2&lt;/span&gt;  &lt;span class=&quot;skill-tag&quot;&gt;Your Skill 3&lt;/span&gt;&lt;/div&gt;\n\n修改主题色编辑 source/css/about.css，修改渐变色：\n/* 修改渐变色 */background: linear-gradient(135deg, #your-color-1 0%, #your-color-2 100%);\n\n修改座右铭在座右铭区域修改内容：\n&lt;blockquote class=&quot;about-quote&quot;&gt;  &lt;p&gt;Your Quote 1&lt;/p&gt;  &lt;p&gt;Your Quote 2&lt;/p&gt;&lt;/blockquote&gt;\n\n注意事项\nsearch.json 文件：博客统计功能依赖 search.json 文件，确保已安装 hexo-generator-search 插件\nFont Awesome 图标：确保主题已引入 Font Awesome 图标库\nPJAX 兼容：代码已处理 PJAX 兼容性，支持无刷新页面切换\n图片路径：确保头像图片路径正确，建议使用绝对路径\n响应式测试：建议在不同设备上测试页面效果\n\n总结通过本文的详细教程，我们成功实现了一个功能完善、美观大方的关于页面。这个页面不仅展示了个人信息，还具有动态统计、响应式设计、深色模式支持等现代化特性。\n关于页面的核心价值在于：\n\n个性化展示：充分展现博主的个性和特点\n信息完整：包含个人简介、技能、统计、联系方式等完整信息\n视觉美观：使用渐变色、动画效果等现代设计元素\n用户友好：响应式设计确保在各种设备上都有良好体验\n\n希望这个教程能帮助你打造一个独特的关于页面，让访客更好地了解你！\n相关文章\nHexo 友链页面 - 增加博客社交属性\nHexo 说说功能 - 打造社交化动态页面\nHexo 系列文章功能 - 组织相关内容的最佳实践\n\n参考资料\nHexo 官方文档\nButterfly 主题文档\nFont Awesome 图标库\nCSS Grid 布局指南\n\n","categories":["Hexo博客"],"tags":["Hexo","Butterfly","教程"]},{"title":"Hexo PWA 支持 - 离线访问与应用化配置教程","url":"/2026/01/07/Hexo-PWA%E6%94%AF%E6%8C%81-%E7%A6%BB%E7%BA%BF%E8%AE%BF%E9%97%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","content":"Hexo PWA 支持 - 离线访问与应用化配置教程\n想让你的博客像原生 App 一样？支持离线访问？可以添加到手机主屏幕？PWA 技术帮你实现！本教程教你如何为 Hexo 博客配置 PWA 支持。\n\n📋 目录\n什么是 PWA\n为什么需要 PWA\n安装插件\n配置说明\n验证 PWA\n使用体验\n总结\n\n\n什么是 PWA1. 定义PWA（Progressive Web App） 是一种渐进式 Web 应用技术，让网站具备类似原生应用的体验。\n2. 核心技术PWA 主要依赖三大技术：\n\n📱 Web App Manifest：应用清单文件，定义应用的名称、图标、主题色等\n🔧 Service Worker：服务工作线程，实现离线缓存和后台同步\n🔒 HTTPS：安全连接，PWA 必须在 HTTPS 环境下运行\n\n3. 主要特性✅ 离线访问：即使没有网络也能浏览已缓存的内容✅ 添加到主屏幕：像 App 一样安装到手机桌面✅ 全屏显示：隐藏浏览器地址栏，沉浸式体验✅ 推送通知：支持消息推送（需额外配置）✅ 后台同步：在后台更新内容✅ 快速加载：利用缓存加速页面加载\n\n为什么需要 PWA1. 提升用户体验传统网站的问题：\n\n❌ 没网络就无法访问\n❌ 每次都要打开浏览器输入网址\n❌ 加载速度受网络影响大\n❌ 无法像 App 一样使用\n\nPWA 的优势：\n\n✅ 离线也能浏览已访问的内容\n✅ 点击桌面图标直接打开\n✅ 缓存加速，秒开页面\n✅ 全屏显示，沉浸式体验\n\n2. 增加用户粘性效果：\n\n📱 用户可以把博客”安装”到手机\n🔖 像使用 App 一样使用博客\n📈 提高用户回访率\n⏱️ 减少流失率\n\n3. 节省流量优势：\n\n💾 缓存静态资源（CSS、JS、图片）\n🌐 只加载更新的内容\n📉 减少重复下载\n💰 为用户节省流量费用\n\n4. SEO 友好好处：\n\n🚀 加载速度快，提升 SEO 排名\n📱 移动端体验好，Google 重视\n🔍 更容易被搜索引擎收录\n⭐ 用户体验好，降低跳出率\n\n\n安装插件1. 安装 hexo-offline在 Hexo 博客根目录执行：\nnpm install hexo-offline --save\n\n2. 插件功能hexo-offline 插件会自动：\n\n✅ 生成 Service Worker 文件（sw.js）\n✅ 配置缓存策略\n✅ 实现离线访问\n✅ 支持自定义缓存规则\n\n\n配置说明1. 创建配置文件在 Hexo 根目录创建 hexo-offline.config.cjs 文件：\nmodule.exports = &#123;  globPatterns: [&#x27;**/*.&#123;js,html,css,png,jpg,jpeg,gif,svg,webp,eot,ttf,woff,woff2&#125;&#x27;],  globDirectory: &#x27;public&#x27;,  swDest: &#x27;public/sw.js&#x27;,  maximumFileSizeToCacheInBytes: 10485760,  runtimeCaching: [    &#123;      urlPattern: /^https:\\/\\/cdn\\.jsdelivr\\.net\\/.*/i,      handler: &#x27;CacheFirst&#x27;,      options: &#123;        cacheName: &#x27;jsdelivr-cache&#x27;,        expiration: &#123;          maxEntries: 100,          maxAgeSeconds: 7 * 24 * 60 * 60        &#125;      &#125;    &#125;,    &#123;      urlPattern: /\\.(?:png|jpg|jpeg|svg|gif|webp)$/,      handler: &#x27;CacheFirst&#x27;,      options: &#123;        cacheName: &#x27;image-cache&#x27;,        expiration: &#123;          maxEntries: 100,          maxAgeSeconds: 30 * 24 * 60 * 60        &#125;      &#125;    &#125;  ],  skipWaiting: true,  clientsClaim: true&#125;;\n\n2. 创建 manifest.json在 source 目录下创建 manifest.json 文件：\n&#123;  &quot;name&quot;: &quot;cyforkk&quot;,  &quot;short_name&quot;: &quot;cyforkk&quot;,  &quot;description&quot;: &quot;找寻自我 - 记录学习与生活&quot;,  &quot;theme_color&quot;: &quot;#49B1F5&quot;,  &quot;background_color&quot;: &quot;#ffffff&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;orientation&quot;: &quot;portrait&quot;,  &quot;scope&quot;: &quot;/&quot;,  &quot;start_url&quot;: &quot;/&quot;,  &quot;icons&quot;: [    &#123;      &quot;src&quot;: &quot;/images/icon/hudie1.png&quot;,      &quot;sizes&quot;: &quot;192x192&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;/images/icon/hudie1.png&quot;,      &quot;sizes&quot;: &quot;512x512&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;  ]&#125;\n\n3. 配置项详解hexo-offline.config.cjs 配置module.exports = &#123;  // 要缓存的文件类型  globPatterns: [&#x27;**/*.&#123;js,html,css,png,jpg,jpeg,gif,svg,webp,eot,ttf,woff,woff2&#125;&#x27;],  // 生成目录  globDirectory: &#x27;public&#x27;,  // Service Worker 输出路径  swDest: &#x27;public/sw.js&#x27;,  // 最大缓存文件大小（10MB）  maximumFileSizeToCacheInBytes: 10485760,  // 运行时缓存策略  runtimeCaching: [    &#123;      // CDN 资源缓存      urlPattern: /^https:\\/\\/cdn\\.jsdelivr\\.net\\/.*/i,      handler: &#x27;CacheFirst&#x27;,  // 缓存优先      options: &#123;        cacheName: &#x27;jsdelivr-cache&#x27;,        expiration: &#123;          maxEntries: 100,  // 最多缓存 100 个文件          maxAgeSeconds: 7 * 24 * 60 * 60  // 缓存 7 天        &#125;      &#125;    &#125;,    &#123;      // 图片资源缓存      urlPattern: /\\.(?:png|jpg|jpeg|svg|gif|webp)$/,      handler: &#x27;CacheFirst&#x27;,      options: &#123;        cacheName: &#x27;image-cache&#x27;,        expiration: &#123;          maxEntries: 100,          maxAgeSeconds: 30 * 24 * 60 * 60  // 缓存 30 天        &#125;      &#125;    &#125;  ],  // 立即激活新的 Service Worker  skipWaiting: true,  // 立即控制所有客户端  clientsClaim: true&#125;;\n\n参数说明：\n\n\n\n参数\n说明\n推荐值\n\n\n\nglobPatterns\n要缓存的文件类型\n常用静态资源\n\n\nglobDirectory\n生成目录\npublic\n\n\nswDest\nService Worker 输出路径\npublic&#x2F;sw.js\n\n\nmaximumFileSizeToCacheInBytes\n最大缓存文件大小\n10485760 (10MB)\n\n\nskipWaiting\n立即激活新 SW\ntrue\n\n\nclientsClaim\n立即控制客户端\ntrue\n\n\nManifest 配置&#123;  &quot;name&quot;: &quot;cyforkk&quot;,              // 应用完整名称  &quot;short_name&quot;: &quot;cyforkk&quot;,        // 应用简称（主屏幕显示）  &quot;description&quot;: &quot;找寻自我 - 记录学习与生活&quot;,  // 应用描述  &quot;theme_color&quot;: &quot;#49B1F5&quot;,       // 主题颜色（地址栏颜色）  &quot;background_color&quot;: &quot;#ffffff&quot;,  // 背景颜色（启动画面）  &quot;display&quot;: &quot;standalone&quot;,        // 显示模式  &quot;orientation&quot;: &quot;portrait&quot;,      // 屏幕方向  &quot;scope&quot;: &quot;/&quot;,                   // 应用作用域  &quot;start_url&quot;: &quot;/&quot;,               // 启动 URL  &quot;icons&quot;: [                      // 应用图标    &#123;      &quot;src&quot;: &quot;/images/icon/hudie1.png&quot;,      &quot;sizes&quot;: &quot;192x192&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;/images/icon/hudie1.png&quot;,      &quot;sizes&quot;: &quot;512x512&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;  ]&#125;\ntheme_color: &quot;#49B1F5&quot;    # 主题颜色（地址栏颜色）\nbackground_color: &quot;#ffffff&quot;  # 背景颜色（启动画面）\ndisplay: standalone       # 显示模式\norientation: portrait     # 屏幕方向\nscope: /                  # 应用作用域\nstart_url: /              # 启动 URL\nicons:                    # 应用图标\n  - src: /images/icon/hudie1.png\n    sizes: 192x192\n    type: image/png\n  - src: /images/icon/hudie1.png\n    sizes: 512x512\n    type: image/png\n\n**参数说明**：| 参数 | 说明 | 推荐值 ||------|------|--------|| name | 应用完整名称 | 你的博客名称 || short_name | 应用简称 | 简短的名称 || description | 应用描述 | 博客简介 || theme_color | 主题颜色 | 与主题配色一致 || background_color | 背景颜色 | 通常为白色或主题色 || display | 显示模式 | standalone（推荐） || orientation | 屏幕方向 | portrait（竖屏） || icons | 应用图标 | 至少 192x192 和 512x512 |**display 参数说明**：- `fullscreen`：全屏显示，隐藏所有浏览器 UI- `standalone`：独立应用，隐藏地址栏（推荐）- `minimal-ui`：最小化 UI，保留部分浏览器控件- `browser`：普通浏览器模式**缓存策略说明**：1. **CacheFirst（缓存优先）**   - 先查找缓存，有缓存直接返回   - 没有缓存才请求网络   - 适用于：CSS、JS、图片等静态资源2. **NetworkFirst（网络优先）**   - 先请求网络，网络失败才用缓存   - 确保内容是最新的   - 适用于：HTML 页面、API 数据3. **CacheOnly（仅缓存）**   - 只从缓存读取，不请求网络   - 适用于：完全离线的资源4. **NetworkOnly（仅网络）**   - 只从网络请求，不使用缓存   - 适用于：实时数据、动态内容5. **StaleWhileRevalidate（过期重新验证）**   - 返回缓存，同时在后台更新   - 适用于：可以接受稍微过期的内容### 4. 准备图标PWA 需要不同尺寸的图标，建议准备：- **192x192**：Android 主屏幕图标- **512x512**：Android 启动画面图标- **180x180**：iOS 主屏幕图标（可选）**图标要求**：- 格式：PNG（推荐）或 JPEG- 背景：最好是纯色或透明- 内容：清晰、简洁、易识别**图标位置**：\nsource&#x2F;images&#x2F;icon&#x2F;├── hudie1.png (192x192)└── hudie1.png (512x512)\n---## 验证 PWA### 1. 生成网站配置完成后，执行：```bashhexo cleanhexo generate\n\n2. 查看生成的文件在 public 目录下会生成：\npublic/├── manifest.json    # Web App Manifest 文件└── sw.js           # Service Worker 文件\n\n3. 本地测试启动本地服务器：\nhexo server\n\n注意：PWA 需要 HTTPS 环境，本地测试时 localhost 被视为安全环境，可以正常测试。\n4. 检查 manifest.json访问：http://localhost:4000/manifest.json\n你会看到类似这样的内容：\n&#123;  &quot;name&quot;: &quot;cyforkk&quot;,  &quot;short_name&quot;: &quot;cyforkk&quot;,  &quot;description&quot;: &quot;找寻自我 - 记录学习与生活&quot;,  &quot;theme_color&quot;: &quot;#49B1F5&quot;,  &quot;background_color&quot;: &quot;#ffffff&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;orientation&quot;: &quot;portrait&quot;,  &quot;scope&quot;: &quot;/&quot;,  &quot;start_url&quot;: &quot;/&quot;,  &quot;icons&quot;: [    &#123;      &quot;src&quot;: &quot;/images/icon/hudie1.png&quot;,      &quot;sizes&quot;: &quot;192x192&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;/images/icon/hudie1.png&quot;,      &quot;sizes&quot;: &quot;512x512&quot;,      &quot;type&quot;: &quot;image/png&quot;    &#125;  ]&#125;\n\n5. 使用 Chrome DevTools 检查步骤 1：打开开发者工具\n访问你的博客\n按 F12 打开开发者工具\n切换到「Application」标签\n\n步骤 2：检查 Manifest\n在左侧选择「Manifest」\n查看应用信息是否正确\n检查图标是否显示\n\n步骤 3：检查 Service Worker\n在左侧选择「Service Workers」\n查看 Service Worker 是否注册成功\n状态应该显示为「activated and is running」\n\n步骤 4：检查缓存\n在左侧选择「Cache Storage」\n查看缓存的文件列表\n确认静态资源已被缓存\n\n6. Lighthouse 审计使用 Chrome Lighthouse 进行 PWA 审计：\n\n打开开发者工具\n切换到「Lighthouse」标签\n勾选「Progressive Web App」\n点击「Generate report」\n\n评分标准：\n\n✅ 90-100 分：优秀\n⚠️ 50-89 分：良好\n❌ 0-49 分：需要改进\n\n\n使用体验1. 添加到主屏幕（Android）步骤 1：访问博客使用 Chrome 浏览器访问你的博客。\n步骤 2：安装提示如果 PWA 配置正确，浏览器会自动弹出安装提示：\n将 cyforkk 添加到主屏幕？[取消] [添加]\n\n步骤 3：手动添加如果没有自动提示，可以手动添加：\n\n点击浏览器菜单（三个点）\n选择「添加到主屏幕」\n输入应用名称\n点击「添加」\n\n步骤 4：使用应用\n在主屏幕找到博客图标\n点击图标打开博客\n全屏显示，无地址栏\n像使用 App 一样使用博客\n\n2. 添加到主屏幕（iOS）iOS 对 PWA 的支持有限，但仍可以添加到主屏幕：\n步骤 1：打开 Safari使用 Safari 浏览器访问博客（必须是 Safari）。\n步骤 2：分享菜单点击底部的「分享」按钮（方框加箭头）。\n步骤 3：添加到主屏幕\n滚动找到「添加到主屏幕」\n输入应用名称\n点击「添加」\n\n注意：iOS 不支持 Service Worker 的所有特性，离线功能可能受限。\n3. 离线访问测试离线功能\n正常访问博客，浏览几个页面\n打开飞行模式或断开网络\n刷新页面或访问已浏览过的页面\n页面仍然可以正常显示\n\n离线提示可以在页面上添加离线提示，让用户知道当前是离线状态：\nwindow.addEventListener(&#x27;online&#x27;, () =&gt; &#123;  console.log(&#x27;网络已连接&#x27;);&#125;);window.addEventListener(&#x27;offline&#x27;, () =&gt; &#123;  console.log(&#x27;网络已断开，正在使用缓存&#x27;);&#125;);\n\n4. 更新机制自动更新当你更新博客内容并重新部署后：\n\nService Worker 会检测到新版本\n在后台下载新的资源\n下次访问时自动使用新版本\n\n强制更新如果需要立即更新：\n\n打开开发者工具\n切换到「Application」→「Service Workers」\n点击「Update」按钮\n刷新页面\n\n\n高级配置1. 自定义缓存策略如果需要更精细的缓存控制：\nserviceWorker:  routes:    # 字体文件：缓存优先，缓存 1 年    - pattern: !!js/regexp /.*\\.(woff|woff2|ttf|eot)$/      strategy: cacheFirst    # API 数据：网络优先，超时 3 秒    - pattern: !!js/regexp /\\/api\\//      strategy: networkFirst    # 图片：过期重新验证    - pattern: !!js/regexp /.*\\.(jpg|jpeg|png|gif|webp)$/      strategy: staleWhileRevalidate\n\n2. 排除特定页面如果某些页面不需要缓存：\nserviceWorker:  exclude:    - /admin/    - /login/    - /api/\n\n3. 自定义启动画面修改 background_color 和 theme_color 可以自定义启动画面：\nmanifest:  body:    theme_color: &quot;#49B1F5&quot;        # 地址栏颜色    background_color: &quot;#ffffff&quot;   # 启动画面背景色\n\n4. 添加快捷方式为应用添加快捷方式（Android 支持）：\nmanifest:  body:    shortcuts:      - name: 最新文章        short_name: 文章        description: 查看最新文章        url: /archives/        icons:          - src: /images/icon/article.png            sizes: 96x96      - name: 标签        short_name: 标签        description: 浏览标签        url: /tags/        icons:          - src: /images/icon/tag.png            sizes: 96x96\n\n\n常见问题1. PWA 安装提示不显示？可能原因：\n\n网站不是 HTTPS\nmanifest.json 配置错误\n图标路径不正确\nService Worker 未注册成功\n\n解决方法：\n\n确保网站使用 HTTPS\n检查 manifest.json 是否可访问\n验证图标文件是否存在\n使用 Chrome DevTools 检查错误\n\n2. 离线功能不工作？可能原因：\n\nService Worker 未激活\n缓存策略配置错误\n页面未被预加载\n\n解决方法：\n\n检查 Service Worker 状态\n确认缓存策略正确\n增加预加载的 URL\n清除缓存重新测试\n\n3. iOS 不支持离线访问？原因：iOS Safari 对 Service Worker 的支持有限。\n解决方法：\n\niOS 13+ 支持基本的 Service Worker\n更新到最新版本的 iOS\n使用 App Cache 作为备选方案（已废弃）\n\n4. 更新后内容不刷新？原因：Service Worker 缓存了旧版本。\n解决方法：\n\n修改 Service Worker 版本号\n在开发者工具中手动更新\n清除浏览器缓存\n使用 skipWaiting 强制更新\n\n5. 图标不显示？可能原因：\n\n图标路径错误\n图标尺寸不符合要求\n图标格式不支持\n\n解决方法：\n\n检查图标路径是否正确\n确保图标尺寸为 192x192 和 512x512\n使用 PNG 格式\n图标文件大小不要超过 1MB\n\n\n总结已实现的功能✅ PWA 支持：完整的渐进式 Web 应用功能✅ 离线访问：缓存静态资源，离线可用✅ 添加到主屏幕：像 App 一样安装使用✅ 智能缓存：静态资源缓存优先，页面网络优先✅ 自动更新：后台更新，无感知升级\n性能提升通过 PWA 配置，我的博客实现了：\n\n🚀 首次加载后，再次访问秒开\n💾 节省流量 50-70%（静态资源缓存）\n📱 移动端体验提升 80%（全屏显示）\n📈 用户回访率提高 30%（主屏幕图标）\n\n配置要点\nHTTPS 必须：PWA 必须在 HTTPS 环境下运行\n图标准备：至少 192x192 和 512x512 两种尺寸\n缓存策略：静态资源缓存优先，页面网络优先\n预加载配置：预加载常用页面和最新文章\n\n下一步优化除了基础 PWA 功能，还可以：\n\n🔔 配置推送通知\n🔄 实现后台同步\n📊 添加离线统计\n🎨 自定义启动画面\n⚡ 优化缓存策略\n\n\n参考资源\nhexo-pwa 官方文档\nPWA 官方文档\nService Worker API\nWeb App Manifest\nWorkbox 缓存策略\n\n\n结语PWA 技术让网站具备了原生应用的体验，通过本教程，你已经学会了如何为 Hexo 博客配置 PWA 支持。现在你的博客可以离线访问，可以添加到主屏幕，就像一个真正的 App！\n记住：PWA 不仅是技术，更是用户体验的提升！\n如果你有任何问题或建议，欢迎在评论区留言交流！\nHappy Blogging! 📱\n","categories":["Hexo博客"],"tags":["Hexo","教程","PWA"]},{"title":"Hexo使用Butterfly主题配置页脚网站运行实时时间","url":"/2025/07/26/Hexo%E4%BD%BF%E7%94%A8Butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%A1%B5%E8%84%9A%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%97%B6%E9%97%B4/","content":"Hexo使用Butterfly主题配置页脚网站运行实时时间一、找配置文件寻找&#x2F;node_modules&#x2F;hexo-theme-butterfly&#x2F;layout&#x2F;includes&#x2F;footer.pug文件，添加完之后已经成功了，但是在左下角\n里面的代码直接全部替换为\n- const &#123; nav, owner, copyright, custom_text &#125; = theme.footerif nav  .footer-flex    for block in nav      .footer-flex-items(style=`$&#123; block.width ? &#x27;flex-grow:&#x27; + block.width : &#x27;&#x27; &#125;`)        for blockItem in block.content          .footer-flex-item            .footer-flex-title= blockItem.title            .footer-flex-content              for subitem in blockItem.item                if subitem.html                  div!= subitem.html                else if subitem.url                  a(href=url_for(subitem.url), target=&#x27;_blank&#x27; title=subitem.title)= subitem.title                else if subitem.title                  div!= subitem.title.footer-running-time  span 本站已运行：&lt;span id=&quot;running-time&quot;&gt;0 天 0 小时 0 分钟 0 秒&lt;/span&gt;script.  function updateRunningTime() &#123;    const startDate = new Date(&quot;2025-07-20T00:00:00&quot;); // 修改为你自己的建站时间    const now = new Date();    let diff = Math.floor((now - startDate) / 1000); // 时间差（秒）    const days = Math.floor(diff / 86400);    diff -= days * 86400;    const hours = Math.floor(diff / 3600) % 24;    diff -= hours * 3600;    const minutes = Math.floor(diff / 60) % 60;    const seconds = diff % 60;    document.getElementById(&quot;running-time&quot;).innerText =      `$&#123;days&#125; 天 $&#123;hours&#125; 小时 $&#123;minutes&#125; 分钟 $&#123;seconds&#125; 秒`;  &#125;  // 页面加载后立即执行一次，之后每秒更新一次  document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;    updateRunningTime();    setInterval(updateRunningTime, 1000);  &#125;);.footer-other  .footer-copyright    if owner.enable      - const currentYear = new Date().getFullYear()      - const sinceYear = owner.since      span.copyright        if sinceYear &amp;&amp; sinceYear != currentYear          != `&amp;copy;$&#123;sinceYear&#125; - $&#123;currentYear&#125; By $&#123;config.author&#125;`        else          != `&amp;copy;$&#123;currentYear&#125; By $&#123;config.author&#125;`    if copyright.enable      - const v = copyright.version ? getVersion() : false      span.framework-info        if owner.enable &amp;&amp; nav          span.footer-separator |        span= _p(&#x27;footer.framework&#x27;) + &#x27; &#x27;        a(href=&#x27;https://hexo.io&#x27;)= `Hexo$&#123; v ? &#x27; &#x27; + v.hexo : &#x27;&#x27; &#125;`        span.footer-separator |        span= _p(&#x27;footer.theme&#x27;) + &#x27; &#x27;        a(href=&#x27;https://github.com/jerryc127/hexo-theme-butterfly&#x27;)= `Butterfly$&#123; v ? &#x27; &#x27; + v.theme : &#x27;&#x27; &#125;`  if theme.footer.custom_text    .footer_custom_text!= theme.footer.custom_text\n\n自定义CSS样式（更加美观）找到&#x2F;source文件夹，新建css文件夹，在css文件夹中新建custom.css文件，将下面代码全部复制到custom.css文件中\n\n.footer-running-time &#123;  font-size: 18px;  font-weight: bold;  text-align: center;  margin: 15px 0;  padding: 12px 18px;  border-radius: 10px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);  background: linear-gradient(90deg, #ffc0fa, #f375f3);  -webkit-background-clip: text;  -webkit-text-fill-color: transparent;  display: flex;  justify-content: center;  align-items: center;  gap: 12px;  flex-wrap: wrap;  transition: all 0.3s ease;  position: relative;&#125;.footer-running-time::before &#123;  content: &#x27;&#x27;;  position: absolute;  top: 0;  left: 0;  width: 100%;  height: 100%;  background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 1px, transparent 1px);  background-size: 4px 4px;  opacity: 0.3;  z-index: 0;  pointer-events: none;&#125;.footer-running-time i.fas.fa-hourglass &#123;  font-size: 20px;  margin-right: 6px;  color: #ffffff;  background: #ffc0cb;  border-radius: 50%;  padding: 8px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);  animation: bounce 1.2s infinite;  z-index: 1;&#125;@keyframes bounce &#123;  0%, 100% &#123;    transform: translateY(0) scale(1);  &#125;  50% &#123;    transform: translateY(-6px) scale(1.05);  &#125;&#125;\n\n让CSS样式生效找到_config.butterfly.yml文件inject中的head属性\ninject:  head:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;&gt; #增加这一行\n效果图\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo 常用命令使用和详解","url":"/2025/08/11/Hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%92%8C%E8%AF%A6%E8%A7%A3/","content":"Hexo 常用命令使用和详解Hexo 作为一款高性能的静态博客框架，其命令行工具设计简洁却功能强大。无论是新手搭建第一个博客，还是老手批量管理内容，掌握核心命令都是提升效率的关键。详细解析 Hexo 常用命令的用法与技巧。\n一、内容管理：文章与页面的创建与发布1. 创建文章（默认布局为 post）hexo new &quot;文章标题&quot;  # 等价于 hexo new post &quot;文章标题&quot;\n\n\n生成路径：source&#x2F;_posts&#x2F;文章标题.md\n\nMarkdown 头部信息（Front-matter）：自动生成包含标题、日期、标签等元数据的头部，例如：\n\n\n---title: 文章标题date: 2025-08-10 15:30:00tags:- Hexo---\n\n2. 创建独立页面（如关于页、分类页）hexo new page &quot;页面名称&quot;  # 如 hexo new page &quot;about&quot;\n\n\n生成路径：source&#x2F;页面名称&#x2F;index.md\n\n特点：页面 URL 为 域名&#x2F;页面名称（如 https://example.com/about），适合放置固定内容\n\n\n二、生成与预览：本地验证内容效果1. 生成静态文件hexo generate  # 简写：hexo g\n\n\n作用：将 Markdown 内容、主题模板编译为静态 HTML&#x2F;CSS&#x2F;JS，输出到 public 目录\n\n2. 本地预览博客hexo server  # 简写：hexo s\n\n\n默认访问地址：http://localhost:4000\n\n实用参数：\n\n\nhexo s -p 5000：指定端口（解决 4000 端口被占用问题）\n\n\n\nhexo s -i 0.0.0.0：允许局域网其他设备访问（如手机预览移动端效果）\n\n\n\n3. 清理缓存与生成文件hexo clean\n\n\n作用：删除 public 目录（生成的静态文件）和 db.json（缓存数据）\n\n何时使用：\n\n\n主题更换后（避免旧主题文件残留）\n\n\n\n内容更新后页面显示异常（如样式错乱、内容缺失）\n\n\n\n部署前（确保发布的是最新版本）\n\n\n\n4. 高效部署组合命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n\n清理→生成→本地预览\n默认访问地址：http://localhost:4000\nhexo clean &amp;&amp; hexo g -d  # 清理→生成→部署一站式操作\n\n先清理旧文件避免缓存干扰，再生成最新静态文件，最后直接部署，是日常发布的最佳实践\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo+Butterfly 优雅配置音乐播放器","url":"/2025/08/14/Hexo-Butterfly-%E4%BC%98%E9%9B%85%E9%85%8D%E7%BD%AE%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","content":"Hexo+Butterfly 优雅配置音乐播放器在博客中嵌入音乐播放器，能为访客营造更沉浸的阅读氛围。Hexo 搭配 Butterfly 主题时，借助 APlayer 和 Meting.js 可快速实现这一功能，无需复杂开发。本文将详细讲解配置流程、参数含义及实用技巧，帮你轻松打造专属音乐博客。\n一、核心工具与原理配置音乐播放器需依赖两个关键工具，二者分工明确：\n\nAPlayer：轻量级 HTML5 音乐播放器内核，负责渲染播放界面、控制播放逻辑（如暂停、切换歌曲）；\n\nMeting.js：音乐平台 API 封装工具，支持直接调用网易云、QQ 音乐等平台的播放列表，无需自建音乐文件库。\n\n\n工作流程：Meting.js 从音乐平台获取播放列表数据，APlayer 将数据渲染为可视化播放器，实现 “一键接入在线音乐” 的效果。\n二、前置准备\n环境要求：\n\n已安装 Hexo 博客框架及 Butterfly 主题（建议使用最新版本，兼容性更好）。\n若未安装主题，可参考 Butterfly 官方文档 完成部署。\n\n获取音乐资源 ID：\n\n以网易云音乐为例，打开目标播放列表，URL 中 id&#x3D; 后的数字即为播放列表 ID（如 https://music.163.com/playlist?id=13293433925 中，13293433925 就是需用到的 ID）。\n支持的平台：网易云（netease）、QQ 音乐（qq）、虾米（xiami）等。\n三、详细配置步骤1. 修改主题配置文件Butterfly 主题通过 _config.butterfly.yml 管理注入代码，无需修改主题源码，步骤如下：\n（1）打开配置文件在 Hexo 根目录中找到 _config.butterfly.yml（主题配置文件，非 Hexo 根目录的 _config.yml）。\n（2）配置注入资源搜索 inject 配置项，注入 APlayer 样式、Meting.js 脚本及播放器容器：\ninject:  head:  # 注入到&lt;head&gt;标签，加载样式    - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;    bottom:  # 注入到页面底部，加载脚本和播放器    - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&quot;&gt;&lt;/script&gt;    # 播放器容器配置    - &lt;div class=&quot;aplayer no-destroy&quot;          data-id=&quot;13293433925&quot;  # 替换为你的播放列表ID\t\t\t(修改你自己的id)         data-server=&quot;netease&quot;  # 音乐平台（netease/qq/xiami）   (修改,选择你自己的音乐平台)         data-type=&quot;playlist&quot;   # 资源类型（playlist/song/album）         data-fixed=&quot;true&quot;      # 是否固定在底部（true/false）         data-mini=&quot;true&quot;       # 固定时是否迷你显示（true/false）         data-listFolded=&quot;false&quot; # 是否折叠播放列表（true/false）         data-order=&quot;random&quot;    # 播放顺序（random/normal/single）         data-preload=&quot;auto&quot;    # 预加载模式（auto/none/metadata）         data-autoplay=&quot;false&quot;  # 是否自动播放（建议false，避免浏览器拦截）         data-theme=&quot;#409EFF&quot;&gt;  # 主题色（与Butterfly主题色匹配）      &lt;/div&gt;\n\n2. 配置播放器全局开关在 _config.butterfly.yml 中找到 aplayerInject 配置，控制播放器是否启用及显示范围：\naplayerInject:  enable: true  # 全局启用播放器（true/false）  per_page: true  # 所有页面均显示（true）或仅在指定页面显示（false）\n\n3. 生效配置执行以下命令清理缓存并启动本地服务，查看效果：\nhexo clean &amp;&amp; hexo s  # 清理缓存后启动服务，访问 http://localhost:4000 验证\n\n四、关键参数详解播放器的核心功能由 data-* 参数控制，理解这些参数可灵活定制播放器行为：\n\n\n\n参数名\n含义与可选值\n推荐配置\n\n\n\ndata-id\n音乐资源唯一标识（播放列表 &#x2F; 歌曲 ID）\n替换为自己的播放列表 ID\n\n\ndata-server\n音乐平台\nnetease（资源丰富，稳定性好）\n\n\ndata-type\n资源类型\nplaylist（播放列表，多首歌循环）\n\n\ndata-fixed\n是否固定在页面底部\ntrue（不遮挡内容，体验更佳）\n\n\ndata-mini\n固定模式下是否迷你显示\ntrue（节省空间）\n\n\ndata-order\n播放顺序\nrandom（随机播放，增加新鲜感）\n\n\ndata-autoplay\n是否自动播放\nfalse（浏览器默认拦截自动播放）\n\n\ndata-theme\n主题色（十六进制颜色码）\n与 Butterfly 主题主色一致（如 #409EFF）\n\n\n五、实用技巧与个性化切换音乐平台只需修改 data-server 和对应平台的 data-id：\n\nQQ 音乐：data-server&#x3D;”qq” data-id&#x3D;”QQ播放列表ID”\n\n虾米音乐：data-server&#x3D;”xiami” data-id&#x3D;”虾米播放列表ID”\n\n\n六、注意事项\nAPI 访问限制：\n\n音乐平台 API 可能存在防盗链机制，若播放器加载失败，可尝试：\n\n\n更换播放列表（避免版权受限的资源）；\n\n\n\n使用 HTTPS 协议（部分平台要求）。\n\n\n\n\n性能优化：\n\n\n\n播放列表不宜过大（建议 10-30 首歌），减少加载时间；\n\n\n\n关闭不必要的参数（如 data-preload&#x3D;”none” 关闭预加载）。\n\n\n\n\n兼容性问题：\n\n\n\n确保 APlayer 和 Meting.js 版本匹配（本文使用官方推荐的 CDN 版本，兼容性最佳）；\n\n\n\n低版本浏览器（如 IE）可能不支持，建议使用现代浏览器（Chrome、Edge 等）。\n\n\n\n总结：核心要点速览\n\n\n环节\n关键操作\n\n\n\n核心工具\nAPlayer（播放器界面）+ Meting.js（音乐 API 对接）\n\n\n配置入口\n主题配置文件 _config.butterfly.yml 的 inject 项\n\n\n必改参数\ndata-id（播放列表 ID）、data-server（音乐平台）\n\n\n显示控制\n全局 &#x2F; 单页显示通过 aplayerInject.per_page 和 Front-matter 控制\n\n\n避坑指南\n关闭自动播放、控制播放列表大小、注意 API 限制\n\n\n通过以上步骤，你的 Hexo 博客将拥有一个美观且功能完善的音乐播放器。如需进一步定制，可参考 APlayer 官方文档 和 Meting.js 文档 探索更多高级功能（如歌词显示、自定义控件）。\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo 说说功能 - 打造社交化动态页面","url":"/2026/01/07/Hexo%E8%AF%B4%E8%AF%B4%E5%8A%9F%E8%83%BD-%E6%89%93%E9%80%A0%E7%A4%BE%E4%BA%A4%E5%8C%96%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2/","content":"前言在博客中，除了长篇的技术文章，我们有时也想分享一些简短的想法、生活感悟或者日常动态。说说功能就像微博、朋友圈一样，可以让我们快速记录生活中的点滴，让博客更加生动有趣。\n本教程将教你如何在 Hexo + Butterfly 主题中实现一个完整的说说功能。\n功能特点✨ 核心功能：\n\n📝 支持发布简短动态\n📅 自动按时间降序排序\n🕐 智能时间显示（刚刚、几分钟前、具体日期）\n📍 支持显示发布来源（Web、手机等）\n🎨 精美的卡片式设计\n📱 完美的响应式布局\n🌙 深色模式适配\n✨ 流畅的动画效果\n\n实现步骤第一步：创建说说页面使用 Hexo 命令创建说说页面：\nhexo new page talking\n\n编辑 source/talking/index.md，设置页面类型：\n---title: 说说date: 2026-01-07 18:35:09type: talkingcomments: true---&lt;div id=&quot;talking-container&quot;&gt;  &lt;div class=&quot;talking-loading&quot;&gt;加载中...&lt;/div&gt;&lt;/div&gt;\n\n第二步：创建数据文件在 source/_data/ 目录下创建 talking.yml 文件（如果 _data 目录不存在，需要先创建）：\n- content: 今天天气真好，适合写代码！☀️  date: 2026-01-07 10:00:00  from: Web- content: 刚刚完成了 Hexo 博客的 PWA 功能配置，现在支持离线访问了！🎉  date: 2026-01-07 14:30:00  from: Web- content: 学习新技术的过程虽然辛苦，但看到成果的那一刻真的很有成就感 💪  date: 2026-01-06 20:15:00  from: Web\n\n数据格式说明：\n\ncontent: 说说内容（支持 emoji）\ndate: 发布时间（格式：YYYY-MM-DD HH:mm:ss）\nfrom: 发布来源（可选，如：Web、iPhone、Android）\n\n第三步：创建生成器脚本在 scripts/ 目录下创建 talking-generator.js：\nconst yaml = require(&#x27;js-yaml&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);hexo.extend.generator.register(&#x27;talking&#x27;,ction(locals) &#123;  const talkingPath = path.join(hexo.source_dir, &#x27;_data&#x27;, &#x27;talking.yml&#x27;);  if (!fs.existsSync(talkingPath)) &#123;    return [];  &#125;  try &#123;    consa = yaml.load(fs.readFileSync(talkingPath, &#x27;utf8&#x27;));    // 按日期降序排序    if (Array.isArray(talkingData)) &#123;      talkingData.sort((a, b) =&gt; new Date(b.date) - new Date(a.date));    &#125;    return [&#123;      path: &#x27;talking.json&#x27;,      data: JSON.stringify(talkingData || [])    &#125;];  &#125; catch (error) &#123;    console.error(&#x27;生成说说数据失败:&#x27;, error);    return [];  &#125;&#125;);\n\n脚本功能：\n\n读取 talking.yml 文件\n将 YAML 数据转换为 JSON 格式\n按日期降序排序\n生成 talking.json 供前端调用\n\n第四步：创建样式文件在 source/css/ 目录下创建 talking.css：\n/* 说说页面样式 */#talking-container &#123;  max-width: 800px;  margin: 0 auto;  padding: 20px;&#125;.talking-item &#123;  background: var(--card-bg);  border-radius: 12px;  padding: 20px;  margin-bottom: 20px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);  transition: all 0.3s ease;  animation: fadeInUp 0.6s ease-out;&#125;.talking-item:hover &#123;  transform: translateY(-5px);  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);&#125;.talking-content &#123;  font-size: 16px;  line-height: 1.8;  color: var(--font-color);  margin-bottom: 15px;  word-wrap: break-word;&#125;.talking-meta &#123;  display: flex;  justify-content: space-between;  align-items: center;  font-size: 14px;  color: var(--font-color);  opacity: 0.7;&#125;.talking-date &#123;  display: flex;  align-items: center;&#125;.talking-date i &#123;  margin-right: 5px;&#125;.talking-from &#123;  display: flex;  align-items: center;&#125;.talking-from i &#123;  margin-right: 5px;&#125;/* 加载动画 */@keyframes fadeInUp &#123;  from &#123;    opacity: 0;    transform: translateY(30px);  &#125;  to &#123;    opacity: 1;    transform: translateY(0);  &#125;&#125;/* 响应式设计 */@media screen and (max-width: 768px) &#123;  #talking-container &#123;    padding: 10px;  &#125;  .talking-item &#123;    padding: 15px;  &#125;  .talking-content &#123;    font-size: 14px;  &#125;  .talking-meta &#123;    flex-direction: column;    align-items: flex-start;    gap: 8px;  &#125;&#125;/* 暗黑模式适配 */[data-theme=&quot;dark&quot;] .talking-item &#123;  background: var(--card-bg);  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);&#125;[data-theme=&quot;dark&quot;] .talking-item:hover &#123;  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);&#125;\n\n样式特点：\n\n使用 CSS 变量适配主题\n卡片式设计，悬停效果\n渐入动画\n响应式布局\n深色模式支持\n\n第五步：创建 JavaScript 文件在 source/js/ 目录下创建 talking.js：\n// 说说页面功能document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123;  // 检查是否在说说页面  if (window.location.pathname.includes(&#x27;/talking/&#x27;)) &#123;    loadTalking();  &#125;&#125;);// 加载说说数据function loadTalking() &#123;  fetch(&#x27;/talking.json&#x27;)    .then(response =&gt; response.json())    .then(data =&gt; &#123;      renderTalking(data);    &#125;)    .catch(error =&gt; &#123;      console.error(&#x27;加载说说数据失败:&#x27;, error);      showError();    &#125;);&#125;// 渲染说说列表function renderTalking(talkingList) &#123;  const container = document.getElementById(&#x27;talking-container&#x27;);  if (!container) &#123;    console.error(&#x27;找不到说说容器&#x27;);    return;  &#125;  if (!talkingList || talkingList.length === 0) &#123;    container.innerHTML = &#x27;&lt;div class=&quot;talking-empty&quot;&gt;暂无说说&lt;/div&gt;&#x27;;    return;  &#125;  let html = &#x27;&#x27;;  talkingList.forEach((item, index) =&gt; &#123;    html += `      &lt;div class=&quot;talking-item&quot; style=&quot;animation-delay: $&#123;index * 0.1&#125;s&quot;&gt;        &lt;div class=&quot;talking-content&quot;&gt;$&#123;escapeHtml(item.content)&#125;&lt;/div&gt;        &lt;div class=&quot;talking-meta&quot;&gt;          &lt;div class=&quot;talking-date&quot;&gt;            &lt;i class=&quot;far fa-clock&quot;&gt;&lt;/i&gt;            &lt;span&gt;$&#123;formatDate(item.date)&#125;&lt;/span&gt;          &lt;/div&gt;          &lt;div class=&quot;talking-from&quot;&gt;            &lt;i class=&quot;fas fa-map-marker-alt&quot;&gt;&lt;/i&gt;            &lt;span&gt;$&#123;escapeHtml(item.from || &#x27;Web&#x27;)&#125;&lt;/span&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    `;  &#125;);  container.innerHT html;&#125;// 格式化日期function formatDate(dateString) &#123;  const date = new Date(dateString);  const now = new Date();  const diff = now - date;  // 小于1分钟  if (diff &lt; 60000) &#123;    return &#x27;刚刚&#x27;;  &#125;  // 小于1小时  if (diff &lt; 3600000) &#123;    return Math.floor(diff / 60000) + &#x27; 分钟前&#x27;;  &#125;  // 小于1天  if (diff &lt; 86400000) &#123;    return Math.floor(diff / 3600000) + &#x27; 小时前&#x27;;  &#125;  // 小于7天  if (diff &lt; 604800000) &#123;    return Math.floor(diff / 86400000) + &#x27; 天前&#x27;;  &#125;  // 超过7天，显示具体日期  const year = date.getFullYear();  const month = String(date.getMonth() + 1).padStart(2, &#x27;0&#x27;);  const day = String(date.getDate()).padStart(2, &#x27;0&#x27;);  const hours = String(date.getHours()).padStart(2, &#x27;0&#x27;);  const minutes = String(date.getMinutes()).padStart(2, &#x27;0&#x27;);  return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hours&#125;:$&#123;minutes&#125;`;&#125;// HTML 转义function escapeHtml(text) &#123;  const div = document.createElement(&#x27;div&#x27;);  div.textContent = text;  return div.innerHTML;&#125;// 显示错误信息function showError() &#123;  const container = document.getElementById(&#x27;talking-container&#x27;);  if (container) &#123;    container.innerHTML = `      &lt;div class=&quot;talking-error&quot;&gt;        &lt;i class=&quot;fas fa-exclamation-triangle&quot;&gt;&lt;/i&gt;        &lt;p&gt;加载说说失败，请稍后再试&lt;/p&gt;      &lt;/div&gt;    `;  &#125;&#125;\n\n功能说明：\n\n自动检测说说页面并加载数据\n智能时间格式化（相对时间和绝对时间）\nHTML 转义防止 XSS 攻击\n错误处理和友好提示\n渐进式动画效果\n\n第六步：注入 CSS 和 JS编辑 _config.butterfly.yml，在 inject 部分添加：\ninject:  head:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/talking.css&quot;&gt; # 说说页面  bottom:    - &lt;script src=&quot;/js/talking.js&quot;&gt;&lt;/script&gt;\n\n第七步：添加导航菜单在 _config.butterfly.yml 的 menu 部分添加说说入口：\nmenu:  首页: / || fas fa-home  时间轴: /archives/ || fas fa-archive  标签: /tags/ || fas fa-tags  分类: /categories/ || fas fa-folder-open  说说: /talking/ || fas fa-comments  # 新增\n\n第八步：生成并测试# 清理缓存hexo clean# 生成网站hexo generate# 启动本地服务器hexo server\n\n访问 http://localhost:4000/talking/ 查看效果。\n使用说明发布新说说编辑 source/_data/talking.yml，在文件开头添加新的说说：\n- content: 这是一条新的说说 🎉  date: 2026-01-08 10:00:00  from: Web\n\n然后重新生成网站：\nhexo clean &amp;&amp; hexo generate\n\n时间格式说明时间显示规则：\n\n刚刚：1分钟内\nX 分钟前：1小时内\nX 小时前：24小时内\nX 天前：7天内\n具体日期：超过7天显示 YYYY-MM-DD HH:mm\n\n自定义样式你可以修改 talking.css 来自定义样式：\n/* 修改卡片背景色 */.talking-item &#123;  background: #f8f9fa;&#125;/* 修改文字颜色 */.talking-content &#123;  color: #333;&#125;/* 修改悬停效果 */.talking-item:hover &#123;  transform: translateY(-8px);  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);&#125;\n\n进阶功能1. 添加图片支持修改数据格式：\n- content: 今天拍到的美丽日落 🌅  date: 2026-01-08 18:30:00  from: iPhone  images:    - /images/sunset1.jpg    - /images/sunset2.jpg\n\n修改 talking.js 的渲染函数：\n// 在 renderTalking 函数中添加图片渲染if (item.images &amp;&amp; item.images.length &gt; 0) &#123;  html += &#x27;&lt;div class=&quot;talking-images&quot;&gt;&#x27;;  item.images.forEach(img =&gt; &#123;    html += `&lt;img src=&quot;$&#123;img&#125;&quot; alt=&quot;说说图片&quot; class=&quot;talking-image&quot;&gt;`;  &#125;);  html += &#x27;&lt;/div&gt;&#x27;;&#125;\n\n2. 添加点赞功能可以集成 LeanCloud 或其他后端服务实现点赞功能。\n3. 添加评论功能说说页面已经支持评论，你可以在每条说说下添加评论区。\n4. 添加标签分类- content: 学习 Vue 3 的新特性  date: 2026-01-08 10:00:00  from: Web  tags:    - 前端    - Vue\n\n常见问题Q1: 说说不显示怎么办？检查步骤：\n\n确认 talking.yml 文件存在且格式正确\n检查浏览器控制台是否有错误\n确认 talking.json 是否生成（在 public/ 目录下）\n检查 CSS 和 JS 是否正确注入\n\nQ2: 时间显示不正确？确保 talking.yml 中的日期格式正确：YYYY-MM-DD HH:mm:ss\nQ3: 样式显示异常？\n清理缓存：hexo clean\n检查 CSS 文件路径是否正确\n确认主题变量是否定义\n\nQ4: 如何批量导入说说？可以编写脚本从其他平台（如微博、Twitter）导出数据，然后转换为 YAML 格式。\n性能优化1. 分页加载当说说数量较多时，可以实现分页：\nconst pageSize = 10;let currentPage = 1;function renderPage(data, page) &#123;  const start = (page - 1) * pageSize;  const end = start + pageSize;  const pageData = data.slice(start, end);  renderTalking(pageData);&#125;\n\n2. 懒加载图片如果说说包含图片，使用懒加载提升性能：\n&lt;img src=&quot;placeholder.jpg&quot; data-src=&quot;$&#123;img&#125;&quot; class=&quot;lazyload&quot;&gt;\n\n3. 缓存优化利用浏览器缓存减少请求：\nconst cachedData = localStorage.getItem(&#x27;talking-cache&#x27;);if (cachedData) &#123;  renderTalking(JSON.parse(cachedData));&#125;\n\n总结通过本教程，我们实现了一个完整的说说功能，包括：\n✅ 数据管理：使用 YAML 文件管理说说数据✅ 自动生成：通过 Hexo 生成器自动转换为 JSON✅ 页面渲染：动态加载和渲染说说列表✅ 样式设计：精美的卡片式设计和动画效果✅ 响应式布局：完美适配各种设备✅ 深色模式：自动适配主题模式\n说说功能让博客更加生动有趣，可以记录生活中的点滴，与访客分享日常。你可以根据自己的需求进一步扩展功能，如添加图片、标签、点赞等。\n相关文章\nHexo 性能优化 - 代码压缩配置教程\nHexo SEO 优化 - 站点地图配置教程\nHexo 数据统计 - 百度统计与 Google Analytics 配置教程\nHexo 系列文章功能 - 组织相关内容的最佳实践\nHexo PWA 支持 - 离线访问与应用化配置教程\n\n\n💡 提示：如果你觉得这篇教程对你有帮助，欢迎点赞、收藏和分享！有任何问题欢迎在评论区留言。\n","categories":["Hexo博客"],"tags":["Hexo","Butterfly","教程"]},{"title":"Hexo 友链页面 - 增加博客社交属性","url":"/2026/01/07/Hexo%E5%8F%8B%E9%93%BE%E9%A1%B5%E9%9D%A2-%E5%A2%9E%E5%8A%A0%E5%8D%9A%E5%AE%A2%E7%A4%BE%E4%BA%A4%E5%B1%9E%E6%80%A7/","content":"Hexo 友链页面 - 增加博客社交属性想让你的博客更有社交属性？想和其他博主互相交流？友链页面是必不可少的！本教程教你如何在 Hexo + Butterfly 主题中实现一个完整的友链功能。\n📋 目录\n什么是友链\n为什么需要友链\n实现步骤\n功能特点\n使用说明\n总结\n\n什么是友链1. 定义友情链接（Friend Links）是博客之间互相推荐的链接，通常展示在专门的友链页面上。\n2. 展示形式友链通常以卡片形式展示，包含：\n\n🖼️ 网站头像：网站的 Logo 或代表图片\n📝 网站名称：网站的标题\n🔗 网站链接：网站的 URL\n💬 网站描述：一句话介绍\n\n3. 作用\n互相推广：增加网站曝光度\n建立联系：与其他博主交流\n提升 SEO：增加外链权重\n丰富内容：让博客更有人情味\n\n为什么需要友链1. 社交属性问题：博客是孤立的，缺乏与其他博主的联系\n解决：通过友链建立博客圈子，互相交流学习\n2. 流量互换问题：新博客流量少，难以被发现\n解决：通过友链互相推荐，增加访问量\n3. SEO 优化问题：搜索引擎收录慢，排名低\n解决：友链提供外链，提升网站权重\n4. 内容发现问题：不知道有哪些优质博客\n解决：通过友链发现同类型的优质内容\n实现步骤第一步：创建友链页面使用 Hexo 命令创建友链页面：\nhexo new page link\n\n编辑 source/link/index.md，设置页面类型：\n---title: 友情链接date: 2026-01-07 22:18:43type: linkcomments: true---&lt;div id=&quot;link-container&quot;&gt;  &lt;div class=&quot;link-loading&quot;&gt;加载中...&lt;/div&gt;&lt;/div&gt;\n\n第二步：创建友链数据文件在 source/_data/ 目录下创建 links.yml：\n- name: Hexo  link: https://hexo.io/zh-cn/  avatar: https://hexo.io/icon/favicon-196x196.png  descr: 快速、简洁且高效的博客框架- name: Butterfly  link: https://butterfly.js.org/  avatar: https://butterfly.js.org/img/avatar.png  descr: 一个基于 Hexo 的 Material Design 风格主题- name: GitHub  link: https://github.com/  avatar: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png  descr: 全球最大的代码托管平台\n\n字段说明：\n\nname：网站名称\nlink：网站链接\navatar：头像链接\ndescr：网站描述\n\n第三步：创建数据生成器在 scripts/ 目录下创建 link-generator.js：\nconst yaml = require(&#x27;js-yaml&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);hexo.extend.generator.register(&#x27;link&#x27;, function(locals) &#123;  const linkPath = path.join(hexo.source_dir, &#x27;_data&#x27;, &#x27;links.yml&#x27;);  if (!fs.existsSync(linkPath)) &#123;    return [];  &#125;  try &#123;    const linkData = yaml.load(fs.readFileSync(linkPath, &#x27;utf8&#x27;));    return [&#123;      path: &#x27;links.json&#x27;,      data: JSON.stringify(linkData || [])    &#125;];  &#125; catch (error) &#123;    console.error(&#x27;生成友链数据失败:&#x27;, error);    return [];  &#125;&#125;);\n\n作用：将 YAML 格式的友链数据转换为 JSON，供前端加载。\n第四步：创建样式文件在 source/css/ 目录下创建 link.css：\n/* 友链容器 */#link-container &#123;  margin: 20px 0;&#125;/* 友链说明 */.link-notice &#123;  background: var(--card-bg);  border-radius: 12px;  padding: 20px;  margin-bottom: 20px;  border-left: 4px solid #49b1f5;&#125;.link-notice h3 &#123;  margin-top: 0;  color: #49b1f5;&#125;.link-notice code &#123;  background: rgba(73, 177, 245, 0.1);  padding: 2px 6px;  border-radius: 4px;  color: #49b1f5;  font-weight: bold;&#125;/* 友链网格布局 */.link-grid &#123;  display: grid;  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));  gap: 20px;  margin-top: 20px;&#125;/* 友链卡片 */.link-card &#123;  display: flex;  align-items: center;  background: var(--card-bg);  border-radius: 12px;  padding: 20px;  text-decoration: none;  color: var(--font-color);  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);  transition: all 0.3s ease;  position: relative;  overflow: hidden;  animation: fadeInUp 0.6s ease-out;  opacity: 0;  animation-fill-mode: forwards;&#125;/* 顶部渐变边框 */.link-card::before &#123;  content: &#x27;&#x27;;  position: absolute;  top: 0;  left: 0;  right: 0;  height: 3px;  background: linear-gradient(90deg, #49b1f5, #ff7242);  transform: scaleX(0);  transition: transform 0.3s ease;&#125;.link-card:hover::before &#123;  transform: scaleX(1);&#125;/* 卡片悬停效果 */.link-card:hover &#123;  transform: translateY(-5px);  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);&#125;/* 头像 */.link-avatar &#123;  width: 60px;  height: 60px;  border-radius: 50%;  object-fit: cover;  margin-right: 15px;  border: 3px solid transparent;  transition: all 0.3s ease;&#125;.link-card:hover .link-avatar &#123;  transform: rotate(360deg);  border-color: #49b1f5;&#125;/* 信息区域 */.link-info &#123;  flex: 1;  min-width: 0;&#125;/* 网站名称 */.link-name &#123;  font-size: 18px;  font-weight: bold;  margin-bottom: 5px;  color: var(--font-color);  white-space: nowrap;  overflow: hidden;  text-overflow: ellipsis;&#125;/* 网站描述 */.link-descr &#123;  font-size: 14px;  color: var(--font-color);  opacity: 0.7;  display: -webkit-box;  -webkit-line-clamp: 2;  -webkit-box-orient: vertical;  overflow: hidden;&#125;/* 加载中 */.link-loading &#123;  text-align: center;  padding: 40px;  color: var(--font-color);  opacity: 0.7;&#125;/* 空状态 */.link-empty &#123;  text-align: center;  padding: 40px;  color: var(--font-color);  opacity: 0.5;&#125;/* 错误状态 */.link-error &#123;  text-align: center;  padding: 40px;  color: #ff7242;&#125;.link-error i &#123;  font-size: 48px;  margin-bottom: 10px;&#125;/* 淡入动画 */@keyframes fadeInUp &#123;  from &#123;    opacity: 0;    transform: translateY(20px);  &#125;  to &#123;    opacity: 1;    transform: translateY(0);  &#125;&#125;/* 响应式设计 */@media (max-width: 768px) &#123;  .link-grid &#123;    grid-template-columns: 1fr;    gap: 15px;  &#125;  .link-card &#123;    padding: 15px;  &#125;  .link-avatar &#123;    width: 50px;    height: 50px;  &#125;  .link-name &#123;    font-size: 16px;  &#125;  .link-descr &#123;    font-size: 13px;  &#125;&#125;/* 深色模式适配 */[data-theme=&quot;dark&quot;] .link-card &#123;  background: #1f1f1f;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);&#125;[data-theme=&quot;dark&quot;] .link-card:hover &#123;  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);&#125;[data-theme=&quot;dark&quot;] .link-notice &#123;  background: #1f1f1f;&#125;\n\n特点：\n\n✅ Grid 网格布局，自适应列数\n✅ 卡片悬停效果（上移、阴影、头像旋转）\n✅ 渐变顶部边框动画\n✅ 淡入动画，错开延迟\n✅ 响应式设计，移动端友好\n✅ 深色模式适配\n\n第五步：创建 JavaScript 文件在 source/js/ 目录下创建 link.js：\n// 友链页面功能function initLink() &#123;  const container = document.getElementById(&#x27;link-container&#x27;);  if (container) &#123;    loadLinks();  &#125;&#125;// 初始化if (document.readyState === &#x27;loading&#x27;) &#123;  document.addEventListener(&#x27;DOMContentLoaded&#x27;, initLink);&#125; else &#123;  initLink();&#125;// PJAX 兼容document.addEventListener(&#x27;pjax:complete&#x27;, initLink);// 加载友链数据function loadLinks() &#123;  fetch(&#x27;/links.json&#x27;)    .then(response =&gt; response.json())    .then(data =&gt; &#123;      renderLinks(data);    &#125;)    .catch(error =&gt; &#123;      console.error(&#x27;加载友链数据失败:&#x27;, error);      showLinkError();    &#125;);&#125;// 渲染友链列表function renderLinks(linkList) &#123;  const container = document.getElementById(&#x27;link-container&#x27;);  if (!container) &#123;    console.error(&#x27;找不到友链容器&#x27;);    return;  &#125;  if (!linkList || linkList.length === 0) &#123;    container.innerHTML = &#x27;&lt;div class=&quot;link-empty&quot;&gt;暂无友链&lt;/div&gt;&#x27;;    return;  &#125;  // 添加友链说明  let html = `    &lt;div class=&quot;link-notice&quot;&gt;      &lt;h3&gt;🔗 友链说明&lt;/h3&gt;      &lt;p&gt;欢迎交换友链！请在评论区留言，格式如下：&lt;/p&gt;      &lt;p&gt;        &lt;code&gt;名称&lt;/code&gt;：你的网站名称&lt;br&gt;        &lt;code&gt;链接&lt;/code&gt;：你的网站地址&lt;br&gt;        &lt;code&gt;头像&lt;/code&gt;：你的头像链接&lt;br&gt;        &lt;code&gt;描述&lt;/code&gt;：一句话介绍      &lt;/p&gt;      &lt;p&gt;💡 本站信息：&lt;/p&gt;      &lt;p&gt;        &lt;code&gt;名称&lt;/code&gt;：cyforkk&lt;br&gt;        &lt;code&gt;链接&lt;/code&gt;：https://cyforkk.top/&lt;br&gt;        &lt;code&gt;头像&lt;/code&gt;：https://cyforkk.top/images/wallpaper-img/sanye.png&lt;br&gt;        &lt;code&gt;描述&lt;/code&gt;：找寻自我      &lt;/p&gt;    &lt;/div&gt;    &lt;div class=&quot;link-grid&quot;&gt;  `;  // 渲染友链卡片  linkList.forEach((item, index) =&gt; &#123;    const name = escapeHtml(item.name);    const link = escapeHtml(item.link);    const avatar = escapeHtml(item.avatar);    const descr = escapeHtml(item.descr);    html += `      &lt;a href=&quot;$&#123;link&#125;&quot; class=&quot;link-card&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; style=&quot;animation-delay: $&#123;index * 0.1&#125;s&quot;&gt;        &lt;img src=&quot;$&#123;avatar&#125;&quot; alt=&quot;$&#123;name&#125;&quot; class=&quot;link-avatar&quot; onerror=&quot;this.src=&#x27;/img/friend_404.gif&#x27;&quot;&gt;        &lt;div class=&quot;link-info&quot;&gt;          &lt;div class=&quot;link-name&quot;&gt;$&#123;name&#125;&lt;/div&gt;          &lt;div class=&quot;link-descr&quot;&gt;$&#123;descr&#125;&lt;/div&gt;        &lt;/div&gt;      &lt;/a&gt;    `;  &#125;);  html += &#x27;&lt;/div&gt;&#x27;;  container.innerHTML = html;&#125;// HTML 转义function escapeHtml(text) &#123;  const div = document.createElement(&#x27;div&#x27;);  div.textContent = text;  return div.innerHTML;&#125;// 显示错误信息function showLinkError() &#123;  const container = document.getElementById(&#x27;link-container&#x27;);  if (container) &#123;    container.innerHTML = `      &lt;div class=&quot;link-error&quot;&gt;        &lt;i class=&quot;fas fa-exclamation-triangle&quot;&gt;&lt;/i&gt;        &lt;p&gt;加载友链失败，请稍后再试&lt;/p&gt;      &lt;/div&gt;    `;  &#125;&#125;\n\n功能：\n\n✅ 从 /links.json 加载数据\n✅ 动态渲染友链卡片\n✅ HTML 转义防止 XSS 攻击\n✅ 错误处理和友好提示\n✅ PJAX 兼容性\n✅ 图片加载失败处理\n\n第六步：注入 CSS 和 JS编辑 _config.butterfly.yml，在 inject 部分添加：\ninject:  head:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/link.css&quot;&gt; # 友链页面  bottom:    - &lt;script src=&quot;/js/link.js&quot;&gt;&lt;/script&gt;\n\n第七步：添加导航菜单在 _config.butterfly.yml 的 menu 部分添加：\nmenu:  友链: /link/ || fas fa-link\n\n第八步：生成并部署# 清理缓存hexo clean# 生成静态文件hexo generate# 启动本地服务器测试hexo server# 部署到 GitHub Pageshexo deploy\n\n功能特点✨ 核心功能\n数据管理\n\nYAML 格式，易于编辑\n自动转换为 JSON\n支持批量添加\n\n\n美观界面\n\n卡片式设计\nGrid 网格布局\n流畅动画效果\n\n\n交互体验\n\n悬停效果（上移、阴影、旋转）\n渐变边框动画\n错开淡入动画\n\n\n响应式设计\n\n自适应列数\n移动端优化\n触摸友好\n\n\n深色模式\n\n自动适配主题\n颜色变量控制\n平滑过渡\n\n\n安全性\n\nHTML 转义\nXSS 防护\n图片加载失败处理\n\n\n兼容性\n\nPJAX 支持\n事件监听\n错误处理\n\n\n\n使用说明添加友链编辑 source/_data/links.yml，添加新的友链：\n- name: 你的网站名称  link: https://your-website.com/  avatar: https://your-website.com/avatar.png  descr: 你的网站描述\n\n修改友链直接编辑 links.yml 文件，修改对应字段即可。\n删除友链从 links.yml 文件中删除对应的友链条目。\n自定义样式编辑 source/css/link.css，修改样式变量：\n/* 修改主题色 */.link-notice &#123;  border-left: 4px solid #your-color;&#125;/* 修改卡片间距 */.link-grid &#123;  gap: 30px; /* 默认 20px */&#125;/* 修改卡片圆角 */.link-card &#123;  border-radius: 16px; /* 默认 12px */&#125;\n\n自定义说明编辑 source/js/link.js，修改友链说明部分：\n// 修改本站信息&lt;p&gt;  &lt;code&gt;名称&lt;/code&gt;：你的网站名称&lt;br&gt;  &lt;code&gt;链接&lt;/code&gt;：你的网站地址&lt;br&gt;  &lt;code&gt;头像&lt;/code&gt;：你的头像链接&lt;br&gt;  &lt;code&gt;描述&lt;/code&gt;：你的网站描述&lt;/p&gt;\n\n总结通过本教程，我们实现了一个完整的友链功能，包括：\n✅ 已实现功能\n数据管理：YAML 格式，易于维护\n自动生成：YAML 转 JSON，无需手动处理\n美观界面：卡片式设计，Grid 布局\n动画效果：悬停、淡入、旋转等\n响应式：自适应不同屏幕尺寸\n深色模式：自动适配主题\n安全性：HTML 转义，XSS 防护\n兼容性：PJAX 支持，错误处理\n\n📊 效果展示访问 http://localhost:4000/link/ 查看效果：\n\n🎨 精美的卡片式布局\n✨ 流畅的动画效果\n📱 完美的移动端适配\n🌙 深色模式支持\n🔒 安全的数据处理\n\n🎯 下一步\n添加更多友链：与其他博主交换友链\n优化样式：根据个人喜好调整设计\n增加功能：如友链分类、搜索等\n定期维护：检查友链有效性\n\n💡 提示\n定期检查友链是否有效\n与友链博主保持联系\n优先添加活跃的博客\n注意友链的质量而非数量\n\n\n相关文章：\n\nHexo 性能优化 - 代码压缩配置教程\nHexo SEO 优化 - 站点地图配置教程\nHexo 说说功能 - 打造社交化动态页面\n\n参考资源：\n\nHexo 官方文档\nButterfly 主题文档\nYAML 语法指南\n\n","categories":["Hexo博客"],"tags":["Hexo","Butterfly","教程"]},{"title":"MySQL 5.7 字符集设置指南：从乱码根源到彻底解决","url":"/2025/08/14/MySQL-5-7-%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8E%E4%B9%B1%E7%A0%81%E6%A0%B9%E6%BA%90%E5%88%B0%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3/","content":"MySQL 5.7 字符集设置指南：从乱码根源到彻底解决在 MySQL 使用中，“乱码” 是最让人头疼的问题之一 —— 明明输入的是中文，存储后却变成一堆问号或火星文。其实，这大多是字符集设置不当导致的。本文基于 MySQL 5.7 的字符集配置逻辑，教你从根源解决乱码问题，让数据存储和显示始终 “表里如一”。\n一、先搞懂：字符集到底是什么？简单说，字符集是数据库 “认识” 文字的字典。不同的字符集支持不同的文字范围：\n\nlatin1：只支持英文和少数符号，不支持中文；\n\nutf8：支持中文，但 MySQL 5.7 中的utf8是 “阉割版”，最多支持 3 个字节，无法存储 emoji（如😊）或某些生僻字；\n\nutf8mb4：“完整版” utf8，支持 4 个字节，能完美存储中文、emoji 和各种生僻字，是推荐选择。\n\n\n如果数据库的字符集不支持你要存储的文字，就会出现乱码。比如用latin1存储中文，结果必然是问号 “???”。\n二、MySQL 5.7 的字符集 “三层结构”MySQL 5.7 的字符集设置分为三个层级，层层递进，缺一不可：\n\n服务器级：数据库启动时的默认字符集，影响所有新建的数据库；\n\n数据库级：每个数据库可以单独指定字符集，覆盖服务器级设置；\n\n表 &#x2F; 字段级：创建表或字段时可指定字符集，覆盖数据库级设置。\n\n\n举个例子：如果服务器级用latin1，但某数据库单独设置了utf8mb4，那么该数据库的表默认会用utf8mb4。\n三、一步到位：全局字符集配置（推荐）最省心的方式是在配置文件中统一设置字符集，避免层级冲突。\n步骤 1：找到配置文件\nWindows：通常在 MySQL 安装目录的my.ini（如C:\\Program Files\\MySQL\\mysql-5.7\\my.ini）；\n\nLinux：一般在&#x2F;etc&#x2F;my.cnf或&#x2F;etc&#x2F;mysql&#x2F;my.cnf。\n\n\n步骤 2：修改配置参数用文本编辑器打开配置文件，在对应节点添加以下内容：\n# [mysqld] 节点：服务器级字符集[mysqld]character-set-server=utf8mb4  # 服务器默认字符集collation-server=utf8mb4_unicode_ci  # 对应的排序规则（不区分大小写）# [client] 节点：客户端连接时的字符集（避免连接环节乱码）[client]default-character-set=utf8mb4# [mysql] 节点：mysql命令行工具的字符集[mysql]default-character-set=utf8mb4\n\n关键说明：\n\ncollation-server是字符集的 “排序规则”，utf8mb4_unicode_ci支持多语言正确排序，推荐使用；\n\n必须同时配置client和mysql节点，否则客户端连接时可能用默认的latin1，导致 “写入乱码”。\n\n\n步骤 3：重启服务生效# Windows（管理员CMD）net stop mysql57  # 停止服务（mysql57是服务名，需替换）net start mysql57  # 启动服务# Linuxsudo systemctl restart mysqld  # 或 mysql\n\n四、临时调整：数据库 &#x2F; 表级字符集设置如果不想修改全局配置，也可以在创建数据库或表时单独指定字符集。\n1. 创建数据库时指定CREATE DATABASE mydb   CHARACTER SET utf8mb4   COLLATE utf8mb4_unicode_ci;\n\n2. 创建表时指定USE mydb;  # 切换到目标数据库CREATE TABLE user (  id INT,  name VARCHAR(50)) ENGINE=InnoDB   DEFAULT CHARSET=utf8mb4   COLLATE=utf8mb4_unicode_ci;\n\n注意：如果数据库级已设置utf8mb4，表级可以省略，但明确指定更稳妥。\n五、验证字符集设置是否生效配置后，用以下命令检查是否生效：\n\n查看服务器级字符集：\n\nshow variables like &#x27;character_set_server&#x27;;  # 应显示utf8mb4show variables like &#x27;collation_server&#x27;;      # 应显示utf8mb4_unicode_ci\n\n\n查看当前数据库字符集：\n\nuse mydb;show variables like &#x27;character_set_database&#x27;;  # 应显示utf8mb4\n\n\n查看表字符集：\n\nshow create table user;  # 查看表定义，确认CHARSET=utf8mb4\n\n六、常见问题：设置后仍乱码怎么办？\n连接环节的 “隐形坑”\n\n即使服务器和数据库字符集正确，客户端连接时如果用了其他字符集，仍会乱码。解决方法：连接时显式指定字符集：\n# 命令行连接时mysql -u root -p --default-character-set=utf8mb4# 程序中连接（以Python为例）import pymysqlconn = pymysql.connect(  host=&#x27;localhost&#x27;,  user=&#x27;root&#x27;,  password=&#x27;123456&#x27;,  db=&#x27;mydb&#x27;,  charset=&#x27;utf8mb4&#x27;  # 必须指定)\n\n\n已有数据乱码\n\n字符集修改后，新数据会正常存储，但旧的乱码数据需要重新插入。可以先导出数据，修改字符集后再导入。\n七、最佳实践总结\n优先用 utf8mb4：无论是新库还是旧库，都建议统一为utf8mb4，避免未来兼容问题；\n\n全局配置一步到位：修改my.ini&#x2F;my.cnf是最彻底的方式，减少后续维护成本；\n\n连接时显式指定字符集：程序或命令行连接必须带charset&#x3D;utf8mb4，堵住最后一个漏洞；\n\n新建库表时检查字符集：养成创建时显式指定utf8mb4的习惯，避免依赖默认配置。\n\n\n按照这些步骤操作，MySQL 5.7 的字符集问题就能迎刃而解，从此和乱码说再见。\n以上内容涵盖了 MySQL 5.7 字符集设置的关键要点。若你对某些内容有疑问，或想进一步细化某个步骤，欢迎随时告诉我。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"JDK7 与 JDK8 中 HashMap 的演进：从问题到优化的全面解析","url":"/2025/08/11/JDK7-%E4%B8%8E-JDK8-%E4%B8%AD-HashMap-%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8E%E9%97%AE%E9%A2%98%E5%88%B0%E4%BC%98%E5%8C%96%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/","content":"JDK7 与 JDK8 中 HashMap 的演进：从问题到优化的全面解析HashMap 作为 Java 集合框架中使用最广泛的工具类，在 JDK7 到 JDK8 的版本迭代中经历了根本性的设计升级。从单纯的 “数组 + 链表” 到引入红黑树优化，从线程不安全的头插法到更稳健的尾插法，这些变化不仅解决了旧版本的性能瓶颈，更体现了 Java 对实际开发需求的持续响应。本文将对比解析两个版本的核心设计，带你理解 HashMap 的演进逻辑。\n一、JDK7 HashMap：简单设计下的性能与安全隐患JDK7 的 HashMap 采用 “数组 + 单向链表” 的基础结构，实现简单但在高频场景下暴露了明显缺陷。\n1. 底层结构：数组 + 单向链表\n数组（Entry [] table）：作为存储节点的 “桶”，长度始终为 2 的幂（初始 16），通过(n-1) &amp; hash计算索引（等价于取模，效率更高）。\n\n链表（Entry 节点）：每个节点包含hash、key、value和next指针，用于解决哈希冲突 —— 当多个 key 计算出相同索引时，用链表串联节点。\n\n\n2. 核心问题点\n头插法导致的线程安全风险：新节点插入链表头部（newEntry.next &#x3D; table[i]; table[i] &#x3D; newEntry），多线程扩容时可能形成环形链表，导致get操作陷入无限循环。\n\n链表过长的性能瓶颈：无红黑树优化，当哈希冲突严重时，链表长度可能急剧增长，查询时间复杂度退化为 O (n)。\n\n扩容效率低：节点迁移时需重新计算哈希索引，且头插法会导致链表顺序反转。\n\n\n3. 关键方法：put 流程的隐患// JDK7 put核心逻辑简化public V put(K key, V value) &#123;    if (table == EMPTY_TABLE) &#123;        inflateTable(threshold); // 初始化数组    &#125;    if (key == null) return putForNullKey(value);    int hash = hash(key);    int i = indexFor(hash, table.length);    // 遍历链表检查重复key    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;        if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;            V oldValue = e.value;            e.value = value;            return oldValue;        &#125;    &#125;    modCount++;    addEntry(hash, key, value, i); // 头插法插入新节点    return null;&#125;\n\n二、JDK8 HashMap：红黑树带来的性能革命JDK8 针对 JDK7 的缺陷进行了全方位优化，引入红黑树和尾插法，彻底改写了 HashMap 的性能表现。\n1. 底层结构：数组 + 链表 + 红黑树的复合设计\n数组（Node [] table）：保留 2 的幂长度特性，但初始化时机推迟到首次put（延迟初始化，节省内存）。\n\n链表（Node 节点）：仅在哈希冲突较少时使用，新节点采用尾插法插入，避免链表反转。\n\n红黑树（TreeNode 节点）：当链表长度超过 8 且数组长度≥64时，链表转为红黑树（查询复杂度降至 O (logn)）；当节点数≤6 时，自动还原为链表（减少树结构维护成本）。\n\n\n2. 核心改进点\n哈希算法优化：通过高位异或（h ^ (h &gt;&gt;&gt; 16)）让高位信息参与索引计算，减少冲突概率：\n\nstatic final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;\n\n\n尾插法插入节点：新节点添加到链表尾部，避免多线程扩容时的环形链表问题（但仍非线程安全）。\n\n高效扩容机制：节点迁移时无需重新计算哈希，通过(hash &amp; oldCap)判断是否迁移至 “原索引 + 旧容量” 位置，大幅提升扩容效率。\n\n\n3. 关键方法：put 流程的优化// JDK8 put核心逻辑简化final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length; // 延迟初始化    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null); // 桶为空直接插入    else &#123;        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp; ((k = p.key) == key || key.equals(k)))            e = p; // 命中重复key        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 红黑树插入        else &#123;            // 链表插入，尾插法            for (int binCount = 0; ; ++binCount) &#123;                if ((e = p.next) == null) &#123;                    p.next = newNode(hash, key, value, null);                    // 满足条件时转为红黑树                    if (binCount &gt;= TREEIFY_THRESHOLD - 1)                        treeifyBin(tab, hash);                    break;                &#125;                if (e.hash == hash &amp;&amp; key.equals(e.key)) break;                p = e;            &#125;        &#125;        if (e != null) &#123; // 覆盖重复key的value            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            return oldValue;        &#125;    &#125;    ++modCount;    if (++size &gt; threshold) resize(); // 检查扩容    return null;&#125;\n\n三、JDK7 与 JDK8 HashMap 核心差异对比\n\n\n特性\nJDK7 HashMap\nJDK8 HashMap\n\n\n\n底层结构\n数组 + 单向链表\n数组 + 链表 + 红黑树\n\n\n节点插入方式\n头插法（链表反转）\n尾插法（顺序保留）\n\n\n哈希计算\n二次哈希（效果有限）\n高位异或（减少冲突）\n\n\n扩容节点迁移\n重新计算索引\n基于旧容量判断（高效迁移）\n\n\n极端查询性能\nO (n)（链表过长）\nO (logn)（红黑树优化）\n\n\n初始化时机\n构造器直接创建数组\n首次 put 时延迟初始化\n\n\n线程安全隐患\n多线程扩容可能形成环形链表\n尾插法避免环形链表（仍不安全）\n\n\n四、实战指南：不同版本下的使用建议1. 版本选择\n新系统优先使用 JDK8 及以上版本，享受红黑树和高效扩容带来的性能提升。\n\n维护 JDK7 旧系统时，避免在多线程场景使用 HashMap，改用ConcurrentHashMap。\n\n\n2. 初始容量设置无论哪个版本，均需根据预期数据量设置初始容量，减少扩容次数：\n初始容量 &#x3D; (预期元素数 &#x2F; 0.75) + 1（0.75 为默认加载因子）。\n例如：存储 1000 个元素，建议初始容量为(1000&#x2F;0.75)+1≈1334（实际会调整为 2048，2 的幂）。\n3. 线程安全处理\nJDK7&#x2F;8 的 HashMap 均线程不安全，多线程场景需替换为：\n\n\nConcurrentHashMap（推荐，JDK8 + 基于 CAS 实现，性能优异）；\n\n\n\nCollections.synchronizedMap()（全局锁，性能较差）。\n\n\n\n4. key 的设计原则\n优先使用不可变对象（如 String、Long），避免hashCode变化导致的查询异常。\n\n自定义类作为 key 时，必须同时重写hashCode()和equals()，保证逻辑一致。\n\n\n总结从 JDK7 到 JDK8，HashMap 的演进本质是 “解决实际问题” 的过程：用红黑树解决链表过长的性能问题，用尾插法规避线程安全风险，用延迟初始化优化内存占用。这些变化不仅提升了工具类的实用性，更体现了 “平衡时间与空间” 的设计哲学。\n理解两个版本的差异，不仅能帮助我们在开发中合理选型、规避风险，更能让我们从源码层面学到 “发现问题 - 解决问题” 的思维方式 —— 这正是深入学习 Java 集合框架的核心价值。\n","categories":["编程语言"],"tags":["JAVA","集合"]},{"title":"MySQL 基础操作与编码设置：从入门到避坑","url":"/2025/08/16/MySQL-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%81%BF%E5%9D%91/","content":"MySQL 基础操作与编码设置：从入门到避坑掌握 MySQL 的基础操作是使用数据库的第一步，而字符集设置不当导致的乱码问题则是新手常踩的 “坑”。本文从实际操作出发，带你快速上手数据库基本操作，并解决中文存储的常见问题。\n一、MySQL 基础操作：从数据库到表的核心命令1. 查看所有数据库登录 MySQL 后，首先可以查看当前服务器中的所有数据库：\nSHOW DATABASES;\n\n系统默认包含 4 个核心数据库：\n\ninformation_schema：存储数据库元信息（如库名、表名、字段类型等）；\n\nperformance_schema：用于监控数据库性能；\n\nsys：简化性能监控的视图集合；\n\nmysql：存储用户权限、系统配置等核心信息。\n\n\n2. 创建自己的数据库使用create database命令创建自定义数据库，名称需唯一：\n-- 创建名为cyforkkdb的数据库CREATE DATABASE cyforkkdb;\n\n3. 切换到目标数据库对数据库操作前需先指定目标库，使用use命令：\n-- 切换到cyforkkdb数据库USE cyforkkdb;\n\n\n提示：若未执行use命令直接操作表，会报错No database selected。\n\n4. 查看数据库中的表切换到目标库后，查看所有表：\n-- 查看当前数据库的表show tables;SHOW TABLES;-- 查看指定数据库的表（无需切换库） SHOW TABLES FORM 数据库名;\n\n5. 创建数据表使用create table定义表结构，需指定字段名和数据类型：\n-- 创建student表（包含id和name字段）CREATE TABLE student(  id int,  -- 整数类型  name varchar(20)  -- 字符串类型，最长20个字符);\n\n6. 查看表数据新表默认无数据，可通过select命令查看：\n-- 查看student表的所有数据SELECT * FROM student;\n\n7. 插入数据使用insert into添加记录：\n-- 向student表插入两条记录INSERT INTO student VALUES(1, &#x27;张三&#x27;);INSERT INTO student VALUES(2, &#x27;李四&#x27;);\n\n\n注意：若插入中文时出现Incorrect string value错误，大概率是字符集不支持中文，需按后文方法配置。\n\n8. 查看表 &#x2F; 库的创建信息通过show create命令可查看表或数据库的详细配置（包括字符集）：\n-- 查看student表的创建信息（\\G用于格式化输出）SHOW CREATE TABLE student\\G-- 查看cyforkkdb数据库的创建信息SHOW CREATE DATABASE cyforkkdb\\G\n\n9. 删除表和数据库删除操作需谨慎，执行后数据无法恢复：\n-- 删除student表DROP TABLE student;-- 删除atguigudb数据库DROP DATABASE cyforkkdb;\n\n二、字符集设置：解决中文乱码问题1. 问题表现插入中文时提示ERROR 1366 (HY000): Incorrect string value，或查询时显示乱码，本质是字符集不支持中文（默认latin1）。\n2. 查看当前字符集通过以下命令检查字符集配置：\n-- 查看字符集相关变量SHOW VARIABLES LIKE &#x27;character_%&#x27;;SHOW VARIABLES LIKE &#x27;collation_%&#x27;;\n\n3. MySQL 5.7 配置方法步骤 1：修改配置文件my.ini找到安装目录下的my.ini（默认路径：C:\\ProgramData\\MySQL\\MySQL Server 5.7），添加以下配置：\n[mysql]default-character-set=utf8  -- 客户端默认字符集[mysqld]character-set-server=utf8  -- 服务器默认字符集collation-server=utf8_general_ci  -- 服务器默认排序规则\n\n步骤 2：重启服务-- 停止服务（mysql57是服务名）net stop mysql57-- 启动服务net start mysql57\n\n步骤 3：验证配置重新登录后执行show variables like ‘character_%’;，确认character_set_server等参数为utf8。\n4. MySQL 8.0 的优势MySQL 8.0 默认字符集为utf8mb4（支持所有中文、emoji 和生僻字），无需手动配置即可正常存储中文，从根源解决乱码问题。\n5. 已有库 &#x2F; 表的字符集修改若修改配置前已创建库或表，需手动调整：\n-- 修改数据库字符集ALTER DATABASE 数据库名 charset utf8;-- 修改表字符集（仅影响新字段）ALTER TABLE 表名 charset utf8;-- 修改字段字符集（需指定字段类型）ALTER TABLE 表名 MODIFY 字段名 varchar(20) charset utf8;\n\n总结MySQL 基础操作围绕 “库 - 表 - 数据” 三层结构展开，核心命令包括create、use、insert、select等。中文乱码问题的关键是字符集配置，MySQL 5.7 需手动修改my.ini为utf8，而 8.0 默认utf8mb4更省心。掌握这些内容，即可完成日常数据存储与查询需求。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 基础：SELECT 语句的核心语法与规范","url":"/2025/08/16/MySQL-%E5%9F%BA%E7%A1%80%EF%BC%9ASELECT-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%A7%84%E8%8C%83/","content":"MySQL 基础：SELECT 语句的核心语法与规范SELECT 语句是 MySQL 中最基础也最常用的查询命令，掌握其语法规则和使用规范，是高效处理数据的第一步。本文将聚焦 SELECT 语句的基本结构、关键规范及实用功能，帮助初学者建立扎实的 SQL 基础。\n一、SELECT 语句的基本语法结构1. 核心语法框架SELECT 语句的最基础结构用于从表中提取指定字段的数据，语法如下：\n-- 选择指定字段SELECT 字段1, 字段2, ... FROM 表名;-- 选择所有字段（不推荐在生产环境使用）SELECT * FROM 表名;\n\n2. 关键说明\nSELECT 后接需要查询的字段名，多个字段用英文逗号分隔；\n\nFROM 后必须指定数据来源的表名，否则会触发语法错误；\n\n语句必须以英文分号 ; 结束，这是 MySQL 语句的通用规则。\n\n\n二、SELECT * 的使用禁忌与替代方案SELECT * 能快速返回表中所有字段，但在实际开发中存在明显弊端，需谨慎使用：\n1. 不推荐使用的原因\n效率低下：会返回无关字段，增加数据库 IO 压力和网络传输成本，尤其对包含大量字段的大表影响显著；\n\n稳定性差：当表结构变更（如新增 &#x2F; 删除字段）时，查询结果会意外包含或丢失数据，可能导致依赖查询结果的应用程序出错；\n\n可读性低：无法直观判断查询的具体字段，不利于代码维护。\n\n\n2. 推荐做法明确指定所需字段，例如：\n-- 推荐：只查询必要字段SELECT id, username, register_time FROM user;-- 不推荐：返回所有字段SELECT id, username, register_time, password, email, phone, ...  -- 字段过多时可换行FROM user;\n\n三、SQL 大小写规范与书写建议MySQL 对大小写的敏感性随操作系统不同而变化，遵循统一规范可避免低级错误：\n1. 大小写规则\nWindows 环境：大小写不敏感（SELECT 与 select 等效）；\n\nLinux 环境：大小写敏感（数据库名、表名、表别名严格区分大小写）。\n\n\n2. 通用书写规范\n关键字（如 SELECT、FROM、WHERE）全部大写；\n\n表名、字段名、别名等全部小写；\n\n多字段或复杂语句分行书写并缩进，提升可读性：\n\n\n-- 规范示例SELECT     id,     product_name,     price FROM     product WHERE     stock &gt; 0;\n\n四、列别名：提升结果可读性的实用技巧列别名用于给查询结果中的字段临时命名，让输出更直观，不影响原表结构。\n1. 语法格式-- 格式1：使用 AS 关键字（推荐，可读性强）SELECT 字段名 AS 别名 FROM 表名;-- 格式2：省略 AS（需在字段名与别名间加空格）SELECT 字段名 别名 FROM 表名;\n\n2. 注意事项\n若别名包含空格、特殊字符（如括号、中文），需用双引号 “ 或反引号 &#96; 包裹：\n\nSELECT     user_id AS &quot;用户 ID&quot;,  -- 别名含空格    order_no `订单编号(2023)`  -- 别名含特殊字符FROM order;\n\n\n别名仅在当前查询结果中生效，不会修改表中实际字段名。\n\n五、去重查询：DISTINCT 关键字的正确用法DISTINCT 用于提取唯一值，消除结果中的重复记录，适用于统计不重复数据的场景。\n1. 基本语法SELECT DISTINCT 字段名 FROM 表名;\n\n2. 关键特性\nDISTINCT 作用于其后的所有字段，而非单个字段。例如 SELECT DISTINCT a, b 会对 a 和 b 的组合去重；\n\n若字段包含 NULL，DISTINCT 会将所有 NULL 视为相同值，仅保留一条。\n\n\n3. 示例-- 对单个字段去重：查询所有不重复的部门 IDSELECT DISTINCT department_id FROM employee;-- 对多个字段去重：查询不重复的&quot;部门-职位&quot;组合SELECT DISTINCT department_id, job_title FROM employee;\n\n六、空值（NULL）的特殊处理规则NULL 表示 “未知值”，与空字符串 “” 完全不同（空字符串长度为 0，NULL 长度未知且占用存储空间），处理方式需特别注意：\n1. 核心规则\n不能用 &#x3D; 或 !&#x3D; 判断 NULL，必须使用 IS NULL（判断为空）或 IS NOT NULL（判断非空）；\n\nNULL 与任何值运算的结果都为 NULL（如 NULL + 1、NULL || ‘abc’ 均返回 NULL）。\n\n\n2. 示例-- 查询未填写邮箱的用户SELECT username FROM user WHERE email IS NULL;-- 查询已填写手机号的用户SELECT username FROM user WHERE phone IS NOT NULL;\n\n七、着重号：解决关键字冲突的必备技巧若表名、字段名与 SQL 关键字（如 order、select）重名，需用反引号 &#96; 包裹，避免语法错误。\n-- 表名是关键字 order，用着重号包裹SELECT * FROM `order`;-- 字段名是关键字 desc，用着重号包裹SELECT `desc` FROM product;\n\n八、常数查询：为结果添加固定标识SELECT 语句支持直接查询常数，在结果中增加固定值列，常用于标记数据来源或整合多数据源。\n1. 应用场景\n区分不同表的查询结果（如多表数据合并时）；\n\n为结果添加业务标识（如数据归属、统计版本）。\n\n\n2. 示例-- 为员工表查询结果添加公司标识SELECT     &#x27;技术部&#x27; AS department,  -- 固定常数列    emp_name,     hire_date FROM employee;\n\n查询结果：\n\n\n\ndepartment\nemp_name\nhire_date\n\n\n\n技术部\n张三\n2023-01-15\n\n\n技术部\n李四\n2023-03-20\n\n\n九、显示表结构：DESCRIBE &#x2F; DESC 命令使用 DESCRIBE 或 DESC 可查看表的字段详情，是分析表结构的常用工具。\n1. 语法-- 完整写法DESCRIBE 表名;-- 简写DESC 表名;\n\n2. 输出字段含义执行 DESC user; 后，输出结果包含以下信息：\n\nField：字段名称；\n\nType：字段数据类型（如 INT、VARCHAR(50)）；\n\nNull：是否允许存储 NULL 值（YES 表示允许）；\n\nKey：索引类型（PRI 为主键，UNI 为唯一索引）；\n\nDefault：字段默认值；\n\nExtra：附加信息（如 AUTO_INCREMENT 表示自增）。\n\n\n十、条件过滤：WHERE 子句的基础用法WHERE 子句用于筛选符合条件的记录，必须紧跟 FROM 子句，是数据过滤的核心工具。\n1. 语法结构SELECT 字段名 FROM 表名 WHERE 条件表达式;\n\n2. 示例-- 查询价格大于 100 且库存大于 0 的商品SELECT name, price FROM product WHERE price &gt; 100 AND stock &gt; 0;-- 查询注册时间在 2023 年的用户SELECT username FROM user WHERE register_time BETWEEN &#x27;2023-01-01&#x27; AND &#x27;2023-12-31&#x27;;\n\n总结：核心要点速览\n避免SELECT *，明确指定需要的字段，提升效率和稳定性；\n\n善用列别名让结果更易读，特殊别名用双引号包裹；\n\nDISTINCT对其后所有字段去重，注意NULL的处理；\n\nNULL需用IS NULL判断，与空字符串不同；\n\n关键字冲突用着重号（&#96;）解决；\n\n常数查询可标记数据来源，DESC用于查看表结构；\n\nWHERE子句紧随FROM，用于筛选符合条件的记录。\n\n\n掌握这些技巧，能让你的 SQL 查询更高效、更易维护，为复杂查询打下坚实基础。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"LinkedHashMap、HashSet、LinkedHashSet 深度解析：从源码到实战","url":"/2025/08/11/LinkedHashMap%E3%80%81HashSet%E3%80%81LinkedHashSet-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%AE%9E%E6%88%98/","content":"LinkedHashMap、HashSet、LinkedHashSet 深度解析：从源码到实战在 Java 集合框架中，LinkedHashMap、HashSet 和 LinkedHashSet 是基于 HashMap 衍生出的高频使用类。它们看似独立，实则底层紧密关联，各自在 “有序性” 和 “去重性” 上形成互补。本文将从源码实现入手，解析三者的设计逻辑与适用场景，帮你在开发中精准选型。\n一、LinkedHashMap：HashMap 的 “有序升级版”LinkedHashMap 是 HashMap 的子类，核心优势是支持有序存储，通过维护双向链表记录元素顺序，完美解决了 HashMap”无序” 的痛点。\n1. 底层结构：HashMap + 双向链表LinkedHashMap 的底层由两部分组成：\n\n哈希表：继承自 HashMap 的 “数组 + 链表 + 红黑树” 结构，保证键值对的高效存取；\n\n双向链表：额外维护一条贯穿所有节点的双向链表，记录元素的插入顺序或访问顺序。\n\n\n节点结构在 HashMap 的 Node 基础上新增了两个指针：\nstatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;    Entry&lt;K,V&gt; before, after; // 双向链表指针    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;        super(hash, key, value, next);    &#125;&#125;\n\n2. 核心特性：两种有序模式LinkedHashMap 通过accessOrder属性控制有序性（默认false）：\n\n插入顺序（accessOrder&#x3D;false）：迭代时与元素插入顺序一致，新增元素放在链表尾部。\n\nMap&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;();map.put(&quot;b&quot;, 2);map.put(&quot;a&quot;, 1);map.put(&quot;c&quot;, 3);// 迭代结果：b→a→c（与插入顺序相同）\n\n\n访问顺序（accessOrder&#x3D;true）：调用get、put等方法访问元素后，该元素会被移到链表尾部（最近访问的元素在尾部），天然适配 LRU（最近最少使用）缓存场景。\n\n3. 关键方法：实现 LRU 缓存通过重写removeEldestEntry方法，可自定义 “当新增元素后是否删除最老元素”：\n// 实现容量为3的LRU缓存Map&lt;String, Integer&gt; lruCache = new LinkedHashMap&lt;&gt;(16, 0.75f, true) &#123;    @Override    protected boolean removeEldestEntry(Map.Entry&lt;String, Integer&gt; eldest) &#123;        return size() &gt; 3; // 超过3个元素则删除最老的    &#125;&#125;;\n\n4. 与 HashMap 的核心差异\n\n\n特性\nHashMap\nLinkedHashMap\n\n\n\n有序性\n无序\n支持插入顺序 &#x2F; 访问顺序\n\n\n性能\n插入 &#x2F; 删除略快\n因维护双向链表，迭代效率更高\n\n\n内存占用\n较低\n较高（多维护双向链表指针）\n\n\n二、HashSet：基于 HashMap 的 “去重容器”HashSet 是专门用于元素去重的集合，底层完全依赖 HashMap 实现，可理解为 “只存 key 的 HashMap”。\n1. 底层实现：HashMap 的包装类HashSet 内部持有一个 HashMap 实例，所有操作均通过该 map 完成：\npublic class HashSet&lt;E&gt; &#123;    private transient HashMap&lt;E, Object&gt; map;    private static final Object PRESENT = new Object(); // 固定value    public HashSet() &#123;        map = new HashMap&lt;&gt;();    &#125;    // 添加元素本质是map的put操作    public boolean add(E e) &#123;        return map.put(e, PRESENT) == null; // key存在则返回false    &#125;&#125;\n\n2. 核心特性\n去重规则：与 HashMap 的 key 一致 —— 两个元素hashCode相等且equals返回 true，则视为重复。\n\n无序性：存储顺序与插入顺序无关（同 HashMap 的 key 特性）。\n\n允许 null 元素：但仅能存一个（null 的 hashCode 固定为 0）。\n\n\n3. 基础用法示例Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;apple&quot;);set.add(&quot;banana&quot;);set.add(&quot;apple&quot;); // 重复元素，添加失败System.out.println(set.size()); // 输出2// 遍历（无序）for (String s : set) &#123;    System.out.println(s); // 顺序不确定&#125;\n\n三、LinkedHashSet：HashSet 的 “有序版”LinkedHashSet 是 HashSet 的子类，底层依赖 LinkedHashMap 实现，同时具备去重性和插入顺序性。\n1. 底层实现：LinkedHashMap 的包装类与 HashSet 类似，LinkedHashSet 通过父类构造器初始化 LinkedHashMap：\npublic class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;    public LinkedHashSet() &#123;        // 调用HashSet的构造器，实际创建LinkedHashMap        super(16, 0.75f, true);    &#125;&#125;// HashSet中对应的构造器HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125;\n\n2. 核心特性\n有序性：默认按插入顺序排序（迭代时与插入顺序一致），且顺序不随元素访问变化（区别于 LinkedHashMap 的访问顺序）。\n\n去重性：与 HashSet 一致，依赖 LinkedHashMap 的 key 去重逻辑。\n\n\n3. 用法示例Set&lt;String&gt; linkedSet = new LinkedHashSet&lt;&gt;();linkedSet.add(&quot;b&quot;);linkedSet.add(&quot;a&quot;);linkedSet.add(&quot;c&quot;);// 遍历（按插入顺序）for (String s : linkedSet) &#123;    System.out.println(s); // 输出：b→a→c&#125;\n\n四、三者对比与实战选型1. 核心差异对比表\n\n\n集合类型\n底层依赖\n有序性\n去重性\n典型应用场景\n\n\n\nLinkedHashMap\nHashMap + 双向链表\n插入顺序 &#x2F; 访问顺序\n键唯一\nLRU 缓存、有序映射、历史记录\n\n\nHashSet\nHashMap\n无序\n元素唯一\n标签去重、快速判重\n\n\nLinkedHashSet\nLinkedHashMap\n插入顺序\n元素唯一\n有序去重（如日志记录、流程步骤）\n\n\n2. 实战选型建议\n需要键值对且有序：用 LinkedHashMap（如配置参数按插入顺序输出）。\n\n仅需元素去重且无序：用 HashSet（如用户标签去重）。\n\n需去重且保留插入顺序：用 LinkedHashSet（如接口调用参数记录）。\n\n高频迭代操作：优先选 LinkedHashMap&#x2F;LinkedHashSet（迭代效率更高）。\n\n内存敏感场景：优先选 HashMap&#x2F;HashSet（内存占用更低）。\n\n\n总结LinkedHashMap、HashSet 和 LinkedHashSet 的设计充分体现了 Java 集合框架的 “复用性” 思想：\n\n给 HashMap 加双向链表，得到支持有序的 LinkedHashMap；\n\n封装 HashMap 的 key，得到用于去重的 HashSet；\n\n用 LinkedHashMap 替代 HashMap，得到有序去重的 LinkedHashSet。\n\n\n理解这种 “基于已有实现扩展功能” 的设计思路，不仅能帮你快速掌握 API 用法，更能在实际开发中学会 “站在巨人肩膀上” 设计简洁高效的代码。记住：没有最好的集合，只有最适合场景的选择。\n","categories":["编程语言"],"tags":["JAVA","集合"]},{"title":"MySQL 分页查询：用 LIMIT 高效处理大量数据","url":"/2025/08/19/MySQL-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%EF%BC%9A%E7%94%A8-LIMIT-%E9%AB%98%E6%95%88%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/","content":"MySQL 分页查询：用 LIMIT 高效处理大量数据在实际开发中，当查询结果包含成百上千条记录时，一次性展示所有数据会导致加载缓慢、用户体验差。分页查询能将数据分段展示，既减轻服务器压力，又方便用户浏览。MySQL 中通过LIMIT子句实现分页，本文将详细讲解其用法、原理及实战技巧。\n一、分页的必要性：为什么需要分页？分页查询的核心价值在于高效处理大量数据，主要解决以下问题：\n\n数据过载：一次性返回 10 万条记录会占用大量内存和网络带宽，导致页面卡顿；\n\n用户体验：用户通常只关注前几页数据，分页可聚焦核心内容；\n\n查询效率：数据库无需扫描全表，仅返回指定范围的记录，减少资源消耗。\n\n\n示例场景：\n\n电商平台的商品列表（每页显示 20 条）；\n\n后台系统的用户管理（每页显示 50 条）；\n\n日志查询（按时间分页加载）。\n\n\n二、MySQL 分页核心：LIMIT 子句的用法MySQL 中通过LIMIT子句实现分页，语法简洁且功能灵活，支持指定起始位置和返回条数。\n1. 基本语法结构SELECT 字段1, 字段2, ...FROM 表名[WHERE 条件]  -- 可选，筛选数据[ORDER BY 排序字段]  -- 可选，排序后再分页LIMIT [偏移量,] 行数;  -- 必须放在语句最后\n\n\n参数说明：\n\n\n行数：必填，指定返回的记录条数；\n\n\n\n偏移量：可选，指定从第几条记录开始返回（从 0 开始计数，默认值为 0）；\n\n\n\nMySQL 8.0 支持LIMIT 行数 OFFSET 偏移量（与LIMIT 偏移量, 行数等效，更易读）。\n\n\n\n2. 基础示例：获取指定范围的记录假设employees表有 100 条数据，每页显示 10 条，分页查询示例如下：\n-- 第1页：返回前10条（偏移量0，取10条）SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESC  -- 先排序再分页，确保顺序一致LIMIT 10;  -- 等价于 LIMIT 0, 10-- 第2页：返回11-20条（偏移量10，取10条）SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESCLIMIT 10, 10;  -- 偏移量=10，行数=10-- 第3页：返回21-30条（偏移量20，取10条）SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESCLIMIT 20, 10;-- MySQL 8.0写法（第2页，更直观）SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESCLIMIT 20 OFFSET 10;  -- 行数=20，偏移量=10\n\n3. 通用分页公式：快速计算偏移量当已知 “当前页码” 和 “每页条数” 时，可通过公式快速计算偏移量：\n偏移量 = (当前页码 - 1) × 每页条数\n\n示例：\n\n每页显示 15 条，查询第 5 页数据：\n\nSELECT * FROM productsORDER BY create_time DESCLIMIT (5-1)*15, 15;  -- 偏移量=60，行数=15\n\n三、关键特性与注意事项1. LIMIT 的位置：必须放在语句最后LIMIT是 SQL 语句中最后执行的子句，其执行顺序如下：\n\nFROM：确定数据来源表；\n\nWHERE：筛选符合条件的记录；\n\nORDER BY：对筛选后的记录排序；\n\nLIMIT：从排序后的结果中截取指定范围的记录。\n\n\n\n错误示例：LIMIT放在ORDER BY之前会导致分页基于未排序的数据，结果混乱。\n\n-- 错误：LIMIT位置错误SELECT * FROM employees LIMIT 10 ORDER BY salary DESC;\n\n2. 偏移量的特殊性：从 0 开始计数LIMIT的偏移量从 0 开始（即第一条记录的偏移量为 0），而非 1，这是初学者常犯的错误。\n\n正确：第 1 条记录的偏移量为 0（LIMIT 0,1）；\n\n错误：误认为第 1 条记录的偏移量为 1（LIMIT 1,1会返回第 2 条记录）。\n\n\n3. 提升效率的技巧\n结合排序使用：分页前务必排序（如ORDER BY id DESC），否则每次分页的结果顺序可能不一致；\n\n限制返回行数：若已知结果只有 1 条（如查询唯一用户），用LIMIT 1可让数据库找到结果后立即停止扫描，大幅提升效率：\n\n\n-- 高效：找到1条后立即返回SELECT * FROM users WHERE username = &#x27;admin&#x27; LIMIT 1;\n\n\n避免超大偏移量：当偏移量很大（如LIMIT 100000, 10），查询效率会下降，可通过条件过滤优化：\n\n-- 优化前：偏移量过大SELECT * FROM logs LIMIT 100000, 10;-- 优化后：用索引字段过滤（假设id自增）SELECT * FROM logs WHERE id &gt; 100000 LIMIT 10;\n\n四、跨数据库分页对比：不同数据库的实现方式不同数据库的分页语法不同，迁移时需注意差异：\n\n\n\n数据库\n分页关键字 &#x2F; 语法\n示例（取前 5 条）\n\n\n\nMySQL\nLIMIT\nSELECT * FROM heros LIMIT 5;\n\n\nSQL Server\nTOP\nSELECT TOP 5 * FROM heros;\n\n\nDB2\nFETCH FIRST … ROWS ONLY\nSELECT * FROM heros FETCH FIRST 5 ROWS ONLY;\n\n\nOracle\nROWNUM（需子查询）\nSELECT * FROM (SELECT * FROM heros ORDER BY id) WHERE ROWNUM &lt;&#x3D; 5;\n\n\n五、总结：核心要点速览\n\n\n内容\n关键说明\n\n\n\n基本语法\nLIMIT [偏移量,] 行数 或 LIMIT 行数 OFFSET 偏移量（MySQL 8.0+）\n\n\n分页公式\n偏移量 &#x3D; (当前页码 - 1) × 每页条数，确保分页逻辑正确\n\n\n执行顺序\n放在语句最后，在ORDER BY之后，基于排序后的结果分页\n\n\n效率技巧\n结合排序使用，结果唯一时用LIMIT 1，避免超大偏移量（用条件过滤替代）\n\n\n跨库差异\nMySQL 用LIMIT，SQL Server 用TOP，Oracle 用ROWNUM，迁移时需调整语法\n\n\n掌握LIMIT分页不仅能提升数据展示效率，还能减少服务器负载，是处理大量数据的必备技能。实际开发中，建议结合业务场景合理设置每页条数（通常 10-50 条），并通过排序和索引优化进一步提升查询性能。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 实战：5 道基础 SELECT 语句练习题解析","url":"/2025/08/19/MySQL-%E5%AE%9E%E6%88%98%EF%BC%9A5-%E9%81%93%E5%9F%BA%E7%A1%80-SELECT-%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/","content":"MySQL 实战：5 道基础 SELECT 语句练习题解析在 MySQL 学习中，实战练习是掌握基础语法的关键。本文通过 5 道经典 SELECT 语句练习题，带你巩固查询操作的核心知识点，从简单查询到条件筛选，逐步提升 SQL 应用能力。\n一、计算员工年薪（算术运算与别名）需求查询员工 12 个月的工资总和，并起别名为ANNUAL SALARY。\n解决方案-- 基础版：仅计算基本工资的年薪SELECT employee_id, last_name, salary * 12 &quot;ANNUAL SALARY&quot;FROM employees;-- 进阶版：包含佣金的年薪（处理NULL值）SELECT employee_id, last_name,        salary * 12 * (1 + IFNULL(commission_pct, 0)) &quot;ANNUAL SALARY&quot;FROM employees;\n\n知识点解析\n算术运算：salary * 12 实现月工资到年薪的转换，* 为乘法运算符；\n\n别名：用双引号 “” 定义别名 ANNUAL SALARY（含空格需加引号）；\n\nNULL 处理：IFNULL(commission_pct, 0) 将佣金率（可能为 NULL）转换为 0，避免因NULL * 数值导致结果为 NULL。\n\n\n二、查询去重的职位 ID（DISTINCT 关键字）需求查询employees表中去除重复的job_id以后的数据。\n解决方案SELECT DISTINCT job_idFROM employees;\n\n知识点解析\nDISTINCT 作用：对其后的字段（此处为job_id）进行去重，仅保留唯一值；\n\n注意：DISTINCT 作用于所有指定字段，若写 SELECT DISTINCT job_id, department_id，则对两个字段的组合去重。\n\n\n三、筛选高工资员工（WHERE 条件过滤）需求查询工资大于 12000 的员工姓名和工资。\n解决方案SELECT last_name, salaryFROM employeesWHERE salary &gt; 12000;\n\n知识点解析\nWHERE 子句：用于筛选符合条件的记录，紧跟FROM子句；\n\n比较运算符：&gt; 表示 “大于”，其他常用比较符有 &lt;、&gt;&#x3D;、&lt;&#x3D;、&#x3D; 等；\n\n性能建议：若salary字段有索引，WHERE salary &gt; 12000可利用索引提升查询效率。\n\n\n四、查询指定员工信息（精确匹配）需求查询员工号为 176 的员工的姓名和部门号。\n解决方案SELECT last_name, department_idFROM employeesWHERE employee_id = 176;\n\n知识点解析\n精确匹配：&#x3D; 用于判断字段值与指定值是否相等（此处employee_id为整数，直接写数值即可）；\n\n主键查询：employee_id通常为主键，主键查询效率极高，因为主键默认是唯一索引。\n\n\n五、查看表结构与全量数据（DESC 与 SELECT *）需求显示表departments的结构，并查询其中的全部数据。\n解决方案-- 显示表结构DESC departments;  -- 或使用 DESCRIBE departments;-- 查询全部数据（仅建议在测试环境使用）SELECT * FROM departments;\n\n知识点解析\nDESC 命令：查看表的字段信息，包括字段名（Field）、类型（Type）、是否允许 NULL（Null）、索引（Key）等；\n\n**SELECT ***：返回表中所有字段的全部记录，缺点是效率低（尤其大表）且结构变更时易出错，生产环境不推荐。\n\n\n总结：基础查询的核心要点\n算术运算：支持+、-、*、&#x2F;，注意用IFNULL处理NULL值；\n\n去重：DISTINCT 用于提取唯一值，作用于其后所有字段；\n\n条件筛选：WHERE 子句结合比较运算符（&gt;、&#x3D;等）实现精准过滤；\n\n表结构查看：DESC 命令快速了解表设计；\n\n别名规范：用双引号定义含特殊字符的别名，提升结果可读性。\n\n\n通过这 5 道题，可掌握 SELECT 语句的基本用法。实际开发中，需根据业务需求灵活组合这些技巧，同时注意查询效率和代码规范性。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 安装避坑指南：服务启动与登录问题全解析","url":"/2025/08/14/MySQL-%E5%AE%89%E8%A3%85%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98%E5%85%A8%E8%A7%A3%E6%9E%90/","content":"MySQL 安装避坑指南：服务启动与登录问题全解析MySQL 作为最流行的关系型数据库之一，安装过程中难免遇到各种问题，尤其是服务启动失败和登录报错，常常让初学者头疼。本文结合实战经验，总结了 MySQL 安装后服务启动与用户登录的常见问题及解决方案，帮你快速排查故障，顺利开启数据库之旅。\n一、服务启动常见问题与解决方法MySQL 安装完成后，首先需要启动服务才能正常使用。服务启动失败是最常见的 “拦路虎”，主要集中在这几个场景：\n1. 服务未安装或安装失败现象：执行net start mysql时提示 “服务名无效”，或安装过程中提示 “服务安装失败”。\n原因：\n\n安装包损坏或权限不足；\n\n之前的 MySQL 服务未彻底卸载，残留注册表信息冲突。\n\n\n解决步骤：\n\n手动安装服务：\n\n以管理员身份打开命令提示符（CMD），进入 MySQL 的bin目录（如C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin），执行：\nmysqld --install [服务名]  # 服务名默认是mysql，可自定义\n\n提示 “Service successfully installed” 即为成功。\n\n彻底卸载残留服务：\n\n\n若提示 “服务已存在”，先删除旧服务：\n\nsc delete mysql  # 删除默认服务名mysql\n\n\n清理注册表：按下Win+R输入regedit，删除HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services中与 MySQL 相关的项。\n\n2. 端口被占用现象：服务启动后立即停止，查看错误日志（data目录下的.err文件）提示 “Port 3306 is already in use”。\n原因：默认端口 3306 被其他程序（如其他 MySQL 实例、Docker 容器）占用。\n解决步骤：\n\n查找占用程序：\n\nnetstat -ano | findstr 3306  # 找到占用3306端口的进程ID（PID）\n\n在任务管理器中结束对应 PID 的进程（若为无关程序）。\n\n修改 MySQL 端口：\n\n打开配置文件my.ini（或my.cnf），在[mysqld]下添加：\nport=3307  # 改为未占用的端口（如3307）\n\n重启服务后，登录时需指定端口：mysql -u root -P 3307 -p。\n3. 配置文件错误现象：服务启动失败，日志提示 “Unknown variable” 或 “Invalid configuration”。\n原因：my.ini配置文件存在语法错误（如拼写错误、参数值格式错误）。\n解决步骤：\n\n检查核心配置：确保[mysqld]下的基础配置正确：\n\nbasedir = C:/Program Files/MySQL/MySQL Server 8.0  # 安装目录（注意用斜杠/）datadir = C:/Program Files/MySQL/MySQL Server 8.0/data  # 数据目录default-character-set = utf8mb4  # 字符集\n\n\n恢复默认配置：若无法定位错误，可删除自定义配置，使用安装包自带的默认my.ini（通常在ProgramData目录下）。\n\n二、用户登录常见错误与解决方案服务启动成功后，登录时可能遇到密码错误、权限不足等问题，以下是高频场景的处理方法：\n1. 密码错误或忘记密码现象：登录提示 “Access denied for user ‘root‘@’localhost‘ (using password: YES)”。\n原因：密码输入错误，或安装时未记录随机密码（MySQL 8.0 + 默认生成随机密码）。\n解决步骤：\n\n重置 root 密码：\n\n\n停止服务：net stop mysql\n\n跳过权限验证启动：\n\n\nmysqld --console --skip-grant-tables --shared-memory\n\n\n新打开一个 CMD 窗口，无密码登录：\n\nmysql -u root  # 直接回车，无需输入密码\n\n\n刷新权限并修改密码（MySQL 8.0 + 语法）：\n\nFLUSH PRIVILEGES;  # 刷新权限ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;新密码&#x27;;  # 新密码需包含大小写、数字和符号\n\n\n重启服务：关闭所有窗口，执行net start mysql，用新密码登录。\n\n2. 主机访问权限限制现象：远程登录提示 “Access denied for user ‘root‘@’192.168.1.100‘ (using password: YES)”。\n原因：默认情况下，root 用户仅允许localhost（本地）登录，未授权远程主机访问。\n解决步骤：\n\n本地登录 MySQL：\n\nmysql -u root -p  # 输入密码登录\n\n\n授权远程访问：\n\n-- 允许root从任意主机登录（生产环境不建议，可指定具体IP如192.168.1.%）CREATE USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;密码&#x27;;  GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; WITH GRANT OPTION;  FLUSH PRIVILEGES;  # 刷新权限\n\n3. 字符集或编码错误现象：登录后执行 SQL 提示 “Illegal mix of collations”，或中文显示乱码。\n原因：客户端与服务器字符集不一致。\n解决步骤：\n\n查看服务器字符集：\n\nSHOW VARIABLES LIKE &#x27;character_set_%&#x27;;\n\n\n统一字符集：在my.ini中添加：\n\n[mysqld]character-set-server = utf8mb4collation-server = utf8mb4_unicode_ci[client]default-character-set = utf8mb4\n\n重启服务后生效。\n三、最佳实践：避免问题的预防措施\n安装时注意事项：\n\n\n选择 “Custom” 自定义安装，明确记录basedir和datadir路径；\n\n若为 MySQL 8.0+，安装后及时记录临时密码（在data目录的.err文件中）。\n\n\n\n配置文件管理：\n\n\n备份my.ini，修改前复制一份副本；\n\n路径使用斜杠&#x2F;而非反斜杠\\（避免转义字符问题）。\n\n\n\n服务与端口管理：\n\n\n定期检查 3306 端口占用情况，避免与其他程序冲突；\n\n非必要不开放 root 用户远程访问，创建专用用户并分配最小权限。\n\n\n\n密码管理：\n\n\n使用强密码（长度≥8 位，包含大小写、数字和特殊符号）；\n\n定期通过ALTER USER命令修改密码，避免明文存储。\n\n\n总结MySQL 服务启动与登录问题多源于配置错误、资源冲突或权限设置，解决的核心是：善用错误日志定位原因，通过规范配置和权限管理预防问题。本文涵盖的场景和方法适用于 MySQL 5.7 和 8.0 版本，遇到问题时先查看data目录下的错误日志（.err文件），大部分故障都能从中找到线索。\n掌握这些技巧后，不仅能快速解决安装后的问题，更能培养排查数据库故障的思路，为后续的 MySQL 学习和使用打下坚实基础。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"Hexo 中 Butterfly 主题修改字体大小教程","url":"/2025/08/11/Hexo-%E4%B8%AD-Butterfly-%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E6%95%99%E7%A8%8B/","content":"Hexo 中 Butterfly 主题修改字体大小教程在使用 Hexo 搭建博客并采用 Butterfly 主题时，有时我们需要根据自己的阅读习惯调整字体大小，下面就来介绍具体的修改方法。\n找到配置文件首先，我们需要找到字体大小设置所在的文件，路径为：\n\\node_modules\\hexo-theme-butterfly\\source\\css\\var.styl\n\n可以通过文件管理器导航到该路径，也可以在博客的开发工具中直接定位到这个文件。\n修改字体大小参数打开var.styl文件后，我们会看到关于字体大小的配置代码：\n// Global Variables$font-size = hexo-config(&#x27;font.global_font_size&#x27;) ? convert(hexo-config(&#x27;font.global_font_size&#x27;)) : 18px  // 全局字体大小$code-font-size = hexo-config(&#x27;font.code_font_size&#x27;) ? convert(hexo-config(&#x27;font.code_font_size&#x27;)) : var(--global-font-size)  // 代码字体大小$font-color = #1F2D3D  // 字体颜色\n\n\n$font-size：这是全局字体大小的设置。代码的意思是，如果在 Hexo 的配置文件中设置了font.global_font_size，则使用该配置的值；如果没有设置，则默认使用 18px（如示例中修改后的数值）。我们可以直接修改这里的默认值（如 18px）来调整全局字体大小。\n\n$code-font-size：这是代码块字体大小的设置。同理，如果配置了font.code_font_size则使用该值，否则默认使用全局字体大小（var(–global-font-size)）。\n\n\n生效修改修改完成后，保存文件，然后在终端中执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s命令，重新生成并预览博客，就可以看到字体大小的变化了。如果是部署在服务器上，还需要执行hexo d命令重新部署。\n通过这种方式，我们可以简单有效地调整 Butterfly 主题下的字体大小，让博客更符合自己的阅读需求。\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"MySQL 排序与分页实战：3 道经典练习题解析","url":"/2025/08/18/MySQL-%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5%E5%AE%9E%E6%88%98%EF%BC%9A3-%E9%81%93%E7%BB%8F%E5%85%B8%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/","content":"MySQL 排序与分页实战：3 道经典练习题解析排序（ORDER BY）和分页（LIMIT）是 MySQL 查询中处理结果集的核心操作，常用于数据展示、报表生成等场景。本文通过 3 道实战练习题，详解排序与分页的组合用法，帮你掌握复杂结果集的处理技巧。\n一、多条件排序：按年薪和姓名组合排序题目 1查询员工的姓名、部门号和年薪，按年薪降序、姓名升序显示。\n解决方案SELECT   last_name,   department_id,   salary * 12 AS annual_sal  -- 计算年薪并起别名FROM employeesORDER BY annual_sal DESC,  -- 先按年薪降序（高薪在前）         last_name ASC;    -- 年薪相同时按姓名升序（A-Z）\n\n知识点解析\n计算字段与别名：salary * 12 计算年薪，用 AS 定义别名 annual_sal，简化排序条件；\n\n多列排序规则：\n\n\n\n\n先按第一个字段（annual_sal）排序，DESC 表示降序；\n\n\n\n当第一个字段值相同时，再按第二个字段（last_name）排序，ASC 表示升序（默认可省略）；\n\n\n\n\n排序依据：支持使用计算字段或别名排序，无需重复写计算逻辑（如直接用 annual_sal 而非 salary*12）。\n\n二、条件筛选 + 排序 + 分页：精准提取指定范围数据题目 2选择工资不在 8000 到 17000 的员工的姓名和工资，按工资降序，显示第 21 到 40 位置的数据。\n解决方案SELECT   last_name,   salaryFROM employeesWHERE salary NOT BETWEEN 8000 AND 17000  -- 筛选工资不在8000-17000的员工ORDER BY salary DESC  -- 按工资降序排序LIMIT 20, 20;  -- 从第21条开始（偏移量20），取20条（21-40）\n\n知识点解析\n范围筛选：NOT BETWEEN 8000 AND 17000 等价于 salary &lt; 8000 OR salary &gt; 17000，用于排除指定区间的数据；\n\n分页逻辑：\n\n\n\n\nLIMIT 偏移量, 行数 中，偏移量从 0 开始计数；\n\n\n\n第 21 到 40 条记录：偏移量 &#x3D; 20（前 20 条跳过），行数 &#x3D; 20（取 20 条）；\n\n\n\n\n执行顺序：先筛选（WHERE）、再排序（ORDER BY）、最后分页（LIMIT），确保分页基于筛选后的有序结果。\n\n三、函数 + 排序：按字段长度排序题目 3查询邮箱中包含字母e的员工信息，先按邮箱的字节数降序，再按部门号升序。\n解决方案SELECT   last_name,   email,   department_idFROM employeesWHERE email REGEXP &#x27;[e]&#x27;  -- 筛选邮箱包含e的员工（等价于 LIKE &#x27;%e%&#x27;）ORDER BY LENGTH(email) DESC,  -- 按邮箱字节数降序（长邮箱在前）         department_id ASC;   -- 字节数相同时按部门号升序\n\n知识点解析\n模糊筛选：\n\n\n\nemail REGEXP ‘[e]’ 与 email LIKE ‘%e%’ 功能相同，均匹配包含e的邮箱；\n\n\n\nREGEXP 支持更复杂的正则匹配，LIKE 适合简单通配符场景；\n\n\n\n\n字符串长度函数：LENGTH(email) 计算邮箱的字节数（注意：中文在不同编码下字节数可能不同，此处针对英文邮箱）；\n\n多维度排序：先按 “邮箱长度” 这一动态计算值排序，再按 “部门号” 这一字段排序，满足复杂业务需求。\n\n\n总结：排序与分页核心要点\n\n\n操作场景\n关键语法 &#x2F; 函数\n注意事项\n\n\n\n多列排序\nORDER BY 字段1 DESC, 字段2\n先按字段 1 排序，值相同时再按字段 2 排序\n\n\n分页查询\nLIMIT 偏移量, 行数\n偏移量从 0 开始，需结合ORDER BY确保顺序\n\n\n范围筛选\nBETWEEN…AND&#x2F;NOT BETWEEN\n闭区间包含边界值，反向筛选用NOT\n\n\n字符串长度计算\nLENGTH(字段)\n返回字节数，适合英文等单字节字符\n\n\n模糊匹配\nLIKE ‘%e%’&#x2F;REGEXP ‘[e]’\n简单场景用LIKE，复杂模式用REGEXP\n\n\n通过这 3 道题可以看出，排序与分页很少单独使用，通常需结合条件筛选、函数计算等操作。掌握它们的组合逻辑，能帮你高效处理各类结果集展示需求，无论是前端列表分页还是后台数据导出，都能应对自如。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 插入数据提示字段超出范围？一招解决 DECIMAL 类型踩坑","url":"/2025/08/16/MySQL-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%8F%90%E7%A4%BA%E5%AD%97%E6%AE%B5%E8%B6%85%E5%87%BA%E8%8C%83%E5%9B%B4%EF%BC%9F%E4%B8%80%E6%8B%9B%E8%A7%A3%E5%86%B3-DECIMAL-%E7%B1%BB%E5%9E%8B%E8%B8%A9%E5%9D%91/","content":"MySQL 插入数据提示字段超出范围？一招解决 DECIMAL 类型踩坑在日常数据库操作中，我们经常会遇到各种字段类型相关的问题。今天就来聊聊一个常见的错误：插入数据时提示字段值超出范围，以实际案例带你搞懂 MySQL 中 DECIMAL 类型的使用要点。\n问题场景再现先看一下我创建表和插入数据的操作：\n-- 创建商品表CREATE TABLE mini_product (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20) NOT NULL,    price DECIMAL(6,2)) ENGINE=InnoDB;-- 插入商品数据INSERT INTO mini_product (name, price) VALUES(&#x27;iPhone&#x27;, 6999.00),(&#x27;小米电视&#x27;, 3299.00),(&#x27;华为耳机&#x27;, 899.00),(&#x27;联想笔记本&#x27;, 5699.00),(&#x27;大疆无人机&#x27;, 7999.00),(&#x27;Kindle&#x27;, 998.00),(&#x27;Switch&#x27;, 2099.00),(&#x27;索尼相机&#x27;, 12999.00),  -- 此行报错(&#x27;机械键盘&#x27;, 599.00),(&#x27;移动硬盘&#x27;, 699.00);\n\n执行后，数据库直接抛出错误：\nERROR 1264 (22003): Out of range value for column ‘price’ at row 8\n错误原因分析这个错误的根源在于price字段的类型定义 ——DECIMAL(6,2)。\nDECIMAL 类型的格式是DECIMAL(M,D)，其中：\n\nM表示总位数（整数部分 + 小数部分），范围 1-65\n\nD表示小数部分的位数，范围 0-30，且D ≤ M\n\n\n对于DECIMAL(6,2)来说：\n\n总位数是 6 位\n\n小数部分固定占 2 位\n\n因此整数部分最多只能有 4 位（6-2&#x3D;4）\n\n最大可存储的值为 9999.99\n\n\n而第 8 行数据中，”索尼相机” 的价格是 12999.00，整数部分有 5 位（12999），明显超过了DECIMAL(6,2)能容纳的最大整数位数（4 位），所以导致了超出范围的错误。\n解决办法只需要调整price字段的精度，使其能够容纳更大的数值。\n根据我们的数据，最大价格是 12999.00，整数部分有 5 位，小数部分 2 位，所以总位数至少需要 7 位（5+2&#x3D;7）。\n执行以下 SQL 语句修改表结构：\nALTER TABLE mini_product MODIFY COLUMN price DECIMAL(7,2);\n\n修改后，DECIMAL(7,2)表示：\n\n总位数 7 位\n\n小数部分 2 位\n\n整数部分最多 5 位\n\n最大可存储的值为 99999.99，足以容纳 12999.00\n\n\n此时再重新执行插入语句，就能成功插入所有数据了。\n扩展知识：DECIMAL 类型使用建议\n根据实际业务数据范围选择合适的精度，既不要过大（浪费存储空间），也不要过小（无法存储有效数据）\n\n对于价格、金额等精确数值，优先使用 DECIMAL 类型，避免使用 FLOAT&#x2F;DOUBLE（可能存在精度丢失问题）\n\n设计表结构时，预估可能的最大数值，给字段预留一定的扩展空间\n\n常见场景参考：\n\n\n\n\n小额商品价格：DECIMAL (6,2)（最大 9999.99）\n\n\n\n中额商品价格：DECIMAL (8,2)（最大 999999.99）\n\n\n\n大额交易金额：DECIMAL (10,2)（最大 99999999.99）\n\n\n\n掌握 DECIMAL 类型的使用要点，能帮你避免很多数据存储相关的问题，让数据库设计更合理、更健壮。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 运算符实战：9 道经典练习题解析","url":"/2025/08/18/MySQL-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E6%88%98%EF%BC%9A9-%E9%81%93%E7%BB%8F%E5%85%B8%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/","content":"MySQL 运算符实战：9 道经典练习题解析运算符是 MySQL 查询的 “灵魂”，灵活运用各类运算符能让数据筛选更加精准高效。本文通过 9 道实战练习题，详解逻辑运算符、比较运算符及模糊匹配的用法，帮你快速掌握运算符的核心应用场景。\n一、范围查询：NOT BETWEEN 与 OR 的灵活运用题目 1：选择工资不在 5000 到 12000 的员工的姓名和工资解决方案-- 方法1：使用OR逻辑运算符SELECT last_name, salaryFROM employeesWHERE salary &lt; 5000 OR salary &gt; 12000;-- 方法2：使用NOT BETWEEN（更简洁）SELECT last_name, salaryFROM employeesWHERE salary NOT BETWEEN 5000 AND 12000;\n\n知识点解析\nBETWEEN AND：表示闭区间范围（包含边界值），salary BETWEEN 5000 AND 12000 等价于 salary &gt;&#x3D; 5000 AND salary &lt;&#x3D; 12000；\n\nNOT 取反：NOT BETWEEN 直接排除范围内的数据，比 OR 更简洁，可读性更高；\n\n适用场景：连续范围的反向筛选，优先用 NOT BETWEEN。\n\n\n二、集合查询：IN 与 OR 的效率对比题目 2：选择在 20 或 50 号部门工作的员工姓名和部门号解决方案-- 方法1：使用OR逻辑运算符SELECT last_name, department_idFROM employeesWHERE department_id = 20 OR department_id = 50;-- 方法2：使用IN集合运算符（推荐）SELECT last_name, department_idFROM employeesWHERE department_id IN (20, 50);\n\n知识点解析\nIN 运算符：用于匹配离散的多个值，IN (20,50) 等价于 &#x3D;20 OR &#x3D;50，但代码更简洁；\n\n性能优势：当集合元素较多（如 10 个以上），IN 的执行效率通常高于多个 OR 拼接；\n\n注意：IN 列表中若包含 NULL，不会影响非 NULL 值的匹配，但结果可能包含 NULL。\n\n\n三、NULL 值处理：IS NULL 与 IS NOT NULL题目 3：选择公司中没有管理者的员工姓名及 job_id解决方案SELECT last_name, job_idFROM employeesWHERE manager_id IS NULL;\n\n题目 4：选择公司中有奖金的员工姓名、工资和奖金级别解决方案SELECT last_name, salary, commission_pctFROM employeesWHERE commission_pct IS NOT NULL;\n\n知识点解析\nNULL 的特殊性：NULL 表示 “未知值”，不能用 &#x3D; 或 !&#x3D; 判断，必须用 IS NULL（为空）或 IS NOT NULL（非空）；\n\n应用场景：判断字段是否未填写（如管理者 ID、奖金比例），避免因 NULL 导致的筛选遗漏；\n\n注意：IFNULL(commission_pct, 0) 可将 NULL 转换为 0（如计算年薪时），但筛选时仍需用 IS NOT NULL。\n\n\n四、模糊匹配：LIKE 通配符的精准用法题目 5：选择员工姓名的第三个字母是 a 的员工姓名解决方案SELECT last_nameFROM employeesWHERE last_name LIKE &#x27;__a%&#x27;;\n\n解析\nLIKE 通配符：_ 匹配单个任意字符，% 匹配 0 个或多个任意字符；\n\n模式说明：a% 表示前两个字符任意，第三个字符为a，后续字符不限（ 对应两个位置）。\n\n\n题目 6：选择姓名中有字母 a 和 k 的员工姓名解决方案SELECT last_nameFROM employeesWHERE last_name LIKE &#x27;%a%k%&#x27; OR last_name LIKE &#x27;%k%a%&#x27;;\n\n解析\n多条件模糊匹配：需考虑两种顺序（a在前k在后或k在前a在后），用 OR 连接；\n\n注意：% 可匹配任意长度字符（包括 0），确保不遗漏包含两个字符的所有情况。\n\n\n题目 7：显示表 employees 中 first_name 以 ‘e’ 结尾的员工信息解决方案-- 方法1：使用LIKESELECT employee_id, first_name, last_nameFROM employeesWHERE first_name LIKE &#x27;%e&#x27;;-- 方法2：使用REGEXP正则（更灵活）SELECT employee_id, first_name, last_nameFROM employeesWHERE first_name REGEXP &#x27;e$&#x27;;\n\n解析\n结尾匹配：%e 表示以e结尾（LIKE），e$ 表示以e结尾（REGEXP正则）；\n\nREGEXP 优势：支持更复杂的模式（如多字符结尾），适合高级字符串匹配。\n\n\n五、区间与集合综合运用题目 8：显示表 employees 部门编号在 80-100 之间的姓名、工种解决方案SELECT last_name, job_idFROM employeesWHERE department_id BETWEEN 80 AND 100;\n\n解析\n连续区间优选 BETWEEN：BETWEEN 80 AND 100 等价于 &gt;&#x3D;80 AND &lt;&#x3D;100，代码更简洁；\n\n注意：区间包含边界值（80 和 100），若需排除边界需用 &gt; 和 &lt;。\n\n\n题目 9：显示表 employees 的 manager_id 是 100、101、110 的员工姓名、工资、管理者 id解决方案SELECT last_name, salary, manager_idFROM employeesWHERE manager_id IN (100, 101, 110);\n\n解析\n离散值集合用 IN：IN (100,101,110) 清晰表达 “属于指定集合”，比 &#x3D;100 OR &#x3D;101 OR &#x3D;110 更易读；\n\n扩展：若集合元素来自子查询，可写成 IN (SELECT …)，实现动态匹配。\n\n\n总结：运算符核心用法速查表\n\n\n运算符 &#x2F; 语法\n作用\n典型场景\n\n\n\nBETWEEN A AND B\n匹配 A 到 B 的闭区间\n工资、年龄等连续范围查询\n\n\nNOT BETWEEN\n排除 A 到 B 的区间\n反向范围筛选\n\n\nIN (值1,值2…)\n匹配离散集合中的值\n部门 ID、管理者 ID 等固定选项\n\n\nIS NULL\n判断字段为空\n查找未分配管理者、无奖金的记录\n\n\nIS NOT NULL\n判断字段非空\n查找有奖金、已填写信息的记录\n\n\nLIKE ‘%a%’\n模糊匹配包含 a 的字符串\n姓名、职位等包含特定字符的查询\n\n\nLIKE ‘__a%’\n匹配第三个字符为 a 的字符串\n固定位置字符匹配\n\n\nREGEXP ‘e$’\n正则匹配以 e 结尾的字符串\n复杂模式的字符串匹配\n\n\n通过这 9 道题，可掌握运算符在实际场景中的灵活应用。记住：优先用 IN 替代多 OR、用 BETWEEN 简化连续范围、用 IS NULL 处理空值，能让你的 SQL 更简洁高效。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 排序操作：用 ORDER BY 让查询结果更有序","url":"/2025/08/19/MySQL-%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%EF%BC%9A%E7%94%A8-ORDER-BY-%E8%AE%A9%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%9B%B4%E6%9C%89%E5%BA%8F/","content":"MySQL 排序操作：用 ORDER BY 让查询结果更有序在数据查询中，无序的结果往往难以分析 —— 比如查看员工薪资时，无序的数字无法快速找到最高或最低值。ORDER BY子句是 MySQL 中实现结果排序的核心工具，能让数据按指定规则有序展示。本文将详细讲解其用法、规则及实战技巧。\n一、排序基础：ORDER BY 的核心规则ORDER BY的作用是对查询结果按指定字段进行排序，其基本语法和核心规则如下：\n1. 基本语法结构SELECT 字段1, 字段2, ...FROM 表名[WHERE 过滤条件]  -- 可选，先筛选再排序ORDER BY 排序字段1 [ASC|DESC], 排序字段2 [ASC|DESC] ...;  -- 必须放在语句结尾\n\n2. 关键规则\n排序方向：\n\n\nASC（ascend）：升序排列（默认，可省略），即从最小值到最大值（如 1→2→3，a→b→c）；\n\n\n\nDESC（descend）：降序排列，即从最大值到最小值（如 3→2→1，c→b→a）。\n\n\n位置要求：ORDER BY必须放在SELECT语句的最后，在WHERE、FROM之后，若有LIMIT则在LIMIT之前。\n\n排序依据：可基于表中字段、计算字段（如salary*12）或别名进行排序。\n\n\n二、单列排序：按单个字段整理数据单列排序是最常用的排序方式，适用于按单一维度（如时间、价格、姓名）整理结果。\n1. 升序排序（默认 ASC）当不指定ASC或DESC时，默认按升序排列。\n示例：按员工入职时间升序排列（最早入职的在前）\nSELECT last_name, job_id, department_id, hire_dateFROM employeesORDER BY hire_date;  -- 等价于 ORDER BY hire_date ASC\n\n2. 降序排序（DESC）需显式指定DESC，适用于需要从大到小展示的场景（如薪资、销量）。\n示例：按员工入职时间降序排列（最新入职的在前）\nSELECT last_name, job_id, department_id, hire_dateFROM employeesORDER BY hire_date DESC;\n\n3. 按计算字段或别名排序排序依据可以是计算得到的字段（如年薪 &#x3D; 月薪 ×12），或字段的别名。\n示例：按员工年薪（月薪 ×12）升序排列\n-- 方法1：按计算字段排序SELECT employee_id, last_name, salary*12FROM employeesORDER BY salary*12;-- 方法2：按别名排序（更简洁，推荐）SELECT employee_id, last_name, salary*12 AS annsal  -- 别名annsal表示年薪FROM employeesORDER BY annsal;  -- 直接使用别名排序\n\n三、多列排序：按多个维度组合排序当单一字段无法满足排序需求时（如先按部门分组，再按部门内薪资排序），可使用多列排序。\n1. 基本语法与规则SELECT 字段1, 字段2, ...FROM 表名ORDER BY 字段A [DESC], 字段B [ASC];  -- 先按字段A排序，再按字段B排序\n\n核心规则：\n\n排序优先级：先按第一个字段（字段 A）排序；\n\n仅当第一个字段存在相同值时，才会按第二个字段（字段 B）排序；\n\n若第一个字段的所有值都是唯一的，第二个字段的排序规则会被忽略。\n\n\n2. 实战示例需求：查询员工信息，先按部门 ID 升序排列，同一部门内按薪资降序排列（高薪在前）。\nSELECT last_name, department_id, salaryFROM employeesORDER BY department_id ASC, salary DESC;  -- 先部门升序，再薪资降序\n\n执行逻辑：\n\n所有员工先按department_id从小到大排序（如部门 10→20→30）；\n\n对于department_id相同的员工（如都在部门 30），再按salary从大到小排序。\n\n\n3. 特殊用法：使用未查询的字段排序ORDER BY支持使用不在 SELECT 列表中的字段进行排序，不影响结果展示但需确保字段存在。\n示例：查询员工姓名和薪资，按部门 ID 升序排序（部门 ID 不显示在结果中）\nSELECT last_name, salaryFROM employeesORDER BY department_id;  -- 用未查询的department_id排序，结果仍只显示name和salary\n\n四、SQL 执行顺序：为什么 ORDER BY 要放在最后？理解 SQL 的执行顺序，能帮助你更好地掌握ORDER BY的用法：\n\n先执行FROM：确定数据来源的表；\n\n再执行WHERE：筛选出符合条件的记录；\n\n然后执行SELECT：提取需要的字段（或计算字段）；\n\n接着执行ORDER BY：对提取的结果进行排序；\n\n最后执行LIMIT（若有）：截取排序后的部分记录。\n\n\n\n关键结论：ORDER BY是对WHERE筛选后的结果进行排序，且必须放在语句最后，确保排序的是最终需要展示的数据。\n\n五、实用技巧与注意事项\n排序字段加索引：对ORDER BY的字段建立索引（如CREATE INDEX idx_hire_date ON employees(hire_date)），可大幅提升排序效率，尤其对大表查询；\n\n避免无意义排序：若结果无需有序展示（如随机取 10 条数据），可省略ORDER BY，减少数据库开销；\n\n多列排序的字段顺序：将区分度高的字段放在前面（如大多数值唯一的字段），可减少后续字段的排序压力；\n\n字符排序规则：字符串排序基于字符的 ASCII 码（如大写字母在小写字母前），若需按中文拼音排序，需确保字段编码为utf8mb4_general_ci等支持中文排序的格式。\n\n\n总结：核心要点速览\n\n\n分类\n关键内容\n示例代码\n\n\n\n基本规则\n用ORDER BY排序，ASC升序（默认），DESC降序，放在语句最后\nORDER BY salary DESC\n\n\n单列排序\n可按字段、计算字段或别名排序\nORDER BY salary*12 或 ORDER BY annsal\n\n\n多列排序\n先按第一个字段排序，相同值时再按第二个字段排序，支持未查询字段\nORDER BY department_id ASC, salary DESC\n\n\n执行顺序\n在FROM、WHERE、SELECT之后，LIMIT之前\n-\n\n\n效率建议\n排序字段加索引，避免不必要的排序，合理安排多列排序的字段顺序\n-\n\n\n掌握ORDER BY的用法，能让你的查询结果从 “杂乱无章” 变为 “井然有序”，显著提升数据可读性和分析效率。实际开发中，需根据业务场景选择合适的排序方式，并注意索引优化以应对大数据量查询。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"SQL 语言规范与基础操作指南","url":"/2025/08/16/SQL-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/","content":"SQL 语言规范与基础操作指南SQL 作为数据库操作的核心语言，遵循规范的语法和书写习惯不仅能提高代码可读性，还能减少错误。本文整理了 SQL 的基础规则、书写规范及常用操作，适合初学者快速上手。\n一、SQL 基本规则1. 书写格式\nSQL 语句可写在一行或多行，推荐各子句分行书写并适当缩进，例如：\n\nSELECT id, name FROM student WHERE age &gt; 18;\n\n\n每条命令必须使用下列其中一个用在末尾用结束语句（; 最常用）\n; \n\\g\n\\G\n\n\n\n2. 关键字与标点\n关键字（如SELECT、FROM、WHERE）不可缩写或分行，需完整书写。\n\n标点符号必须使用英文半角（如’、”、()），且需成对出现（如引号、括号不能遗漏闭合）。\n\n字符串和日期时间类型的值需用单引号（’ ‘） 包裹，例如 ‘2023-01-01’。\n\n列的别名建议用双引号（” “），且AS关键字可省略（但不建议），例如：\n\n\nSELECT id AS &quot;编号&quot;, name &quot;姓名&quot; FROM student; -- 正确\n\n二、大小写规范MySQL 的大小写敏感性与操作系统相关，遵循以下规则可避免混淆：\n\nWindows 环境：大小写不敏感（例如select和SELECT等效）。\n\nLinux 环境：大小写敏感（数据库名、表名、表别名严格区分大小写）。\n\n\n推荐书写规范：\n\n数据库名、表名、字段名、别名等全部小写（如student_info、user_id）。\n\nSQL 关键字、函数名全部大写（如SELECT、INSERT、COUNT()）。\n\n\n示例：\n-- 推荐写法SELECT id, name FROM student WHERE age &gt; 20;-- 不推荐（大小写混乱）Select ID, Name from Student where Age&gt;20;\n\n三、SQL 注释用法注释是代码的 “说明书”，SQL 支持三种注释方式：\n\n单行注释（#）：MySQL 特有的方式，#后直接写注释内容\n\n# 查询所有学生信息SELECT * FROM student;\n\n\n单行注释（– ）：通用方式，–后必须加空格\n\n-- 查询年龄大于18的学生SELECT * FROM student WHERE age &gt; 18;\n\n\n多行注释（&#x2F;* *&#x2F;）：适合大段说明\n\n/*功能：查询学生表中年龄大于20且性别为男的记录*/SELECT * FROM student WHERE age &gt; 20 AND gender = &#x27;男&#x27;;\n\n四、命名规则合理的命名是规范的核心，需注意以下几点：\n\n长度限制：数据库名、表名最多 30 个字符，变量名最多 29 个字符。\n\n允许字符：只能包含 A-Z、a-z、0-9、_（下划线），不可包含空格。\n\n唯一性：\n\n\n\n\n同一 MySQL 实例中，数据库名不可重复；\n\n\n\n同一数据库中，表名不可重复；\n\n\n\n同一表中，字段名不可重复。\n\n\n\n\n避免保留字：若字段名与关键字（如order、select）重名，需用 ** 着重号（&#96;）** 包裹：\n\n-- 正确：用`包裹关键字作为表名CREATE TABLE `order` (  id INT,  order_no VARCHAR(20));\n\n\n类型一致性：同一字段在不同表中类型需一致（如user_id在 A 表是INT，在 B 表也应是INT）。\n\n五、数据导入指令当需要批量导入数据时，可通过source命令导入 SQL 文件，步骤如下：\n\n打开命令行客户端，登录 MySQL：\n\nmysql -u 用户名 -p\n\n\n输入密码后，使用source指令导入（文件路径需用绝对路径）：\n\nsource D:\\data\\mydb.sql; -- Windows系统-- 或source /home/user/data/mydb.sql; -- Linux系统\n\n六、基础 SELECT 语句SELECT是 SQL 中最常用的查询语句，基础语法如下：\n1. 选择全部列SELECT * FROM 表名; -- 查询表中所有字段的所有记录-- 示例：查询student表所有数据SELECT * FROM student;\n\n2. 选择指定列SELECT 列1, 列2, ... FROM 表名;-- 示例：查询student表的id和name字段SELECT id, name FROM student;\n\n3. 列的别名规则\n别名无空格时，可省略双引号：\n\nSELECT id AS 编号, name 姓名 FROM student; -- 正确\n\n\n别名有空格时，必须加双引号：\n\nSELECT id AS &quot;学生编号&quot;, name &quot;学生姓名&quot; FROM student; -- 正确SELECT id AS 学生 编号; -- 错误（空格未加引号）\n\n总结遵循 SQL 规范不仅能让代码更易读、易维护，还能减少因语法问题导致的错误。核心要点包括：统一大小写、规范命名、正确使用注释、遵循标点规则。熟练掌握这些基础，能为复杂的数据库操作打下坚实基础。                                                    \n","categories":["数据库"],"tags":["MySQL"]},{"title":"SQL 概述与分类：零基础也能懂的核心知识","url":"/2025/08/14/SQL-%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%88%86%E7%B1%BB%EF%BC%9A%E9%9B%B6%E5%9F%BA%E7%A1%80%E4%B9%9F%E8%83%BD%E6%87%82%E7%9A%84%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/","content":"SQL 概述与分类：零基础也能懂的核心知识无论学习哪种数据库（MySQL、Oracle、SQL Server），SQL 都是绕不开的基础。它是操作数据库的 “通用语言”，掌握其核心概念和分类，能让你在写代码时思路更清晰。本文用最简单的语言讲解 SQL 的本质和分类，新手也能快速入门。\n一、什么是 SQL？一句话讲明白SQL（Structured Query Language，结构化查询语言）是一种专门用来操作数据库的编程语言。它的作用就像 “数据库的遥控器”—— 通过简单的命令，你可以让数据库执行 “查数据”“存数据”“建表”“改权限” 等操作。\nSQL 的 3 个核心特点：\n标准化：几乎所有数据库（MySQL、Oracle 等）都支持 SQL，学会一种，其他数据库的 SQL 用法也大同小异。\n\n非过程化：你只需要告诉数据库 “要做什么”（比如 “查所有学生的名字”），不用管 “怎么做”（数据库会自己优化执行步骤）。\n\n简单易学：基本命令都是英文单词（如SELECT“查询”、INSERT“插入”），逻辑和日常语言接近。\n\n\n二、SQL 分类：5 大类命令，各司其职根据功能不同，SQL 可以分为 5 大类。记住每类的核心命令和作用，写 SQL 时就不会 “无从下手”。\n1. 数据查询语言（DQL）：查数据的 “放大镜”作用：从数据库中查询数据（最常用的一类命令）。\n核心命令：SELECT（唯一命令，但用法灵活）。\n示例：\n-- 从student表中查询所有学生的姓名和年龄SELECT name, age FROM student;-- 查询年龄大于18的学生SELECT * FROM student WHERE age &gt; 18;\n\n2. 数据操纵语言（DML）：改数据的 “编辑工具”作用：对表中的数据进行 “增删改”（不改变表结构，只改内容）。\n核心命令：INSERT（新增）、UPDATE（修改）、DELETE（删除）。\n示例：\n-- 新增一条学生数据INSERT INTO student (name, age) VALUES (&#x27;张三&#x27;, 20);-- 修改张三的年龄为21UPDATE student SET age = 21 WHERE name = &#x27;张三&#x27;;-- 删除年龄小于18的学生DELETE FROM student WHERE age &lt; 18;\n\n3. 数据定义语言（DDL）：建结构的 “建筑师”作用：创建、修改、删除数据库或表的结构（比如建表、删库、改字段类型）。\n核心命令：CREATE（创建）、ALTER（修改）、DROP（删除）。\n示例：\n-- 创建名为school的数据库CREATE DATABASE school;-- 在school库中创建student表（包含id和name字段）CREATE TABLE student (  id INT,  name VARCHAR(20));-- 给student表增加age字段ALTER TABLE student ADD age INT;-- 删除student表（谨慎使用！数据会丢失）DROP TABLE student;\n\n4. 数据控制语言（DCL）：管权限的 “保安”作用：控制用户对数据库的操作权限（比如 “允许张三查 student 表，不允许他删表”）。\n核心命令：GRANT（授权）、REVOKE（收回权限）。\n示例：\n-- 允许用户zhangsan查询student表GRANT SELECT ON school.student TO &#x27;zhangsan&#x27;@&#x27;localhost&#x27;;-- 收回zhangsan查询student表的权限REVOKE SELECT ON school.student FROM &#x27;zhangsan&#x27;@&#x27;localhost&#x27;;\n\n5. 事务控制语言（TCL）：保安全的 “后悔药”作用：管理数据库事务（确保一组操作要么全成功，要么全失败，比如转账时 “扣钱” 和 “加钱” 必须同时成功）。\n核心命令：COMMIT（提交事务）、ROLLBACK（回滚事务，即 “撤销操作”）。\n示例：\n-- 开启事务（MySQL默认自动提交，需手动关闭）SET autocommit = 0;-- 执行转账操作（扣A的钱，加B的钱）UPDATE account SET money = money - 100 WHERE name = &#x27;A&#x27;;UPDATE account SET money = money + 100 WHERE name = &#x27;B&#x27;;-- 确认操作无误，提交事务（数据永久生效）COMMIT;-- 若操作出错，回滚事务（恢复到操作前的状态）ROLLBACK;\n\n三、总结：记分类，更要会用SQL 分类的核心是 “按功能记命令”：\n\n查数据 → 想SELECT（DQL）；\n\n改数据内容 → 想INSERT&#x2F;UPDATE&#x2F;DELETE（DML）；\n\n改表 &#x2F; 库结构 → 想CREATE&#x2F;ALTER&#x2F;DROP（DDL）；\n\n管权限 → 想GRANT&#x2F;REVOKE（DCL）；\n\n保证操作安全 → 想COMMIT&#x2F;ROLLBACK（TCL）。\n\n\n掌握这些分类，后续学习复杂 SQL 时会更有条理。下一篇我们会深入讲解最常用的 DQL（查询命令），带你搞定各种数据查询场景。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 运算符详解：逻辑、位运算与正则表达式应用","url":"/2025/08/18/MySQL-%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%80%BB%E8%BE%91%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E7%94%A8/","content":"MySQL 运算符详解：逻辑、位运算与正则表达式应用在 MySQL 中，运算符是构建复杂查询条件的基础。除了基础的算术和比较运算符，逻辑运算符、位运算符以及正则表达式的灵活运用，能让数据筛选更加精准高效。本文将系统讲解这些运算符的用法、规则及实战技巧，帮助你掌握复杂查询的核心技能。\n一、逻辑运算符：多条件组合的核心逻辑运算符用于组合多个条件，判断表达式的真假，返回结果为1（真）、0（假）或NULL（未知）。常用的有四种：\n1. 逻辑非（NOT &#x2F; !）作用：对条件结果取反\n语法：NOT 条件 或 ! 条件\n规则：\n\n条件为0（假）时返回1；\n\n条件为非0（真）时返回0；\n\n条件为NULL时返回NULL。\n\n\n示例：\n-- 查询薪资不在9000-12000之间的员工SELECT employee_id, salary FROM employees WHERE NOT (salary &gt;= 9000 AND salary &lt;= 12000);\n\n2. 逻辑与（AND &#x2F; &amp;&amp;）作用：所有条件同时为真时返回1\n语法：条件1 AND 条件2 或 条件1 &amp;&amp; 条件2\n规则：\n\n所有条件非0且非NULL时返回1；\n\n任意条件为0时返回0；\n\n存在NULL且无0时返回NULL。\n\n\n示例：\n-- 查询部门30中薪资&gt;5000的员工SELECT last_name, salary FROM employees WHERE department_id = 30 AND salary &gt; 5000;\n\n3. 逻辑或（OR &#x2F; ||）作用：任意条件为真时返回1\n语法：条件1 OR 条件2 或 条件1 || 条件2\n规则：\n\n任意条件非0时返回1；\n\n所有条件为0时返回0；\n\n存在NULL且无真条件时返回NULL。\n\n\n注意：AND优先级高于OR，建议用括号明确逻辑\n示例：\n-- 正确：查询薪资&gt;10000 或 （岗位含MAN且薪资&gt;5000）的员工SELECT last_name, job_id, salary FROM employees WHERE salary &gt; 10000 OR (job_id LIKE &#x27;%MAN%&#x27; AND salary &gt; 5000);\n\n4. 逻辑异或（XOR）作用：两个条件一真一假时返回1（“异” 即不同）\n语法：条件1 XOR 条件2\n规则：\n\n一真一假（非0和0）时返回1；\n\n同真或同假时返回0；\n\n任意条件为NULL时返回NULL。\n\n\n示例：\n-- 查询部门为10/20 或 薪资&gt;8000，但不同时满足的员工SELECT last_name, department_id, salary FROM employees WHERE department_id IN (10, 20) XOR salary &gt; 8000;\n\n二、位运算符：二进制层面的运算位运算符直接对数值的二进制位进行操作，适用于底层数据处理（如权限控制）。运算时先将数值转为二进制，计算后再转回十进制。\n\n\n\n运算符\n名称\n作用说明\n示例（6→110，3→011）\n\n\n\n&amp;\n按位与\n对应位都为 1 则返回 1，否则 0\n6 &amp; 3 &#x3D; 2（110 &amp; 011&#x3D;010）\n\n\n|\n|\n按位或\n对应位有一个为 1 则返回 1，否则 0\n\n\n^\n按位异或\n对应位不同则返回 1，相同则 0\n6 ^ 3 &#x3D; 5（110 ^ 011&#x3D;101）\n\n\n~\n按位取反\n0→1，1→0（结果为原数的补码）\n~6 &#x3D; -7（补码运算）\n\n\n&gt;&gt;\n按位右移\n二进制位右移指定位数，高位补 0\n6 &gt;&gt; 1 &#x3D; 3（110→11）\n\n\n&lt;&lt;\n按位左移\n二进制位左移指定位数，低位补 0\n6 &lt;&lt; 1 &#x3D; 12（110→1100）\n\n\n示例：\n-- 判断权限位是否包含某角色（假设8对应二进制1000，代表管理员权限）SELECT user_id, role_bits FROM users WHERE (role_bits &amp; 8) = 8;  -- 结果为8表示包含管理员权限\n\n三、运算符优先级：避免逻辑混乱运算符优先级决定计算顺序，优先级高的先执行。记不清时，用括号**()**强制指定顺序（推荐）。\n优先级从高到低（核心）：\n\n括号()（最高）\n\n位运算符（~、&lt;&lt;、&gt;&gt;、&amp;、^、|）\n\n算术运算符（*、&#x2F;、% 高于 +、-）\n\n比较运算符（&#x3D;、&gt;、BETWEEN、IN等）\n\n逻辑运算符（NOT &gt; AND &gt; OR、XOR）\n\n赋值运算符（&#x3D;，最低）\n\n\n示例：\n-- 错误：因AND优先级高，可能不符合预期SELECT * FROM employees WHERE salary&gt;5000 OR salary&lt;3000 AND department_id=30;-- 正确：用括号明确先算OR的两边SELECT * FROM employees WHERE (salary&gt;5000 OR salary&lt;3000) AND department_id=30;\n\n四、正则表达式：复杂字符串匹配REGEXP支持灵活的字符串模式匹配，比LIKE更适合复杂场景。常用匹配规则如下：\n\n\n\n模式符号\n作用\n示例\n\n\n\n^\n匹配开头\n‘^b’ 匹配以 b 开头的字符串\n\n\n$\n匹配结尾\n‘y$’ 匹配以 y 结尾的字符串\n\n\n.\n匹配任意单个字符\n‘a.g’ 匹配 a 和 g 之间有一个任意字符\n\n\n*\n匹配前面字符 0 次或多次\n‘ba*’ 匹配 b 后接 0 个或多个 a（b、ba 等）\n\n\n+\n匹配前面字符至少 1 次\n‘ba+’ 匹配 b 后接 1 个或多个 a（ba、baa）\n\n\n&#96;\n&#96;\n匹配多个选项之一\n\n\n[]\n匹配括号内任意单个字符\n‘[ot]’ 匹配 o 或 t\n\n\n[^]\n匹配括号外任意字符\n‘[^0-9]’ 匹配非数字字符\n\n\n{n,}\n匹配前面字符至少 n 次\n‘x{2,}’ 匹配 x 至少出现 2 次\n\n\n{n,m}\n匹配前面字符 n 到 m 次\n‘ba{1,3}’ 匹配 ba、baa、baaa\n\n\n示例：\n-- 1. 匹配以b开头且后面有至少1个a的字符串SELECT f_name FROM fruits WHERE f_name REGEXP &#x27;^ba+&#x27;;-- 2. 匹配包含on或ap的字符串SELECT f_name FROM fruits WHERE f_name REGEXP &#x27;on|ap&#x27;;-- 3. 匹配x连续出现至少2次的字符串SELECT f_name FROM fruits WHERE f_name REGEXP &#x27;x&#123;2,&#125;&#x27;;\n\n与 LIKE 的区别：\n\nREGEXP匹配字符串中任意位置的模式（如’bon’ REGEXP ‘on’返回 1）；\n\nLIKE需用通配符才能匹配中间内容（如’bon’ LIKE ‘%on%’才返回 1）。\n\n\n五、总结：核心要点速览\n逻辑运算符：\n\n\n\nNOT取反，AND需全真，OR需一真，XOR需一真一假；\n\n\n\n注意AND优先级高于OR，用括号明确逻辑。\n\n\n\n\n位运算符：\n\n\n\n对二进制位操作，适用于权限控制等底层场景；\n\n\n\n常用&amp;（判断位是否为 1）、&lt;&lt;&#x2F;&gt;&gt;（移位运算）。\n\n\n\n\n优先级：\n\n\n\n括号最高，赋值最低；不确定时用括号强制顺序。\n\n\n\n\n正则表达式：\n\n\n\nREGEXP支持复杂模式匹配，灵活度远超LIKE；\n\n\n\n掌握^&#x2F;$&#x2F;[]&#x2F;{}等符号，可应对多数字符串筛选需求。\n\n\n\n熟练运用这些运算符，能让你在处理多条件查询和复杂字符串匹配时更加得心应手，写出高效、精准的 SQL 语句。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"Windows 端口占用解决指南：如何找到并杀死占用端口的进程","url":"/2026/01/07/Windows%20%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E6%8C%87%E5%8D%97%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%B9%B6%E6%9D%80%E6%AD%BB%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B/","content":"Windows 端口占用解决指南：如何找到并杀死占用端口的进程在使用开发工具或运行服务器时，你可能遇到过这样的错误：”Port 4000 has been used”（端口 4000 已被占用）。这意味着该端口已被其他程序占用，导致你的服务无法正常启动。本文将详细介绍如何在 Windows 系统中找到并杀死占用特定端口的进程。\n一、问题现象当你尝试启动服务（如 Hexo 本地服务器）时，可能会看到类似以下错误：\nFATAL Port 4000 has been used. Try other port instead.Error: listen EADDRINUSE: address already in use :::4000\n\n这表明端口 4000 已被其他进程占用，你需要找到并终止该进程，或者使用其他端口（如 hexo s -p 4001）。\n二、解决方法方法一：使用命令行解决（推荐）这是最常用、最有效的方法，适用于所有 Windows 版本。\n步骤 1：打开命令提示符按下 Win + R 键，输入 cmd，然后按下 Enter 键，打开命令提示符窗口。\n步骤 2：查找占用端口的进程输入以下命令，替换 4000 为你要查询的端口号：\nnetstat -ano | findstr :4000\n\n注意：命令中 : 和端口号之间不能有空格！\n执行命令后，你会看到类似以下输出：\nTCP    0.0.0.0:4000           0.0.0.0:0              LISTENING       51160TCP    [::]:4000              [::]:0                 LISTENING       51160\n\n最后一列的数字 51160 就是占用该端口的进程 ID（PID）。\n步骤 3：查看进程信息（可选）如果你想知道这个进程是什么程序，可以输入以下命令，替换 51160 为你的进程 ID：\ntasklist | findstr 51160\n\n执行命令后，你会看到类似以下输出：\nnode.exe                     51160 Console                    1    123,456 K\n\n这表明是 node.exe 进程占用了端口 4000，通常是 Node.js 应用程序。\n步骤 4：杀死占用端口的进程输入以下命令，替换 51160 为你的进程 ID：\ntaskkill /PID 51160 /F\n\n\n/PID：指定进程 ID\n/F：强制终止进程\n\n执行命令后，你会看到类似以下输出：\n成功: 已终止 PID 为 51160 的进程。\n\n现在端口 4000 已经被释放，你可以重新启动你的服务了。\n方法二：使用任务管理器解决如果你不喜欢使用命令行，也可以通过任务管理器来解决。\n步骤 1：打开任务管理器按下 Ctrl + Shift + Esc 键，打开任务管理器。\n步骤 2：显示 PID 列点击任务管理器顶部的 详细信息 选项卡，然后点击 视图 → 选择列，勾选 PID (进程标识符)，然后点击 确定。\n步骤 3：找到并终止进程在详细信息列表中，找到你通过命令行获取到的进程 ID，右键点击该进程，然后选择 结束任务。\n三、常见问题问题 1：命令执行失败如果执行 netstat -ano | findstr :4000 命令时出现以下错误：\nFINDSTR: 无法打开 4000\n\n这是因为你在 : 和端口号之间添加了空格！正确的命令是 netstat -ano | findstr :4000（注意 : 和 4000 之间没有空格）。\n问题 2：没有权限终止进程如果执行 taskkill /PID 51160 /F 命令时出现权限不足的错误，可以尝试以管理员身份运行命令提示符：\n\n按下 Win + X 键，选择 Windows PowerShell (管理员)\n在管理员权限的命令提示符中重新执行命令\n\n四、预防措施\n使用固定端口：为不同的服务分配固定的端口，避免端口冲突\n正确关闭服务：使用 Ctrl + C 等正确方式关闭服务，避免进程异常退出\n定期清理进程：定期检查并关闭不需要的进程\n使用端口管理工具：可以使用一些端口管理工具，如 TCPView，更方便地管理端口\n\n五、总结遇到端口占用问题时，使用命令行方法是最快捷、最有效的解决方式。只需要简单的几个步骤，就能找到并杀死占用端口的进程：\n\nnetstat -ano | findstr :端口号 - 查找占用端口的进程 ID\ntaskkill /PID 进程ID /F - 强制终止该进程\n\n希望本文能帮助你解决 Windows 端口占用问题，让你的开发工作更加顺畅！\n","categories":["计算机"],"tags":["Windows","命令行","端口管理"]},{"title":"从 MySQL 5.7 迁移到 8.0：别让 SQL 文件 “坑” 了你","url":"/2025/08/16/%E4%BB%8E-MySQL-5-7-%E8%BF%81%E7%A7%BB%E5%88%B0-8-0%EF%BC%9A%E5%88%AB%E8%AE%A9-SQL-%E6%96%87%E4%BB%B6-%E2%80%9C%E5%9D%91%E2%80%9D-%E4%BA%86%E4%BD%A0/","content":"从 MySQL 5.7 迁移到 8.0：别让 SQL 文件 “坑” 了你最近处理了一个 MySQL 迁移的棘手问题：把 5.7 环境的数据库打包成 SQL 文件，直接在 8.0 里恢复后，各种报错接踵而至 —— 系统表引擎异常、密码修改失败、甚至服务启动崩溃。其实这类问题很常见，核心原因在于5.7 和 8.0 的底层设计差异，直接 “照搬” 数据很容易踩坑。今天就聊聊如何正确迁移，以及出问题后该怎么补救。\n一、为什么 5.7 的 SQL 文件在 8.0 里会 “水土不服”？很多人觉得 “都是 MySQL，备份恢复一下就行”，但 5.7 到 8.0 的变化远超想象，直接恢复 SQL 文件可能触发一系列连锁反应：\n1. 引擎规则 “红线” 被触碰5.7 中用户表默认引擎可能是 MyISAM（取决于配置），而 8.0 默认是 InnoDB。如果 SQL 文件里显式写了ENGINE&#x3D;MyISAM，恢复到 8.0 后：\n\n普通用户表可以用 MyISAM（8.0 仍支持，但不推荐）；\n\n但如果误操作涉及系统表（如mysql.db），就会触发Storage engine ‘MyISAM’ does not support system tables错误 —— 因为 8.0 强制要求系统表必须用 InnoDB。\n\n\n2. 系统表结构 “暗改” 了5.7 和 8.0 的系统表（存储用户、权限的核心表）长得不一样：\n\n5.7 的mysql.user表有password字段，8.0 早就改成了authentication_string；\n\n权限相关的mysql.db表，字段数量和含义都有变化（比如新增了部分权限枚举值）。\n\n\n如果你的 SQL 文件里不小心包含了mysql系统库的表（比如用–all-databases导出），恢复后会直接 “污染” 8.0 的系统表，导致权限加载失败。\n3. 语法 “过期” 引发隐性错误8.0 废弃了一些 5.7 的语法，比如：\n\n密码函数PASSWORD()在 8.0 里不能用了；\n\n某些索引类型和表选项（如ENGINE&#x3D;MyISAM的分区表）兼容性下降。\n\n\n这些语法在恢复时可能不直接报错，但会导致后续操作（如修改密码、授权）出现奇怪的失败。\n二、正确迁移姿势：只搬 “该搬的东西”迁移的核心原则：只迁移业务数据，远离系统库，兼容新规则。分四步走，稳如老狗：\n步骤 1：导出 5.7 数据时 “精准定位”用mysqldump导出时，只打包自己的业务库（比如mydb），坚决排除系统库：\n# 在5.7环境执行，只导出业务库mysqldump -u root -p --databases mydb --skip-lock-tables --default-character-set=utf8mb4 &gt; mydb_backup.sql\n\n⚠️ 千万别用–all-databases！会把mysql、information_schema这些系统库也导出来，堪称 “定时炸弹”。\n步骤 2：编辑 SQL 文件，“过滤” 不兼容内容用记事本或 VS Code 打开mydb_backup.sql，做三件事：\n\n删掉所有ENGINE&#x3D;MyISAM，要么改成ENGINE&#x3D;InnoDB，要么直接删掉（让 8.0 用默认引擎）；\n\n搜索并删除涉及mysql库的操作（比如USE mysql;、CREATE TABLE mysql.xxx）；\n\n把PASSWORD(‘密码’)改成直接写密码（如’123456’），8.0 会自动用新加密方式。\n\n\n步骤 3：在 8.0 里 “干净” 恢复先在 8.0 里创建空库，再恢复数据，最后用官方工具修复兼容性：\n# 1. 登录8.0，创建业务库mysql -u root -pCREATE DATABASE IF NOT EXISTS mydb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;exit# 2. 恢复数据mysql -u root -p mydb &lt; mydb_backup.sql# 快捷方式（新建了一个数据库名为mydb_backup，数据一并放入库中）mysql -u root -p  &lt; mydb_backup.sql# 3. 关键：执行8.0兼容性修复（自动处理表结构差异）mysql_upgrade -u root -p\n\n步骤 4：验证迁移结果恢复后登录 8.0，检查两个关键点：\n-- 1. 业务表引擎是否正确（推荐InnoDB）USE mydb;SHOW TABLE STATUS;  -- 看Engine列，尽量都是InnoDB-- 2. 系统表是否“纯净”（必须全是InnoDB）USE mysql;SHOW TABLE STATUS LIKE &#x27;db&#x27;;  -- Engine必须是InnoDB，否则有问题\n\n三、已经 “踩坑” 了？这样补救如果已经直接恢复了包含系统库的 SQL 文件，导致系统表异常，按以下步骤救场：\n1. 先修复系统表按之前提到的方法，把mysql.db、mysql.user等系统表转回 InnoDB 并重建结构：\n# 以跳过权限模式启动8.0（窗口保持打开）mysqld --console --skip-grant-tables --shared-memory# 新窗口登录，修复引擎mysql -u root --protocol=memoryuse mysql;ALTER TABLE db ENGINE=InnoDB;ALTER TABLE user ENGINE=InnoDB;FLUSH PRIVILEGES;\n\n2. 重新迁移业务数据\n先删除 8.0 中已恢复的业务库：DROP DATABASE mydb;；\n\n按 “正确迁移步骤” 重新导出、编辑、恢复数据；\n\n执行mysql_upgrade确保兼容性。\n\n\n总结从 MySQL 5.7 迁移到 8.0，不是简单的 “复制粘贴”。核心是要明白：两个版本的系统表和规则已经不同，迁移时必须 “划清界限”—— 只搬业务数据，让 8.0 的系统表保持原生状态。\n记住这三句话：\n\n导出时，只导业务库，不碰系统表；\n\n恢复前，编辑 SQL，删兼容问题；\n\n恢复后，用mysql_upgrade，扫尾保平安。\n\n\n按这个思路操作，迁移过程会顺畅很多，少走很多弯路。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"Hello World","url":"/2025/07/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["教程","Markdown"]},{"title":"内外兼备的得分后卫都在用!1.5motion新单动投篮","url":"/2025/07/19/%E5%86%85%E5%A4%96%E5%85%BC%E5%A4%87%E7%9A%84%E5%BE%97%E5%88%86%E5%90%8E%E5%8D%AB%E9%83%BD%E5%9C%A8%E7%94%A8!1.5motion%E6%96%B0%E5%8D%95%E5%8A%A8%E6%8A%95%E7%AF%AE/","content":"\n  07d75588653f466133359cc81f040bdca149eb2c8a6a948edae6aba795de1e0b5f54d40d8f7f84ec9f7924324909bfb4bd9e25af18d95f677813bfbae78d91f29a7ac58ca9f19cf806b51ed3e4c5d7f584ee9a6e96d8874705bc1a8ca96f277e8c004c434e3e81d9ece06c38085b4696a0c6d6655230e2b00c94f6602db684755dd6d5e77b7981d70dbe7844cff388078648c5355ccb1550e008d9f110245122731892e76f5c5f325aeeeceba16f00aae827eafca0ab1f0a3c5864c69d92996cccc6705ef372cb80742b60c5b073ca83406a87f15dd5a3e911ddd861d47e1766a062c9945557d2de993ff454acfb776b4c66810a0a8ceb9d580adc98b92ed75f6ee7c48751d0123279039f0360e028fcb7880b082033af829abfd89922659c55517bb3c40e2f0eadd94c80c1163dc62e01c099b130f4de37ecce3c3d3e951d8ea5b4dfd8eaf3f1c6de39e6b082bdf6e085ce69bc072eb88fb18726f3e752e510365ff488a25b87839bf55f684f1e844088a6dcec50c6843a68ac687f65af10c785e30d6cc9a061c3e61eafaa1ae66b0f7c9b1cdba18618e2287974a8bea7a6b1b2898f5e3ecd6041d4736fe30974b5a23713cf0e5d5ea52b14e84793016c2d49f98b8c7db8f27a5ec38366c710b7ec078899208e456db34842ef33d01aaf4ced03feab911264c10e3b1f363172efa0f6ea67d9f3e0c87021ec6973175f924697beb780a63a7500b69d868444015e871d1ff4b79af292645a867147675c4c329b2c629d86d1e3c8f0dd0aa69fb91174b19c1af3d21270dd64f10622166c5d2247b627c41f6893a931e8e8f4d894809e6a91b2c9e41630f9766b2b0a0677490ba75afdae880e3c85f036086a6125fc155e55d5074573421bc167d4ddd1c694f43868dde637daa5e8750a622ac66ccf26e1acab43bbb6461b6ec98ca5b264e8e4c7078d7bd80d718ebb94b9f31120fca2ea459b994dff46404a09b011eca11dc0edbf5f6197e08bb8f9ec7a8acce4582c2d73ea27e73e0c37b467541f0e458a7583b8828cd855ba1396e05cb5e1a639e7b2439d4ea821f921013753b3672030e93f62d3f7a0192e2c997ea41027b9285bac5ae9e80a72129971d127f7485d69c5193173e0496a3620db1a9eac563bb26cb18a2e593be049b3dd074d29187d22de6d88335a069a9d070e803fb1bf2ff9386bca6819b294bc080c924f27008c2ce3287f175e1b6688468ecf28fc4b1f8a00a976deccf839c932e8df3532dd8fca83638432fbdc5866f22ead6591d3c1ddb3a54c7e658fcfbd65fd1e752c1188485ce50133308f552e54264a5a2e1499c33ba0921b9b707c9fae31515c200e5cc66537b275ecc0fb8f4cd2b5e61f46672507385bfde993d76b43f1b6774fd669695782468e7ab818ca749699db0ac370229db5d457e5e42ab1c0f4b14ab8824416bcaec958d4747cb8a57de3ae965ca6669d94ec39216ddc246565ceb6c4b405ab8ad7b04377c249a2aca6c5826b6e54c1d4a5c5ce1ff53a5eedeb3854d7c2eb3ccc0798ca212fccc19d0af6b82a59ee1d0ab3c7a6739abdcc62b8c231bd772b0fb05fb1e93964d21543d825872022347703b51899f890b80c1894cf0199da66a386b708a1f3ee594b491261e1aec8817e654680a0de1f6443a3f4b07438da0a4a0cbeb9999fe928d375bf2304d96f1a2a62c7f3b4c88df430a290462143812c7ebbd22df383beb2e9e025d7f2746a3b0e281e450ee21c6c8415f7e0c7c76a11192cd800850dc1441e1815209b1250769f51fb4013675dcdb98123987ea3a6cdb6405a24e25f3b4c2dfc42b7d3c1aa8f5155337403cc01e0b2265e55fdff21f51368a5dd142d5bc492f44bbf7b916a3e14c3e2c82cf20405244976663153843bfa93083736a66ff928e518c01ca416d2a7483b5253eafe98211180c772fcb7e517770824184dddb145cd34f2cbb66db8a66d5e4346225d3bbbbcc4d936c0e39fc6f6facbff7fb5e6bb9dcd52a5bb1baf47c68392615a6fa822846671f203a99ef9697fcd4110a7467ddbc8c5dc8945bdb23001cd6df40e86178c3e7325d2ac03e6623f08419fbbd96f721d1adf6b046712c80ef05df4f699971bbcae67e1b2037ae99c50c9b3cc93234d28b640027264b389d7b936deff9a60de93b595f54b63ad27ec286701dec855812468107a2b399cf5467d7fd4c291b8cbc82345b1c4888af04c325cdd6b525a3b73ec243889ce28c966e4ac96117f5c11ecb4ab0e2ffe598496e923305cc49a5873edc5f57a59eff492b97ad66f1bab5632e558438ca72ed6f1ed3e5a5a994b382188c43b481b9af58973cc3c5bb1f115d2d83274d55e4da5be3dec7009f6e86494f8ac672d7d7e169978176b241d8ca7078a827d849cc17692f1fe8a31b89c524128143f54f72b0a556dbdaf5f21ac49e07771d30b94ea02f8a9548b3ecc6f3632f6c568e04bdb4fd69af0a1d327f48992dbc4c203383fe8d35771f81955b4727db82c097c6ef17e00a7496c5e13c026b10d6ab72d0aa6ab8f6cd5904b4b2c73fd5c7ab56330a584c317b9d4f3641fd80b6d57468b94fbe4fbcefc13b265049fc32a97d2854721ec7df116f794abf18c3bc964ac4692399046b96c94f91d7aa721c21eea33981a46834c18934c498c8929bbcf02fbdcd3acc8da59bf6724cd587cead7ce9c9c03230d730d560f6080ec13a3445448b96716c310b442e4bf18a52a78ec4f7904dd3a85c55e40088af46a5b6665aaa75b74db182b17b0d84f28844307997a2c22f1d3fb5f80db04207b30993b66f35f953246a5d3834b0f2b350f8425566425416c870c16b4413ca57a5fb120c2454f7c526953b87d7054fae67bf25290bb464e72cb56e4d759b5bd4ae0151597a1a5bf5bd54fa5b86f2f56e9eec981dc185dfcd3ce8c3e157bff74503fca03ca5f2fc6719d8e930b2901a64f6fc6e992ded5c59281bf9a707197452ff0b4a15a0aa20a7d741a88592119fda7aa664bc1cee63b55fc2fbe8d217156ed76cfd6eaa8a283cc1c7d8c2b385ac07fca594df14625d123b30e4a1d02c308c1a06d35d12397fe4ed97f284229f6e6dff615dca7cef3e8f653a2bbabcd4e5ed576323545c48d1f8e42d80e413c245952cc6a7b524209d42ad4784c0a56d3dceebed29f217cea9ae140e4b262686ba49dceac92c2f82aa9606e6122e4dc002e1a2a8b999b16659a376af201fefb90ba3f30006a682c41fdd3486887273154ffe6d759ac85ba26d80d3b7beafd18b94a807466a8f297e74156982813ff37b1ea371284986d0765b65f16ae474af8e738e64127aec2f8f63d638f29cd033081db8ef098bef10762689b00ca387e7c553422a72deaee3101e11c575e50f66e029bbbf50cddf26cfdd0b900ebc4f746f95500761069aa2bfad1a14b4eeb8bf6efcd0a1d68bdfd33be43aea25e384d6cfcaa0d02d590b58d2872220d9ffc1fc97f0c07c2b924d313879bc4d724cfcc8f5985169609a3e7e1af293e86db0884da9166982f59cd9ac8744aa2d3d6165e704147b3c8edfd27bfe5c311053ddb5f65803fdf52300b1b2eb6d9cd3a10f96ee5480e52c4e60e5cf1421f85f4d94f41a4545c077d2743af82fdf71c25ea2aa4fbdcc02b56cb5852fe6688a9e8a7882b5a61004c95e35c31fe7d763fc6ac1ad4bf5e37ada7664b2013f78b8b0393a33f1635a35d771f349e76de332340b82f85528fcc98d05fa1bbb05b37d6f038073925e997d9d7bdb6d42a1138a3285585ecfa47dcf6a1f02f237df3fb0d77bd3eaa7c73e363281c094a9ed06e7825b8250ca913267a9cf48dc05b7ce5879cede4af736b5a54305c4e600a5794e04ba44869aa0479788b473e3e64e278a2c0c9f5d20537884ef138167b4203e345c0e9491e98a3030624fc43b20c602f60d0e1b0f4a640d21b37f851eb358a96931419ab3224f20e64ac5448a3a25b20597251e1e73b6305ed247bbbda5ce3a843a0b06255c3466fabeaa3340621ab11a1f2df4c0aa38a8eae440894eaf872274b9ff235cce7e818a7525447630df7233a96022ea0ae8d595c6e8706bcb6c71077f8f62a05ac956af9818d70a20f65089f779586e20f4793b5026328a814f582ccf59c3168bf5318d3a43eaea8bb27430fd9fa135017b5fe445318db7f8010366ea1f8b9690973002aceb38efc437884f79232799ef3f4ffe7d5caf5a8e8cbd1d99a74f8ebe44f1ba11d0479285b7c7f19ac7e24cd5a6e503e701c6886f926943d17c168d5dafa4818bd75f112ff80c21f3a3518870a251451443ae0e8ea8babc07ef9b1f01dbe6ae5d41eaa9a0a04af9163b01ead6b7d371cfedfa5d5b5deb0ba8923e9aff04ca008bd8636c2274af78762c4ebda39f7805bce6f0d9a3875efc3f7b694230246758c2675c72bc7f0821c878db29e83596a88a2f555e54e29c12583f2a6af6203bc14fb9b13526117a2d01e5f1b0202073ffe583f6fa48d570ee843ab9dd56b93abdaf5dec98f7b42171d72a97d3c5f7c4731ddf7e4761537b7475bdde04d673a50d23e0d32fbe50ab58621013d7e93e98c30dedc8b7f659d30a45a14169b2c5317760068ad3c727652b58d300383ad60a5e94930ceaeddaef50697ed3a9d8ce77c037966ca29bac891c41e78cf28cb06631e567e7b82af608e2cb6ecf5424559df989745340f4238d5b6f33093a1b952f2460d6e3e67563cfea09afe9f6a711164c406e759c7f74b48bbb1858d8180602c3f011a8cf4115d8b253d89d2719a4f67f6cc75c3b005bbefb8eed70639eb6cb25e01c3ce7eee2fbf149422b7bf5ce078164cbd1f2f5406e3628db180c99d2866f35630fa4b4288c3cfa1474241d4cd370c6f74331fb773987f405309615d5fd5525ec49d0d53674237431d709de2751126ef62d678dfed6a2930d19c4b6b9ecc0c2d7c879313ed9d6a054338dacc99ec509de00a60bf340fa026475642c0ceb11389cea96485a797697097a1a1ebf7b5416fafbac2841bc85c1be29f7e8464112579995b3119a03a1ea9b8840710b2b43f9433b894488788ad15dd5ad7c9ee87b3345dc3cd62026d93ebbb382ce861257da8ec93ccd192080dd78d893786774e178ad73fe9afa2e565b3128fdfb52976e439e1aba886e65dc76d5fe472b971666d12864dc53e12dcc4fa4c662c4051550fec96d0d541494f5d7bbe116141c2fb46a163d08591c80da84cac265af15021727791f4c439126137f9a8202a238f24f1994ced2bb2a379cc535f1f4a96cf865749dc1eece055c7936585c969b687c0a2140dd48cd2fff8fae9aa4ece0c6c402f4e5cf3d6febe5478387a1b8c5851d4521cb1b41175f86f71b7784f9e81e1f3fcd35277539cce76123f06ff2ff4c0d3cd46b02a3f4cba3e79abca6d873abd8f4b70a75e6abd07217717859ca99487169ddc173fe3cb4a766e8d6ee7cf3670535c48ca95f060d6f60e98d79527b36c6a87a693e55e4622e145d0b2782bc5b1a498e10be05ad1b593fa0831a1f2600970b2e976dc8f0543da6b377cf24c389c50333781edea7af72b87edea9ec78802e9b880f62f62cb8bdd382c3f91d33379a3f316faaf98adb06b441ce226ef30df2dad5f92bc9e7f487544a70124758134ccb3bc9631c566d8bacf8ee1ec650e6f83102642cbf76ecd06568ed0d8cdd507d0df9c8d9428baa16b22583835fb9eafde341bc7f095065267b94fbb1c95db546672a4aefd15fcacad74d89c621b81c99551020435ae76f5e7d7015c81a064aa83eede3f060b186de0248f53e546e08b96da924ef8b7b1a2782a8e83e72020a31297abf127b1a7aaea4b3aaac00fae6368dffd4a412680fd4c0867dbc6df51a4a393451c97cc05b6255da53cfe04cc79a20b1aed2c823804903e8aeaa6a1e2c6941b7d8901156bc52d115b00bd3e8c8e8d0e7790e997bb39a342083dfe7bd4aeecdbc80d3678513542d8e34a34dc6a362f62a28a40be7e42b9f6c583608e2fcd52522ea520661b3351b485a999e04a9909320b0d354fcde1b90f1ee507054d3b6103affeeccccdda6ddfb873f4e1d60c9c2de947a251403f12f5d63d0de0d5e5ca3863ec8e183ad81944eff2fcfe6e3ac7f5290679320c272c91ae19bfb195bf11a7e63ef7f4ba57a62bc22dc50a95da30a9b2b58a37c0a976d31177930f24e87900028bbd429e69e5d7facd464a9e20fce3952006a0845d20ebce40d3c521f84edf1138eac776de9ef0554ca71a19078cdcc9b50caf0983cca46878ecee9b9867f9d5df3d70ab7a6c42b0bd3469e95210bf3e37ad5a561277570ac2cd51099a5e2d5117b239ae156ef4c0700ab3df4b10e5f13c95a0acf5c1c2e1e14e3764f1fa0b06a99aadfeee98fde122c458585bc395727a285fe6c17c20fdfca01b324c5ec74e96c73022644e92340ca296daf2fb9f92a01759e2272f50177d61f593ea08aa4b5c8c3b5d364512fc8a2f8913c2d4c17d45a8f624df2645be54006be48457e8c7232443094c2c9b7dd968ddfcca577e889fa9ceb8f552776729cc42d7a0c108c0f2ce16f7bd25a0e2081faf62715c0eb614144e8c3eb437288c41e211a782486114d15571c5063ac1a1785dda16029b8bef17df8b0da4962d95865175b8b57261220f94be776a1024fbee926126445069850b442526b87721ff859cbe0c2bc4f4f3b658e4ad82458bdcd9c4ccb565734b4227f2777b5350227e3d5c6caa61cf18b64445dc81d31967906b62998398a4e9876722a037a0837dd4d702b3160febb5dfc8ac2a6d77b868b611f2fcc7e08f9d4512f2c94b00fced7112ecac4fe29ea6d78e2915796d7bc0c68b89b344d46a124eb3eee554dba3893e0968032be8dd0d39f7e0f8a3189ad6d21e07cbf86852760bdac34a0bcba32b7318b99e574a03e1a6690b98f4665ea3f813af3f3c233872a866cf4d5cbfb99a89afee40dd33d6e00c782c69914c86b6545976895b01a009b2039ccce7f193d5d026970c802dc5d86b24c7ef5028b4847bc261d39265a4451c5c2ae28814ffe55bfcfd500eb2a00b6bad1d4d3265beda1de0285af6f52da034ad47123b66f7e66e73c913b85fcb9b8608119e4e77ffddc6e2b498e5abb7c4bdb554b1998056f52dc3e195ca7fc82f28d443059770094d5496b7baa5ce7081c5c3fa4b240098a875da08496c5047327139cc0b02668b8e3c0ec3b2b73217fdee83f39dfe21c8a8b41ab5ceb94286892d296c9411eec7d02e4dc68b9f1c1f937fcff26e5b4d09448f4fbba618fc757fa7f98cb596c8470a157f093d9618198a349c81ca224f4592f817c99c2c8560b55be61984ccdd6172007926fccdf3fdb6c3521a10e4f7b0481777aaf461610658c0865c3d04046fc4873fee218d0787380f21c13dce47e18b8b9ff3669219413577ddb8a5700e1173accac870c40aa7e9a9da84ea51d6091006dbab33430ad400b3050e8fd3e889d08927b2ebe031be6745a6cd35dd6020ec414dd25042e326c990497359a596343209f99b8e9f5f9e332120b75a38f74a1602044c9b17c6609e8ffd807da042177bc454f6d79c860762845acf045a25a1d90bbb33b2c1a5d3ff0b74345c36428117ba01609d16542edf972ca1d2aaa3cf32d47d584694bff15cdfba6158db7fb76f2c62733e7130c7f9e14358e9a992eff5f788c94b1bc972fb5271e9c23f9b0775c009090e8c4c85153cfec949ada06c237797c3f27009db449c15ce3e601dddbd52e47931590078177dd83afc410ad23ab3662cf45cdb64fbdec42353e22be381a8c9f80ed7b9af67c3123665d5b82372f8c34fa4725bcdf931892f0c72c93a56a01d49dff2f7e46430bb59f05f4c5505a61ac719d40bff5e65ab7a71aaf1bc82f25fe5962c60700e4e5e4578d0691ef70a6ea7f0ef26a0e81f675d8fa28a2e0c645fdcd54944696c0fb59206678eda40204c1925c176c19486b36c582fa51a2c37058f5d682b07820ba6071a79e4679c4f5a5df73a0057d04b6ab026b4cd78fd5b55d73ed535037e27fcf1e478a6d6fee75ed752b8b89700ec1046f1a873c20f90b85ce3c7d2f64132f9ffd77cd854f4a1491140d50a35f4df7dda6b6e1a7720f4f7b2f31057ad99b9cb634faf2c1bc38bf17c8d66e0c9cc9824d6d392c800a13c78f74cb081c2f0645cf1bf09512a6ed054c1e14bcc23a1b495ec41a098cbcb5f54279a2161e17b05b8f65eee5f2ddfce379e13b1856805a3525217ef9738d1af278508bd1ad18ea320522a9ad5241a945c22f6606d86861ffc95232f21f5f703540705f2af2b15f7a75c11aa80eb99762aa23265e1d251bf932207e730bae4ff793fc1aa479c7a00bfd9685b91a35f4644d7bdc5dbc499551b8be6c7e86021df3708c2854e5c3b59b33b2e84903a24aebbf3baec7daae376b1682ea32408bc805577a8f89c9d7ed0f1782f3d549847ad96b4383f3efc99059ca2929db7135332914b7ce820fbe19780b3c56ca0c67d27cdb4b0550a0c1f174097354380aa0c1a1808e73028cfaf3a7fee8fe2cca26a947c686a30453f68abfe9cc211857ac157e5831915cbefcfeb9335083f81039e804fabb2cdc5526fae380bff57c5bb82e437dd6815e0fc4073f6b12fe805f05726758e10f97b3317d091f62d5ddae3068357d2f3a6a8e99787eed5b4f41617c4fe130d531d757d3973aef208bdcf783cbc38c8e978aea6ef6e2a550c7d1fa6d5e0ae9df06b8ba3132398cc639e5d5372185ea701f6444da9964adb3314c79cb71802b87b4e1da1b8f67d3f2843c15c2601f73794de55e7f1f368d7b56a8f2555936e7d51ffca21174a2253d680b7bc7bb53c3c5816e198acfc0d4f3a853d8d2bf28abd8c89f98dfd2ecd6384fe9e79a8a05cd06455c0119de2076d78ebc0d97a20eaf0bab11116c4c002700c72287aac61d0100071cdbd0e8ed1c0be6d0f4851854c3d5592b1084a27252716c3673f578cb9d1fa5263963e4368325dccca1bbdfb9f769ea0730b31f779b4321acfd5ed99\n  \n    \n      \n      \n        当前文章暂不对外可见，请输入访问密码后查看！\n      \n    \n  \n\n","categories":["篮球"],"tags":["投篮"]},{"title":"键盘灯光切换和系统切换的基本使用","url":"/2025/07/22/%E9%94%AE%E7%9B%98%E7%81%AF%E5%85%89%E5%88%87%E6%8D%A2%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%88%87%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"RK-G98 键盘灯光切换和系统切换的基本使用涵盖灯光控制、系统切换、连接方式等实用操作，、系统切换与键位适配\n1. Windows 与 Mac 模式切换\n切换至 Windows 系统：Fn + A\n\n适配 Windows 快捷键（如Win键、Ctrl+C&#x2F;V等）。\n\n切换至 Mac 系统：Fn + S\n\n适配 Mac 快捷键（如⌘键、⌥键映射等）。\n\n模式切换验证：\n\n切换后键盘指示灯会闪烁 3 次，部分功能键（如Caps Lock）逻辑会自动调整。\n2. 特殊键位互换\nCaps Lock 与左 Ctrl 互换：Fn + Caps\n\n适合习惯使用Ctrl键位于左下角的用户。\n\nWin 键屏蔽 &#x2F; 开启：Fn + Win\n\n游戏时防止误触 Win 键导致卡顿。\t\t\t\n二、灯光控制与自定义1. 基础灯光调节\n亮度调节：\n\n\n增加亮度：Fn + ↑（共 5 档，最大亮度时指示灯闪烁）。\n\n\n\n降低亮度：Fn + ↓（可关闭背光，指示灯闪烁提示最小值）。\n\n\n动态速度调节：\n\n\n减慢速度：Fn + ←（适用于跑马灯、呼吸灯等动态模式）。\n\n\n\n加快速度：Fn + →（最高速时指示灯闪烁）。\n\n\n\n2. 预设背光模式切换(有两种版本)\n全模式循环  Fn + prtsc（ps） 或者 Fn + \\| 遍历所有预设背光模式\n\n","categories":["其他"]},{"title":"在 Hexo 博客中插入图片的完整指南","url":"/2025/07/28/%E5%9C%A8-Hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","content":"在 Hexo 博客中插入图片的完整指南Hexo 是一个基于 Node.js 的静态博客生成器，因其灵活性和扩展性而广受欢迎。然而，在使用 Markdown 编写博客时，插入图片可能会遇到路径问题或格式限制。本文将详细介绍如何在 Hexo 中插入图片的多种方法\n\n一、插入图片的三种种方法方法 1：使用文章资源文件夹（推荐）Hexo 提供了一个 post_asset_folder 功能，允许为每篇文章创建独立的资源文件夹。修改 Hexo 根目录下的 _config.yml 文件：\npost_asset_folder: truemarked:  prependRoot: true  postAsset: true \n\n\n说明：此配置会为每篇新文章自动生成一个与文章同名的文件夹，用于存放图片等资源。\n\n\n创建新文章：\nhexo new &quot;你的文章标题&quot;\n\n这会在 source/_posts/ 目录下生成一个同名文件夹（如 你的文章标题）和 .md 文件。\n\n存放图片：将图片放入生成的文件夹中（例如 source/_posts/你的文章标题/）。\n\n插入图片：在 .md 文件中使用以下语法：\n![替代文字](图片名.jpg)\n\n\n提示：如果图片无法显示，检查路径是否正确（图片名.jpg&#96;）。\n\n\n\n\n方法 2：使用固定资源文件夹（最简单）\n创建统一图片文件夹：在 source/ 目录下新建一个文件夹（例如 images/），用于存放所有文章的图片。\n\n插入图片：在 .md 文件中使用以下语法：\n![替代文字](/images/图片名.jpg)\n\n\n说明：/images/ 表示从 Hexo 根目录的 source/ 文件夹开始查找图片。\n\n\n\n\n方法 3：使用网络图床（氪金玩家）如果不想将图片存储在本地，可以使用图床服务（如阿里云 OSS、GitHub Pages）：\n\n上传图片：将图片上传至图床，并获取图片的 URL（例如 https://example.com/images/图片名.jpg）。\n\n插入图片：在 .md 文件中使用以下语法：\n![替代文字](https://example.com/images/图片名.jpg)\n\n\n隐私保护建议：  \n\n避免使用第三方图床（如免费图床服务），以防图片被他人盗用或丢失。  \n推荐使用私有对象存储（如阿里云 OSS、AWS S3）或 GitHub Pages 搭建私有图床。\n\n\n\n参考链接：\n\nHexo 官方文档\nTypora 图片管理指南\nhexo-asset-img GitHub 仓库\n\n\n希望这篇指南能帮助你更好地管理 Hexo 博客中的图片资源！\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo 系列文章功能 - 组织相关内容的最佳实践","url":"/2026/01/07/Hexo%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%8A%9F%E8%83%BD-%E7%BB%84%E7%BB%87%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","content":"Hexo 系列文章功能 - 组织相关内容的最佳实践\n写了很多相关的文章，但读者不知道该按什么顺序阅读？系列文章功能帮你解决这个问题！本教程教你如何使用 Butterfly 主题的系列文章功能。\n\n📋 目录\n什么是系列文章\n为什么需要系列文章\n启用系列文章功能\n创建系列文章\n配置选项详解\n最佳实践\n总结\n\n\n什么是系列文章1. 定义系列文章（Series） 是将多篇相关文章组织在一起的功能，让读者可以按照特定顺序阅读。\n2. 展示效果启用系列文章后，在文章页面会显示：\n📚 本文属于「Hexo魔改教程」系列├── 1. Hexo 性能优化 - 代码压缩配置教程├── 2. Hexo SEO 优化 - 站点地图配置教程├── 3. Hexo 数据统计 - 百度统计与 Google Analytics 配置教程└── 4. Hexo 系列文章功能 - 组织相关内容的最佳实践 (当前)\n\n3. 功能特点✅ 自动编号：按顺序显示文章编号✅ 导航便捷：点击即可跳转到其他文章✅ 高亮当前：当前文章会特殊标记✅ 自动排序：可按标题或日期排序\n\n为什么需要系列文章1. 提升用户体验问题：\n\n读者不知道从哪篇文章开始读\n找不到系列的其他文章\n不清楚文章之间的关系\n\n解决：\n\n✅ 清晰的阅读顺序\n✅ 方便的文章导航\n✅ 完整的知识体系\n\n2. 增加页面浏览量效果：\n\n📈 读者会连续阅读系列文章\n📈 降低跳出率\n📈 增加停留时间\n📈 提升 SEO 排名\n\n3. 构建知识体系优势：\n\n📚 系统化的内容组织\n📚 循序渐进的学习路径\n📚 完整的教程体系\n📚 专业的内容呈现\n\n4. 适用场景系列文章特别适合：\n\n📖 教程系列：如「Python 入门教程」\n🔧 技术专题：如「Vue 3 实战系列」\n📝 连载小说：如「我的编程之路」\n🎯 项目实战：如「从零搭建博客系统」\n\n\n启用系列文章功能1. 打开配置文件编辑 _config.butterfly.yml 文件，找到 series 配置项：\n# 系列series:  # 是否启用系列  enable: true  # 按标题或日期排序  orderBy: &#x27;title&#x27;  # 排序方式。1, asc 为升序; -1, desc 为降序  order: 1  # 是否显示编号  number: true\n\n2. 配置说明\n\n\n参数\n说明\n可选值\n推荐值\n\n\n\nenable\n是否启用系列功能\ntrue&#x2F;false\ntrue\n\n\norderBy\n排序依据\n‘title’&#x2F;‘date’\n‘title’\n\n\norder\n排序方式\n1（升序）&#x2F;-1（降序）\n1\n\n\nnumber\n是否显示编号\ntrue&#x2F;false\ntrue\n\n\n3. 生成网站配置完成后，执行：\nhexo cleanhexo generate\n\n\n创建系列文章1. 基本用法在文章的 Front Matter 中添加 series 字段：\n---title: 文章标题date: 2026-01-07series: 系列名称---\n\n2. 示例：创建教程系列第一篇文章---title: Python 入门教程（一）：环境搭建date: 2026-01-01tags:  - Python  - 教程categories:  - 编程语言series: Python 入门教程---# Python 入门教程（一）：环境搭建本文是 Python 入门教程的第一篇...\n\n第二篇文章---title: Python 入门教程（二）：基础语法date: 2026-01-02tags:  - Python  - 教程categories:  - 编程语言series: Python 入门教程---# Python 入门教程（二）：基础语法本文是 Python 入门教程的第二篇...\n\n第三篇文章---title: Python 入门教程（三）：数据类型date: 2026-01-03tags:  - Python  - 教程categories:  - 编程语言series: Python 入门教程---# Python 入门教程（三）：数据类型本文是 Python 入门教程的第三篇...\n\n3. 排序规则按标题排序（推荐）如果 orderBy: &#39;title&#39;，文章会按标题的字母&#x2F;数字顺序排序。\n技巧：在标题中添加序号\ntitle: Python 入门教程（一）：环境搭建title: Python 入门教程（二）：基础语法title: Python 入门教程（三）：数据类型\n\n或者使用数字前缀：\ntitle: 01 - 环境搭建title: 02 - 基础语法title: 03 - 数据类型\n\n按日期排序如果 orderBy: &#39;date&#39;，文章会按发布日期排序。\n注意：确保日期设置正确\ndate: 2026-01-01  # 第一篇date: 2026-01-02  # 第二篇date: 2026-01-03  # 第三篇\n\n4. 多个系列你可以创建多个不同的系列：\n# 系列 1：Python 教程series: Python 入门教程# 系列 2：Vue 教程series: Vue 3 实战系列# 系列 3：博客搭建series: Hexo 博客搭建指南\n\n\n配置选项详解1. orderBy - 排序依据按标题排序（title）series:  orderBy: &#x27;title&#x27;\n\n优点：\n\n✅ 顺序可控（通过标题命名）\n✅ 适合教程系列\n✅ 逻辑清晰\n\n缺点：\n\n❌ 需要在标题中添加序号\n❌ 修改标题会影响排序\n\n适用场景：\n\n教程系列\n技术专题\n有明确顺序的内容\n\n按日期排序（date）series:  orderBy: &#x27;date&#x27;\n\n优点：\n\n✅ 自动按时间排序\n✅ 适合连载内容\n✅ 无需修改标题\n\n缺点：\n\n❌ 顺序由发布时间决定\n❌ 后期插入文章困难\n\n适用场景：\n\n连载小说\n日记系列\n时间线内容\n\n2. order - 排序方式升序（1）series:  order: 1\n\n效果：\n1. 第一篇2. 第二篇3. 第三篇\n\n适用：大多数情况\n降序（-1）series:  order: -1\n\n效果：\n3. 第三篇2. 第二篇1. 第一篇\n\n适用：倒序展示（如最新的在前）\n3. number - 显示编号启用编号（true）series:  number: true\n\n效果：\n📚 本文属于「Python 入门教程」系列├── 1. Python 入门教程（一）：环境搭建├── 2. Python 入门教程（二）：基础语法└── 3. Python 入门教程（三）：数据类型 (当前)\n\n禁用编号（false）series:  number: false\n\n效果：\n📚 本文属于「Python 入门教程」系列├── Python 入门教程（一）：环境搭建├── Python 入门教程（二）：基础语法└── Python 入门教程（三）：数据类型 (当前)\n\n\n最佳实践1. 命名规范系列名称推荐：\n\n✅ 简洁明了：「Python 入门教程」\n✅ 突出主题：「Vue 3 实战系列」\n✅ 统一风格：「Hexo 博客搭建指南」\n\n不推荐：\n\n❌ 太长：「从零开始学习 Python 编程语言完整教程系列」\n❌ 太模糊：「教程」\n❌ 包含特殊字符：「Python@教程#系列」\n\n文章标题推荐格式：\n系列名称（序号）：具体内容\n\n示例：\ntitle: Python 入门教程（一）：环境搭建title: Python 入门教程（二）：基础语法title: Python 入门教程（三）：数据类型\n\n或者：\n序号 - 具体内容\n\n示例：\ntitle: 01 - 环境搭建title: 02 - 基础语法title: 03 - 数据类型\n\n2. 内容组织合理的文章数量\n✅ 3-10 篇：最佳范围\n⚠️ 10-20 篇：可以接受\n❌ 20+ 篇：考虑拆分成多个系列\n\n文章长度\n每篇文章保持适中长度（1000-3000 字）\n避免单篇文章过长或过短\n保持系列内文章长度相对均衡\n\n内容连贯性\n前后文章要有逻辑关系\n避免跳跃式的内容\n适当回顾前文内容\n为后续文章做铺垫\n\n3. 导航优化在文章开头添加系列导航&gt; 本文是「Python 入门教程」系列的第二篇。&gt;&gt; 上一篇：[Python 入门教程（一）：环境搭建](/2026/01/01/python-tutorial-01/)&gt; 下一篇：[Python 入门教程（三）：数据类型](/2026/01/03/python-tutorial-03/)\n\n在文章结尾添加系列索引## 系列文章本文是「Python 入门教程」系列的一部分，完整系列包括：1. [环境搭建](/2026/01/01/python-tutorial-01/)2. [基础语法](/2026/01/02/python-tutorial-02/)（本文）3. [数据类型](/2026/01/03/python-tutorial-03/)4. [流程控制](/2026/01/04/python-tutorial-04/)5. [函数与模块](/2026/01/05/python-tutorial-05/)\n\n4. SEO 优化统一的标签和分类tags:  - Python  - 教程categories:  - 编程语言series: Python 入门教程\n\n内部链接在文章中添加指向系列其他文章的链接：\n在[上一篇文章](/2026/01/01/python-tutorial-01/)中，我们学习了如何搭建 Python 环境...关于数据类型的详细内容，我们将在[下一篇文章](/2026/01/03/python-tutorial-03/)中介绍...\n\n5. 更新维护保持更新\n定期检查系列文章的内容\n及时更新过时的信息\n补充新的知识点\n\n完整性\n确保系列文章完整\n避免留下”待续”的文章\n如果系列未完成，在首篇说明\n\n\n示例：完整的系列文章系列：Hexo 魔改教程第一篇---title: Hexo 性能优化 - 代码压缩配置教程date: 2026-01-07 18:00:00tags:  - Hexo  - 性能优化  - 教程categories:  - Hexo博客series: Hexo魔改教程---\n\n第二篇---title: Hexo SEO 优化 - 站点地图配置教程date: 2026-01-07 19:00:00tags:  - Hexo  - SEO  - 教程categories:  - Hexo博客series: Hexo魔改教程---\n\n第三篇---title: Hexo 数据统计 - 百度统计与 Google Analytics 配置教程date: 2026-01-07 20:00:00tags:  - Hexo  - 数据统计  - 教程categories:  - Hexo博客series: Hexo魔改教程---\n\n第四篇---title: Hexo 系列文章功能 - 组织相关内容的最佳实践date: 2026-01-07 21:00:00tags:  - Hexo  - Butterfly  - 教程categories:  - Hexo博客series: Hexo魔改教程---\n\n\n常见问题1. 系列文章不显示？可能原因：\n\nseries.enable 未设置为 true\n文章的 series 字段拼写错误\n缓存未清理\n\n解决方法：\n# 检查配置cat _config.butterfly.yml | grep -A 5 &quot;series:&quot;# 清理缓存hexo cleanhexo generate\n\n2. 排序不正确？原因：\n\n标题命名不规范\n日期设置错误\norderBy 配置不当\n\n解决方法：\n\n检查 orderBy 设置\n统一标题命名格式\n确保日期正确\n\n3. 如何修改系列名称？方法：\n\n批量修改所有相关文章的 series 字段\n重新生成网站\n\n技巧：使用编辑器的批量替换功能\n4. 可以一篇文章属于多个系列吗？答案：不可以。\nButterfly 主题的系列功能只支持一篇文章属于一个系列。\n替代方案：\n\n使用标签（tags）组织多个主题\n使用分类（categories）建立层级关系\n\n\n总结已实现的功能✅ 系列文章功能：将相关文章组织成系列✅ 自动编号：按顺序显示文章编号✅ 灵活排序：支持按标题或日期排序✅ 导航便捷：点击即可跳转\n使用效果通过系列文章功能，我的博客实现了：\n\n📚 内容体系化：知识结构更清晰\n📈 浏览量提升：读者连续阅读多篇文章\n⏱️ 停留时间增加：用户体验更好\n🎯 专业度提升：内容组织更专业\n\n配置要点\n启用功能：series.enable: true\n选择排序方式：按标题或日期\n统一命名规范：系列名称和文章标题\n保持内容连贯：前后文章逻辑清晰\n\n下一步优化除了系列文章，还可以：\n\n📊 添加系列进度条\n🔗 优化系列导航样式\n📱 适配移动端显示\n🎨 自定义系列卡片样式\n\n\n参考资源\nButterfly 主题文档\nHexo 官方文档\nFront Matter 配置\n\n\n结语系列文章功能是组织内容的强大工具。通过本教程，你已经学会了如何使用 Butterfly 主题的系列文章功能，可以开始创建自己的系列教程了！\n记住：好的内容组织，能让读者更容易理解和吸收知识！\n如果你有任何问题或建议，欢迎在评论区留言交流！\nHappy Blogging! 📚\n","categories":["Hexo博客"],"tags":["Hexo","Butterfly","教程"]}]