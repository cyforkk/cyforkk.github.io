[{"title":"CentOS7网络配置失败？从报错到解决的完整指南","url":"/2025/07/26/CentOS7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5%EF%BC%9F%E4%BB%8E%E6%8A%A5%E9%94%99%E5%88%B0%E8%A7%A3%E5%86%B3%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","content":"CentOS 7 网络配置失败？从报错到解决的完整指南在使用 CentOS 7 时，网络配置是日常操作的基础，但偶尔会遇到「重启网络服务失败」的问题。本文结合实际场景，详细讲解如何排查网络服务报错（Job for network.service failed），从配置文件到服务依赖，一步步定位问题并解决，适用于新手和有一定经验的用户。\n一、问题现象：网络服务重启失败执行重启网络服务的命令后，出现如下错误：\n[root@server01 ~]# systemctl restart networkJob for network.service failed because the control process exited with error code. See &quot;systemctl status network.service&quot; and &quot;journalctl -xe&quot; for details.\n\n此时网络可能完全不可用，或配置不生效。这种情况多由 配置文件错误 或 服务冲突 导致，无需慌张，按步骤排查即可解决。\n二、核心排查步骤1. 先看配置文件：语法错误是重灾区网络配置文件是最容易出错的地方，路径为：\n&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-&lt;网卡名&gt;（如 ifcfg-ens33）\n检查配置文件内容执行命令查看当前配置：\ncat /etc/sysconfig/network-scripts/ifcfg-ens33\n\n以静态 IP 配置为例，正确的格式应类似这样（关键参数已标注）：\nTYPE=Ethernet         # 网络类型：以太网BOOTPROTO=static      # 启动协议：静态IP（手动配置）NAME=ens33            # 连接名称（需与网卡名对应）DEVICE=ens33          # 网卡设备名（必须与实际网卡一致）ONBOOT=yes            # 开机自动激活网卡IPADDR=192.168.10.101 # 静态IP地址（根据实际网段修改）NETMASK=255.255.255.0 # 子网掩码（或用 PREFIX=24 表示）GATEWAY=192.168.10.2  # 网关地址（通常是路由器IP）DNS1=192.168.10.2     # DNS服务器（可填公共DNS如114.114.114.114）\n\n配置文件常见错误\n参数拼写错误：如 IPADRR（少打一个 D）、GATEWY（少打 A），这类错误会直接导致服务启动失败。\n\n网卡名不匹配：DEVICE&#x3D;ens33 需与实际网卡名一致，可通过 ip link show 查看真实网卡名（可能是 ens37 等）。\n\n重复参数：同时存在 NETMASK 和 PREFIX 且值冲突（如 NETMASK&#x3D;255.255.255.0 与 PREFIX&#x3D;23 不匹配）。\n\n多余空格：参数值前后有空格（如 IPADDR&#x3D; 192.168.10.101），会被识别为无效值。\n\n\n2. 服务冲突：NetworkManager 与 network 的 “恩怨”CentOS 7 中有两个网络管理服务：\n\nnetwork：传统网络服务，配置文件驱动。\n\nNetworkManager：现代网络管理工具，图形化界面和命令行均支持，默认启用。\n\n\n两者同时运行时可能冲突，导致 network 服务启动失败。\n检查服务状态# 查看 NetworkManager 状态systemctl status NetworkManager# 查看 network 服务状态（包含错误日志）systemctl status network -l\n\n若输出中包含 conflict（冲突）或 dependency failed（依赖失败），大概率是服务冲突导致。\n3. 特殊场景：克隆虚拟机的 “隐藏坑”如果你的系统是从其他虚拟机克隆而来，可能会遇到 网卡硬件信息冲突：\n\n克隆会复制原虚拟机的 UUID（网络连接唯一标识）和 MAC 地址，导致新系统无法识别网卡。\n\n表现为：ip addr 中看不到网卡（如 ens33 缺失），或 lspci 检测不到网络硬件。\n\n\n三、解决方案：分场景处理场景 1：配置文件错误导致的启动失败修复配置文件直接编辑配置文件，修正错误参数：\nvim /etc/sysconfig/network-scripts/ifcfg-ens33\n\n确保关键参数正确（以静态 IP 为例）：\nTYPE=EthernetBOOTPROTO=staticNAME=ens33DEVICE=ens33ONBOOT=yesIPADDR=192.168.10.101 #替换为自己的ipPREFIX=24GATEWAY=192.168.10.2 #替换为自己的网关DNS1=192.168.10.2 #替换为自己的DNS\n\n保存后重启网络服务：\nsystemctl restart network\n\n场景 2：服务冲突导致的启动失败方案 A：禁用 NetworkManager（仅用 network 服务）适合纯命令行环境，或习惯用配置文件管理网络：\n 重复上面场景一的操作（在末尾加上）\nNM_CONTROLLED=no  # 关键：禁用 NetworkManager 管理\n\n# 停止并禁用 NetworkManagersystemctl stop NetworkManagersystemctl disable NetworkManager# 启用并重启 network 服务systemctl enable networksystemctl restart network\n\n场景 3：克隆虚拟机的网卡识别问题克隆后系统未识别网卡，表现为 ip addr 中无 ens33，且 lspci | grep -i network 无输出。\n解决步骤：\n检查虚拟机网络适配器（以 VMware 为例）：\n\n关闭虚拟机 → 右键「设置」→「网络适配器」→ 确认「已连接」和「启动时连接」已勾选，网络模式选择「NAT」或「桥接」。\n\n重建网卡配置：\n\n# 删除原网卡配置文件rm -f /etc/sysconfig/network-scripts/ifcfg-ens33# 删除 udev 规则（克隆残留的硬件信息）rm -f /etc/udev/rules.d/70-persistent-net.rules# 重启系统（自动生成新配置）reboot\n\n\n重启后，用 ip link show 确认网卡已识别（如 ens33），再按场景 1 配置网络即可。\n\n四、验证网络是否正常配置完成后，通过以下命令验证：\n# 查看IP是否生效ip addr show ens33  # 应显示配置的静态IP# 查看路由是否正确（默认网关是否生效）ip route show       # 应包含 &quot;default via 网关IP dev ens33&quot;# 测试连通性ping 网关IP -c 3    # 如 ping 192.168.10.2 -c 3ping 114.114.114.114 -c 3  # 测试公网连通性\n\n若均正常，说明网络配置已生效。\n五、总结：避坑指南\n配置文件是基础：仔细检查参数拼写、网卡名匹配，避免多余空格。\n\n服务二选一：要么用 network 服务（禁用 NetworkManager），要么用 NetworkManager（禁用 network），不要同时启用。\n\n克隆虚拟机注意：必须删除原网卡配置和 udev 规则，否则会因硬件信息冲突导致网卡不识别。\n\n公共 DNS 更可靠：配置 DNS1&#x3D;114.114.114.114 或 8.8.8.8，避免依赖网关 DNS。\n\n\n通过以上步骤，90% 以上的网络服务启动失败问题都能解决。如果仍有问题，可通过 journalctl -xe | grep network 查看详细错误日志，针对性排查即可。\n","categories":["VMWare"]},{"title":"Day 1-3: Java SE核心概念复习详细可执行步骤","url":"/2025/08/21/Day-1-3-Java-SE%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%A4%8D%E4%B9%A0%E8%AF%A6%E7%BB%86%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4/","content":"Day 1-3: Java SE核心概念复习详细可执行步骤总体目标：夯实Java基础，为后续学习打下坚实基础每日学习时间：2-3小时（建议分为上午1小时理论，晚上2小时实践）学习方式：理论学习 + 代码实践 + 练习题巩固\n\nDay 1: 集合框架深度复习上午理论学习（1小时）第一步：回顾集合框架整体架构（15分钟）学习内容：\n\n 绘制集合框架继承关系图\n 理解Collection和Map两大体系\n 掌握List、Set、Queue接口的特点\n\n具体操作：\n\n打开记事本，手绘集合框架UML图\n标记每个接口和实现类的特点\n记录各个集合的使用场景\n\n检验方式：能够不看资料画出完整的集合框架图\n第二步：ArrayList vs LinkedList 原理分析（20分钟）学习内容：\n\n ArrayList底层数组实现原理\n LinkedList双向链表结构\n 时间复杂度对比分析\n 使用场景选择策略\n\n具体操作：\n\n阅读ArrayList源码中的add、get、remove方法\n分析LinkedList的Node结构和双向指针\n制作时间复杂度对比表格\n\n检验方式：能够解释为什么ArrayList查找快，LinkedList插入删除快\n第三步：HashMap深入理解（25分钟）学习内容：\n\n HashMap底层数组+链表+红黑树结构\n hash函数和扩容机制\n 解决哈希冲突的方法\n HashMap线程安全问题\n\n具体操作：\n\n画出HashMap内部结构示意图\n分析put方法的执行流程\n理解负载因子0.75的意义\n学习红黑树转换条件（链表长度&gt;8）\n\n检验方式：能够手绘HashMap结构图并解释put过程\n晚上实践编程（2小时）第一步：手写ArrayList实现（45分钟）任务目标：实现基础的动态数组功能\n// 创建文件：MyArrayList.javapublic class MyArrayList&lt;E&gt; &#123;    private Object[] elementData;    private int size;    private static final int DEFAULT_CAPACITY = 10;        // 待实现方法：    // 1. 构造函数    // 2. add(E element)    // 3. get(int index)    // 4. remove(int index)    // 5. size()    // 6. 扩容方法 grow()&#125;\n\n具体步骤：\n\n创建MyArrayList.java文件\n实现无参构造函数，初始化数组\n实现add方法，包含扩容逻辑\n实现get方法，包含边界检查\n实现remove方法，数组元素前移\n编写测试用例验证功能\n\n检验标准：\n\n 能够正确添加元素\n 自动扩容功能正常\n 能够获取和删除指定位置元素\n 边界条件处理正确\n\n第二步：手写HashMap核心功能（45分钟）任务目标：实现基础的键值对存储功能\n// 创建文件：MyHashMap.javapublic class MyHashMap&lt;K, V&gt; &#123;    private Node&lt;K, V&gt;[] table;    private int size;    private static final int DEFAULT_CAPACITY = 16;        static class Node&lt;K, V&gt; &#123;        K key;        V value;        Node&lt;K, V&gt; next;        // 构造函数    &#125;        // 待实现方法：    // 1. hash(Object key)    // 2. put(K key, V value)    // 3. get(Object key)    // 4. resize()&#125;\n\n具体步骤：\n\n定义Node内部类表示键值对节点\n实现简单的hash函数\n实现put方法，处理哈希冲突（链表法）\n实现get方法，遍历链表查找\n实现基础的扩容逻辑\n编写测试用例\n\n检验标准：\n\n 能够存储和获取键值对\n 正确处理哈希冲突\n key为null的情况处理\n 基本的扩容功能\n\n第三步：集合API熟练度练习（30分钟）练习内容：\n\nArrayList练习：\n\n// 练习题1：移除ArrayList中的重复元素List&lt;Integer&gt; list = Arrays.asList(1, 2, 2, 3, 3, 4);// 要求：保持原有顺序，移除重复元素\n\n\nHashMap练习：\n\n// 练习题2：统计字符串中每个字符的出现次数String str = &quot;hello world&quot;;// 要求：使用HashMap统计字符频率\n\n\nLinkedList练习：\n\n// 练习题3：使用LinkedList实现简单的队列操作// 要求：入队、出队、查看队首元素\n\n具体步骤：\n\n独立完成每个练习题\n对比不同集合类的性能\n记录解题思路和代码\n\n检验标准：30分钟内完成所有练习，代码可运行\n\nDay 2: IO流系统掌握上午理论学习（1小时）第一步：IO流体系结构梳理（20分钟）学习内容：\n\n 字节流和字符流的区别\n 输入流和输出流的分类\n 节点流和处理流的概念\n 常用IO类的继承关系\n\n具体操作：\n\n绘制IO流的分类思维导图\n列出常用的IO类：FileInputStream、BufferedReader等\n理解装饰器模式在IO中的应用\n\n检验方式：能够根据需求选择合适的IO流类\n第二步：文件操作核心API学习（20分钟）学习内容：\n\n File类的常用方法\n 文件和目录的创建、删除、重命名\n 文件属性的获取和设置\n 路径处理的最佳实践\n\n具体操作：\n\n学习File类的构造方法和常用API\n掌握相对路径和绝对路径的使用\n了解文件分隔符的跨平台处理\n\n检验方式：能够熟练使用File类进行文件操作\n第三步：NIO基础概念入门（20分钟）学习内容：\n\n NIO与传统IO的区别\n Buffer、Channel、Selector核心概念\n 同步非阻塞IO的原理\n NIO的适用场景\n\n具体操作：\n\n理解NIO的三大核心组件\n学习ByteBuffer的基本使用\n了解FileChannel的文件操作方式\n\n检验方式：能够解释NIO相比传统IO的优势\n晚上实践编程（2小时）第一步：基础文件操作实现（40分钟）任务目标：掌握文件的读写操作\n练习1：文本文件复制程序\n// 创建文件：FileCopyDemo.javapublic class FileCopyDemo &#123;    // 方法1：使用字节流复制任意类型文件    public static void copyWithByteStream(String src, String dest) &#123;        // 实现逻辑    &#125;        // 方法2：使用字符流复制文本文件    public static void copyWithCharStream(String src, String dest) &#123;        // 实现逻辑    &#125;        // 方法3：使用缓冲流提升性能    public static void copyWithBufferedStream(String src, String dest) &#123;        // 实现逻辑    &#125;&#125;\n\n具体步骤：\n\n创建测试文件（文本文件和图片文件）\n实现三种不同的文件复制方法\n比较复制速度和资源占用\n添加异常处理和资源关闭\n\n检验标准：\n\n 能够正确复制各种类型的文件\n 缓冲流版本性能明显优于普通流\n 正确处理异常和关闭资源\n 代码符合try-with-resources规范\n\n第二步：文件处理工具类开发（50分钟）任务目标：开发实用的文件操作工具类\n// 创建文件：FileUtils.javapublic class FileUtils &#123;    // 读取文件全部内容为字符串    public static String readFileToString(String filePath) &#123;        // 实现逻辑    &#125;        // 将字符串写入文件    public static void writeStringToFile(String content, String filePath) &#123;        // 实现逻辑    &#125;        // 按行读取文件    public static List&lt;String&gt; readLines(String filePath) &#123;        // 实现逻辑    &#125;        // 递归删除目录    public static boolean deleteDirectory(File directory) &#123;        // 实现逻辑    &#125;        // 获取文件大小（支持目录）    public static long getFileSize(File file) &#123;        // 实现逻辑    &#125;        // 查找指定扩展名的所有文件    public static List&lt;File&gt; findFilesByExtension(String directory, String extension) &#123;        // 实现逻辑    &#125;&#125;\n\n具体步骤：\n\n实现文件读写的便捷方法\n添加目录递归处理功能\n实现文件搜索和过滤功能\n编写完整的测试用例\n添加详细的异常处理\n\n检验标准：\n\n 所有方法功能正确\n 能够处理大文件（内存优化）\n 异常处理完善\n 测试覆盖各种场景\n\n第三步：网络IO编程入门（30分钟）任务目标：实现简单的网络通信程序\n练习：简单的Echo服务器和客户端\n// 创建文件：EchoServer.javapublic class EchoServer &#123;    public static void main(String[] args) &#123;        // 实现服务器端逻辑        // 监听端口，接收客户端连接        // 读取客户端消息并原样返回    &#125;&#125;// 创建文件：EchoClient.javapublic class EchoClient &#123;    public static void main(String[] args) &#123;        // 实现客户端逻辑        // 连接服务器        // 发送消息并接收回复    &#125;&#125;\n\n具体步骤：\n\n实现单线程Echo服务器\n实现对应的客户端程序\n测试连接和消息传递\n优化为多线程版本（时间允许）\n\n检验标准：\n\n 服务器能够正常启动和监听\n 客户端能够连接并通信\n 正确处理连接异常\n 资源正确释放\n\n\nDay 3: 多线程编程深入上午理论学习（1小时）第一步：线程基础概念复习（20分钟）学习内容：\n\n 进程与线程的区别\n 线程的生命周期状态\n Thread类和Runnable接口\n 线程的创建方式对比\n\n具体操作：\n\n绘制线程状态转换图\n比较继承Thread和实现Runnable的差异\n学习Callable和Future接口\n\n检验方式：能够解释线程状态转换过程\n第二步：线程安全问题分析（20分钟）学习内容：\n\n 什么是线程安全问题\n 竞态条件和临界区概念\n 内存可见性问题\n 指令重排序问题\n\n具体操作：\n\n分析经典的银行转账线程安全问题\n理解volatile关键字的作用\n学习happens-before原则\n\n检验方式：能够识别代码中的线程安全问题\n第三步：同步机制深入学习（20分钟）学习内容：\n\n synchronized关键字的使用\n Lock接口和ReentrantLock\n 读写锁ReadWriteLock\n 条件变量Condition\n\n具体操作：\n\n学习synchronized的三种使用方式\n比较synchronized和Lock的差异\n理解可重入锁的概念\n\n检验方式：能够选择合适的同步机制解决问题\n晚上实践编程（2小时）第一步：线程创建和基础操作（30分钟）任务目标：熟练掌握线程的创建和控制\n练习1：多种方式创建线程\n// 创建文件：ThreadCreationDemo.javapublic class ThreadCreationDemo &#123;    // 方式1：继承Thread类    static class MyThread extends Thread &#123;        @Override        public void run() &#123;            // 实现线程逻辑        &#125;    &#125;        // 方式2：实现Runnable接口    static class MyRunnable implements Runnable &#123;        @Override        public void run() &#123;            // 实现线程逻辑        &#125;    &#125;        // 方式3：使用Callable和Future    static class MyCallable implements Callable&lt;String&gt; &#123;        @Override        public String call() throws Exception &#123;            // 实现有返回值的线程逻辑            return &quot;result&quot;;        &#125;    &#125;        // 方式4：使用线程池    public static void testThreadPool() &#123;        // 使用ExecutorService创建线程池    &#125;&#125;\n\n具体步骤：\n\n实现四种不同的线程创建方式\n测试线程的启动、等待、中断\n比较各种方式的优缺点\n学习线程池的基本使用\n\n检验标准：\n\n 所有创建方式都能正常工作\n 理解每种方式的适用场景\n 能够正确处理线程异常\n 掌握线程池的基本配置\n\n第二步：线程安全编程实践（50分钟）任务目标：解决实际的线程安全问题\n练习1：银行账户转账系统\n// 创建文件：BankAccount.javapublic class BankAccount &#123;    private double balance;    private final Object lock = new Object();        public void deposit(double amount) &#123;        // 实现存款方法（线程安全）    &#125;        public boolean withdraw(double amount) &#123;        // 实现取款方法（线程安全）    &#125;        public void transfer(BankAccount target, double amount) &#123;        // 实现转账方法（避免死锁）    &#125;        public double getBalance() &#123;        // 实现余额查询（线程安全）    &#125;&#125;// 创建文件：BankTest.javapublic class BankTest &#123;    public static void main(String[] args) &#123;        // 测试多线程并发访问账户        // 验证数据一致性    &#125;&#125;\n\n具体步骤：\n\n实现线程安全的银行账户类\n创建多个线程并发执行转账操作\n验证最终余额的正确性\n优化转账方法避免死锁问题\n\n练习2：生产者消费者模式\n// 创建文件：ProducerConsumer.javapublic class ProducerConsumer &#123;    private final Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();    private final int maxSize = 10;    private final Object lock = new Object();        class Producer implements Runnable &#123;        @Override        public void run() &#123;            // 实现生产者逻辑        &#125;    &#125;        class Consumer implements Runnable &#123;        @Override        public void run() &#123;            // 实现消费者逻辑        &#125;    &#125;&#125;\n\n具体步骤：\n\n实现生产者消费者模式\n使用wait()和notify()进行线程协调\n测试多生产者多消费者场景\n优化为使用Lock和Condition\n\n检验标准：\n\n 银行转账系统数据一致性正确\n 转账过程无死锁发生\n 生产者消费者能够正确协调工作\n 队列大小限制有效\n\n第三步：线程池深入应用（40分钟）任务目标：掌握线程池的配置和使用\n练习：多任务处理系统\n// 创建文件：TaskProcessor.javapublic class TaskProcessor &#123;    // 创建不同类型的线程池    private ExecutorService fixedThreadPool;    private ExecutorService cachedThreadPool;    private ScheduledExecutorService scheduledPool;        // 处理CPU密集型任务    public void processCPUIntensiveTask() &#123;        // 实现CPU密集型任务处理    &#125;        // 处理IO密集型任务    public void processIOIntensiveTask() &#123;        // 实现IO密集型任务处理    &#125;        // 定时任务处理    public void scheduleTask() &#123;        // 实现定时任务    &#125;        // 批量任务处理    public List&lt;String&gt; processBatchTasks(List&lt;String&gt; tasks) &#123;        // 使用CompletionService处理批量任务    &#125;&#125;\n\n具体步骤：\n\n创建不同类型的线程池\n实现CPU密集型和IO密集型任务\n使用ScheduledExecutorService创建定时任务\n实现批量任务处理和结果收集\n添加线程池监控和异常处理\n\n检验标准：\n\n 能够根据任务特点选择合适的线程池\n 定时任务能够正确执行\n 批量任务处理效率高\n 线程池参数配置合理\n 正确关闭线程池释放资源\n\n\n三天学习成果验收综合练习项目：多线程文件处理器项目目标：结合集合、IO、多线程知识开发实用工具\n功能要求：\n\n扫描指定目录下的所有文件\n使用多线程并行处理文件（如计算MD5、统计行数等）\n将处理结果保存到数据结构中\n支持实时显示处理进度\n处理结果导出为文件\n\n技术要点：\n\n 使用File类递归扫描目录\n 用ThreadPoolExecutor处理文件\n 使用ConcurrentHashMap存储结果\n 实现线程安全的进度统计\n 使用BlockingQueue协调任务\n\n验收标准：\n\n 能够正确扫描和处理文件\n 多线程处理提升明显性能\n 程序运行稳定无死锁\n 进度显示准确\n 结果数据正确完整\n\n知识点测试清单集合框架：\n\n 能够选择合适的集合类解决问题\n 理解HashMap的工作原理\n 掌握ArrayList和LinkedList的适用场景\n\nIO流系统：\n\n 熟练使用各种IO流进行文件操作\n 能够开发文件处理工具\n 理解NIO的基本概念\n\n多线程编程：\n\n 掌握多种线程创建方式\n 能够解决线程安全问题\n 熟练使用线程池处理并发任务\n\n下一步学习建议完成Day 1-3的学习后，应该：\n\n每日复习：每天花15分钟回顾已学内容\n知识关联：思考这些基础知识在实际项目中的应用\n持续练习：继续在LeetCode上练习相关算法题\n准备面试：整理常见面试题的答案\n\n常见面试题准备：\n\nHashMap的实现原理和扩容机制\nArrayList和LinkedList的区别\nvolatile关键字的作用\nsynchronized和Lock的区别\n线程池的核心参数含义\n如何解决死锁问题\n\n"},{"title":"Git基本使用（Windows版）","url":"/2025/07/19/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"Git基本使用（Windows版）参考Git教程 - 廖雪峰的官方网站\n\n安装gitgit\n测试是否安装成功\n方式一\n\nwin + r 打开控制台输入\ngit --version\n\n\n方式二\n\n右击&#x3D;&#x3D;》显示更多选项&#x3D;&#x3D;》git bash here\n或快捷键（shift + f10）\n\n配置Git$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;\n\n注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n创建版本库新建文件夹$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit\n\n注意：如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n\n$ mkdir learngit 创建一个空目录 为learngit\n$ cd learngit 进入目录 \n$ pwd 显示当前目录的路径\n$ cd  返回上一级目录 \ncd d:cyfor\\\\ggg\n$ ls 列出当前文件夹的所有文件或文件夹(不包括隐藏的文件)\n$ ls -ah 列出当前文件夹的所有文件或文件夹(包括隐藏的文件)\n\n变为Git仓库（将当前目录变成git可以管理的仓库）$ git init\n\n当前目录会多一个.git的目录\n\n$ git init          \tgit仓库初始化，把这个目录变成Git可以管理的仓库\n\n小结初始化一个Git仓库，使用git init命令。\n添加文件到Git仓库，分两步：\n\n使用命令git add ，注意，可反复多次使用，添加多个文件；\n如果有多个文件夹可以用 git add . 命令\n使用命令git commit -m ，完成。\n\n\n把文件添加到版本库$ git add 文件名/目录名（文件夹名）$ git commit -m &quot;本次提交的说明&quot;\n\n\n$ git add readme.txt\n 把文件添加到仓库\n$ git commit -m “wrote a readme file”\n 把文件提交到仓库 -m后面输入的是本次提交的说明\n$ git add . \t\n当前目录所有元素都加入（文件和文件夹）\n\n$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot;\n\ncommit可以一次提交很多文件，所以你可以多次add不同的文件\n查看仓库当前的状态$ git status\n\n查看具体修改的内容$ git diff\n\n\n时光穿梭显示所有日志提交$ git log 显示从最近到最远的提交日志$ git log --pretty=oneline 简朴显示\n\n版本回退首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n$ git reset --hard HEAD^\n\n--hard参数有啥意义？--hard会回退到上个版本的已提交状态，而--soft会回退到上个版本的未提交状态，--mixed会回退到上个版本已添加但未提交的状态。现在，先放心使用--hard。\n版本恢复方式一：知道版本号恢复\n办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：\n$ git reset --hard 1094a\n\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n方式二：寻找版本号恢复\n$ git reflog\n\n小结\nHEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。\n穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。\n要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。\n\n\n工作区和暂存区电脑中可以看到的目录（文件夹） &#x3D;&#x3D; 工作区\n版本库（工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库）\n版本库有stage和master（分支）、head（头指针）组成\n$ git status 是对工作区的情况$ git add xxx 是将工作区的内容提交到stage中$ git commit -m &quot;xxx&quot; 是将stage的内容提交到master分支中\n\n总结\n每次修改完文件，就add 放入stage中，再commit到分支，因为commit只会提交stage中的文件\n\n\n撤销修改情况一（未添加到stage中）：直接撤销\n$ git checkout -- readme.txt\n\n情况二（放入到stage中）：撤销到工作区再直接撤销\n用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区\n$ git reset HEAD readme.txt\n\n情况三（commit到分支中）：直接回退版本（前提是没有将本地版本库推送到远程）小结场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](##### 版本恢复)一节，不过前提是没有推送到远程库。\n\n删除文件流程：\n\n先删除工作区的文件（命令或手动）\n使用git rm 和git add\n\n删除工作区的文件\n$ rm test.txt\n\n删除版本库中的文件\n$ git rm test.txt$ git commit -m &quot;remove test.txt&quot;\n\n删错文件，从版本库中恢复\ngit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n$ git checkout -- test.txt\n\n 注意\n从来没有被添加到版本库就被删除的文件，是无法恢复的！\n小结\n命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。\n\n远程仓库添加远程仓库第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n第2步：登陆GitHub，点击右上角的头像，settings，SSH与GPG公钥\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n第3步：在主页右上角找到“Create a new repo”按钮，创建一个新的仓库\n第4步：连接对应的仓库\n$ git remote add origin git@github.com:michaelliao/learngit.git\n\n添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n第5步：把本地库的所有内容推送到远程库上\n$ git push -u origin master\n\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n从现在起，只要本地作了提交，就可以通过命令：\n$ git push origin master\n\nSSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：\nThe authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?\n\n这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。\nGit会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：\nWarning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.\n\n这个警告只会出现一次，后面的操作就不会有任何警告了。\n如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。\n查看远程库信息如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm &lt;name&gt;命令。使用前，建议先用git remote -v查看远程库信息：\n$ git remote -v\n\n删除远程库根据名字删除，比如删除origin：\n$ git remote rm origin\n\n此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。\n小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；\n关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；\n关联后，使用命令git push -u origin master第一次推送master分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n从远程库克隆git clone 目标地址.git\n$ git clone git@github.com:michaelliao/gitskills.git\n\n你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n小结要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。\nGit支持多种协议，包括https，但ssh协议速度最快。\n\n分支处理创建dev分支，然后切换到dev分支$ git checkout -b devSwitched to a new branch &#x27;dev&#x27;\n\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n$ git branch dev$ git checkout devSwitched to branch &#x27;dev&#x27;\n\ngit branch&#96;命令查看当前分支$ git branch* dev  master\n\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n切换分支git checkout 分支名\n$ git checkout master\n\n现在，我们把dev分支的工作成果合并到master分支上：\n合并分支$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+)\n\ngit merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n合并完成后，就可以放心地删除dev分支了：\n删除分支$ git branch -d devDeleted branch dev (was b17d20e).\n\n删除后，查看branch，就只剩下master分支了：\n查看分支$ git branch* master\n\n小结Git鼓励大量使用分支：\n查看分支：git branch\n创建分支：git branch &lt;name&gt;\n切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;\n创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;\n合并某分支到当前分支：git merge &lt;name&gt;\n删除分支：git branch -d &lt;name&gt;\n\n冲突分支修改的当行，commit后。主分支有修改当行，commit。会有冲突。\n解决方案（修改再提交）\n我们可以直接查看readme.txt的内容：\nGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1\n\nGit用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：\nGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.Creating a new branch is quick and simple.\n\n其他用带参数的git log也可以看到分支的合并情况：\n$ git log --graph --pretty=oneline --abbrev-commit\n\n尝试拉取远程更改时允许合并不相关的提交历史：\ngit pull origin master --allow-unrelated-histories\n\n\n\ncd(Change directory)    改变文件夹\nmkdir(Make directory)    新建文件夹\npwd(Print working directory)   显示当前目录\ninit(Initialization)    初始化\nstatus    情况\ncommit    提交\nstage\t暂存区\n添加某个文件时，该文件必须在当前目录下存在，用ls或者dir命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名\n$ git remote add origin git@github.com:michaelliao&#x2F;learngit.git\n请千万注意，把上面的michaelliao替换成你自己的GitHub账户名\n添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n$ git push -u origin master\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n只要本地作了提交，就可以通过命令：\n$ git push origin master\ngit remote rm 命令。使用前，建议先用git remote -v查看远程库信息：\n$ git remote -v\n根据名字删除，比如删除origin：\n$ git remote rm origin\n此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。\n要关联一个远程库，使用命令git remote add origin git@server-name:path&#x2F;repo-name.git；\n关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；\n关联后，使用命令git push -u origin master第一次推送master分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；\n","categories":["计算机"],"tags":["Git"]},{"title":"Hexo+Butterfly 优雅配置音乐播放器","url":"/2025/08/14/Hexo-Butterfly-%E4%BC%98%E9%9B%85%E9%85%8D%E7%BD%AE%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","content":"Hexo+Butterfly 优雅配置音乐播放器在博客中嵌入音乐播放器，能为访客营造更沉浸的阅读氛围。Hexo 搭配 Butterfly 主题时，借助 APlayer 和 Meting.js 可快速实现这一功能，无需复杂开发。本文将详细讲解配置流程、参数含义及实用技巧，帮你轻松打造专属音乐博客。\n一、核心工具与原理配置音乐播放器需依赖两个关键工具，二者分工明确：\n\nAPlayer：轻量级 HTML5 音乐播放器内核，负责渲染播放界面、控制播放逻辑（如暂停、切换歌曲）；\n\nMeting.js：音乐平台 API 封装工具，支持直接调用网易云、QQ 音乐等平台的播放列表，无需自建音乐文件库。\n\n\n工作流程：Meting.js 从音乐平台获取播放列表数据，APlayer 将数据渲染为可视化播放器，实现 “一键接入在线音乐” 的效果。\n二、前置准备\n环境要求：\n\n已安装 Hexo 博客框架及 Butterfly 主题（建议使用最新版本，兼容性更好）。\n若未安装主题，可参考 Butterfly 官方文档 完成部署。\n\n获取音乐资源 ID：\n\n以网易云音乐为例，打开目标播放列表，URL 中 id&#x3D; 后的数字即为播放列表 ID（如 https://music.163.com/playlist?id=13293433925 中，13293433925 就是需用到的 ID）。\n支持的平台：网易云（netease）、QQ 音乐（qq）、虾米（xiami）等。\n三、详细配置步骤1. 修改主题配置文件Butterfly 主题通过 _config.butterfly.yml 管理注入代码，无需修改主题源码，步骤如下：\n（1）打开配置文件在 Hexo 根目录中找到 _config.butterfly.yml（主题配置文件，非 Hexo 根目录的 _config.yml）。\n（2）配置注入资源搜索 inject 配置项，注入 APlayer 样式、Meting.js 脚本及播放器容器：\ninject:  head:  # 注入到&lt;head&gt;标签，加载样式    - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;    bottom:  # 注入到页面底部，加载脚本和播放器    - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&quot;&gt;&lt;/script&gt;    # 播放器容器配置    - &lt;div class=&quot;aplayer no-destroy&quot;          data-id=&quot;13293433925&quot;  # 替换为你的播放列表ID\t\t\t(修改你自己的id)         data-server=&quot;netease&quot;  # 音乐平台（netease/qq/xiami）   (修改,选择你自己的音乐平台)         data-type=&quot;playlist&quot;   # 资源类型（playlist/song/album）         data-fixed=&quot;true&quot;      # 是否固定在底部（true/false）         data-mini=&quot;true&quot;       # 固定时是否迷你显示（true/false）         data-listFolded=&quot;false&quot; # 是否折叠播放列表（true/false）         data-order=&quot;random&quot;    # 播放顺序（random/normal/single）         data-preload=&quot;auto&quot;    # 预加载模式（auto/none/metadata）         data-autoplay=&quot;false&quot;  # 是否自动播放（建议false，避免浏览器拦截）         data-theme=&quot;#409EFF&quot;&gt;  # 主题色（与Butterfly主题色匹配）      &lt;/div&gt;\n\n2. 配置播放器全局开关在 _config.butterfly.yml 中找到 aplayerInject 配置，控制播放器是否启用及显示范围：\naplayerInject:  enable: true  # 全局启用播放器（true/false）  per_page: true  # 所有页面均显示（true）或仅在指定页面显示（false）\n\n3. 生效配置执行以下命令清理缓存并启动本地服务，查看效果：\nhexo clean &amp;&amp; hexo s  # 清理缓存后启动服务，访问 http://localhost:4000 验证\n\n四、关键参数详解播放器的核心功能由 data-* 参数控制，理解这些参数可灵活定制播放器行为：\n\n\n\n参数名\n含义与可选值\n推荐配置\n\n\n\ndata-id\n音乐资源唯一标识（播放列表 &#x2F; 歌曲 ID）\n替换为自己的播放列表 ID\n\n\ndata-server\n音乐平台\nnetease（资源丰富，稳定性好）\n\n\ndata-type\n资源类型\nplaylist（播放列表，多首歌循环）\n\n\ndata-fixed\n是否固定在页面底部\ntrue（不遮挡内容，体验更佳）\n\n\ndata-mini\n固定模式下是否迷你显示\ntrue（节省空间）\n\n\ndata-order\n播放顺序\nrandom（随机播放，增加新鲜感）\n\n\ndata-autoplay\n是否自动播放\nfalse（浏览器默认拦截自动播放）\n\n\ndata-theme\n主题色（十六进制颜色码）\n与 Butterfly 主题主色一致（如 #409EFF）\n\n\n五、实用技巧与个性化切换音乐平台只需修改 data-server 和对应平台的 data-id：\n\nQQ 音乐：data-server&#x3D;”qq” data-id&#x3D;”QQ播放列表ID”\n\n虾米音乐：data-server&#x3D;”xiami” data-id&#x3D;”虾米播放列表ID”\n\n\n六、注意事项\nAPI 访问限制：\n\n音乐平台 API 可能存在防盗链机制，若播放器加载失败，可尝试：\n\n\n更换播放列表（避免版权受限的资源）；\n\n\n\n使用 HTTPS 协议（部分平台要求）。\n\n\n\n\n性能优化：\n\n\n\n播放列表不宜过大（建议 10-30 首歌），减少加载时间；\n\n\n\n关闭不必要的参数（如 data-preload&#x3D;”none” 关闭预加载）。\n\n\n\n\n兼容性问题：\n\n\n\n确保 APlayer 和 Meting.js 版本匹配（本文使用官方推荐的 CDN 版本，兼容性最佳）；\n\n\n\n低版本浏览器（如 IE）可能不支持，建议使用现代浏览器（Chrome、Edge 等）。\n\n\n\n总结：核心要点速览\n\n\n环节\n关键操作\n\n\n\n核心工具\nAPlayer（播放器界面）+ Meting.js（音乐 API 对接）\n\n\n配置入口\n主题配置文件 _config.butterfly.yml 的 inject 项\n\n\n必改参数\ndata-id（播放列表 ID）、data-server（音乐平台）\n\n\n显示控制\n全局 &#x2F; 单页显示通过 aplayerInject.per_page 和 Front-matter 控制\n\n\n避坑指南\n关闭自动播放、控制播放列表大小、注意 API 限制\n\n\n通过以上步骤，你的 Hexo 博客将拥有一个美观且功能完善的音乐播放器。如需进一步定制，可参考 APlayer 官方文档 和 Meting.js 文档 探索更多高级功能（如歌词显示、自定义控件）。\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo 中 Butterfly 主题修改字体大小教程","url":"/2025/08/11/Hexo-%E4%B8%AD-Butterfly-%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E6%95%99%E7%A8%8B/","content":"Hexo 中 Butterfly 主题修改字体大小教程在使用 Hexo 搭建博客并采用 Butterfly 主题时，有时我们需要根据自己的阅读习惯调整字体大小，下面就来介绍具体的修改方法。\n找到配置文件首先，我们需要找到字体大小设置所在的文件，路径为：\n\\node_modules\\hexo-theme-butterfly\\source\\css\\var.styl\n\n可以通过文件管理器导航到该路径，也可以在博客的开发工具中直接定位到这个文件。\n修改字体大小参数打开var.styl文件后，我们会看到关于字体大小的配置代码：\n// Global Variables$font-size = hexo-config(&#x27;font.global_font_size&#x27;) ? convert(hexo-config(&#x27;font.global_font_size&#x27;)) : 18px  // 全局字体大小$code-font-size = hexo-config(&#x27;font.code_font_size&#x27;) ? convert(hexo-config(&#x27;font.code_font_size&#x27;)) : var(--global-font-size)  // 代码字体大小$font-color = #1F2D3D  // 字体颜色\n\n\n$font-size：这是全局字体大小的设置。代码的意思是，如果在 Hexo 的配置文件中设置了font.global_font_size，则使用该配置的值；如果没有设置，则默认使用 18px（如示例中修改后的数值）。我们可以直接修改这里的默认值（如 18px）来调整全局字体大小。\n\n$code-font-size：这是代码块字体大小的设置。同理，如果配置了font.code_font_size则使用该值，否则默认使用全局字体大小（var(–global-font-size)）。\n\n\n生效修改修改完成后，保存文件，然后在终端中执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s命令，重新生成并预览博客，就可以看到字体大小的变化了。如果是部署在服务器上，还需要执行hexo d命令重新部署。\n通过这种方式，我们可以简单有效地调整 Butterfly 主题下的字体大小，让博客更符合自己的阅读需求。\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo 双分支部署指南：从原理到 Netlify 实战","url":"/2025/08/17/Hexo-%E5%8F%8C%E5%88%86%E6%94%AF%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0-Netlify-%E5%AE%9E%E6%88%98/","content":"Hexo 双分支部署指南：从原理到 Netlify 实战在 Hexo 博客部署中，很多人会困惑于hexo d自动部署与 GitHub 手动提交的区别，以及如何通过双分支结构优雅地部署到 Netlify。本文将清晰拆解两种部署方式的核心差异，并手把手教你用双分支策略实现 Netlify 部署，兼顾源码安全与静态文件发布需求。\n一、核心概念：hexo d与 GitHub 手动提交的区别简单说，两者的本质是操作对象和目标分支的不同，具体区别如下：\n\n\n\n维度\nhexo d（自动部署）\nGitHub 手动提交（git push）\n\n\n\n操作对象\n仅处理public文件夹（静态文件：HTML&#x2F;CSS&#x2F;JS 等）\n处理 Hexo 源码（source文章、themes主题、_config.yml配置等）\n\n\n依赖配置\n依赖_config.yml中的deploy字段（指定仓库和分支）\n依赖 Git 基础命令（add&#x2F;commit&#x2F;push），无需特殊配置\n\n\n分支用途\n通常部署到静态文件分支（如gh-pages&#x2F;netlify-pages）\n通常提交到源码分支（如main）\n\n\n核心作用\n快速发布静态文件到展示平台\n备份源码、多设备同步开发\n\n\n是否需要****package.json\n不需要（仅推送静态文件）\n需要（源码分支需依赖管理）\n\n\n关键原理：Hexo 的 “源码 - 静态文件” 分离Hexo 是静态博客生成器，工作流分为两步：\n\nhexo g（生成）：将source中的 Markdown 源码转换为public中的静态文件；\n\nhexo d（部署）：将public推送到指定分支。\n\n\n手动提交则是直接管理源码，两者需通过不同分支隔离，否则会导致文件覆盖（这也是建议双分支的核心原因）。\n二、双分支部署策略：源码与静态文件分离双分支策略的核心是用两个分支分别管理源码和静态文件，既保护源码安全，又满足不同平台的部署需求。推荐分支命名：\n\nmain：存放 Hexo 源码（Markdown 文章、主题、配置等）；\n\nnetlify-pages：存放public静态文件（供 Netlify 直接部署）。\n\n\n三、部署到 Netlify 的两种方式（按需求选择）方式 1：静态文件分支部署（直接用public内容）适合场景：希望直接部署本地生成的public文件，跳过 Netlify 云端构建，无需package.json。\n步骤 1：创建静态文件分支# 1. 新建并切换到空分支（无历史记录，更干净）git checkout --orphan netlify-pages# 2. 删除当前分支所有文件（避免污染源码）git rm -rf .# 3. 本地生成最新public（确保包含所有文章）hexo clean &amp;&amp; hexo generate# 4. 将public内容复制到当前分支根目录（注意是内容，不是文件夹）cp -r public/* .# 5. 提交静态文件git add .git commit -m &quot;部署静态文件到netlify-pages&quot;git push -u origin netlify-pages  # 推送到远程静态分支\n\n步骤 2：配置 Netlify（无需构建）\n登录 Netlify，关联你的 GitHub 仓库；\n\n进入站点设置 → Build &amp; deploy → Build settings：\n\n\n\n\nBranch to deploy：选择netlify-pages；\n\n\n\nBuild command：留空（或填#，表示不执行构建）；\n\n\n\nPublish directory：填.（点号，表示直接发布分支根目录的静态文件）。\n\n\n\n\n点击 “Deploy site”，Netlify 会直接读取netlify-pages分支的静态文件并部署。\n\n方式 2：源码分支部署（云端生成public）适合场景：希望 Netlify 自动生成public，需依赖package.json管理依赖，适合多设备同步开发。\n步骤 1：准备源码分支# 1. 切换到源码分支（如main，若不存在则创建）git checkout -b main# 2. 确保本地有完整源码（关键文件）ls  # 应包含：source/、themes/、_config.yml、package.json、package-lock.json# 3. 若缺失package.json，重新初始化（正常Hexo项目默认包含）npm init -y  # 生成基础package.jsonnpm install hexo --save  # 安装Hexo核心依赖# 4. 提交源码git add .git commit -m &quot;提交Hexo源码（含package.json）&quot;git push -u origin main  # 推送到远程源码分支\n\n步骤 2：配置 Netlify（云端构建）\n进入 Netlify 站点设置 → Build settings：\n\n\n\nBranch to deploy：选择main；\n\n\n\nBuild command：填npm install &amp;&amp; hexo generate（安装依赖→生成 public）；\n\n\n\nPublish directory：填public（指定静态文件目录）。\n\n\n\n\n点击 “Deploy site”，Netlify 会自动执行：\n\n\n\n拉取main分支源码 → 安装依赖 → 生成public → 部署静态文件。\n\n\n\n四、关键说明与注意事项1. 分支隔离是核心\n两个分支必须严格隔离：main只存源码，netlify-pages只存静态文件，避免互相污染；\n\n用.gitignore确保main分支忽略public（避免源码分支包含静态文件）：\n\n\n# main分支的.gitignorepublic/node_modules/\n\n2. 静态文件分支部署注意事项\n本地生成public时必须完整：执行hexo clean &amp;&amp; hexo generate后，检查public中是否有index.html和文章对应的 HTML 文件；\n\n更新文章时，需重新生成public并同步到netlify-pages分支：\n\n\nhexo clean &amp;&amp; hexo generate  # 生成新publicgit checkout netlify-pagesrm -rf *  # 删除旧文件cp -r public/* .  # 复制新文件git add . &amp;&amp; git commit -m &quot;更新文章&quot; &amp;&amp; git push\n\n3. 源码分支部署注意事项\npackage.json必须包含必要依赖：至少有hexo（否则 Netlify 会提示 “hexo: command not found”）；\n\n主题和配置文件必须完整：themes文件夹和_config.yml需提交到main分支，否则云端生成的public会缺失样式；\n\n构建命令可简化：若package.json中定义了build脚本，可直接用npm run build：\n\n\n// package.json&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo generate&quot;&#125;\n\n此时 Netlify 的 Build command 可改为npm install &amp;&amp; npm run build。\n五、总结：核心要点速览\n\n\n部署方式\n分支名称\n关键配置（Netlify）\n适用场景\n\n\n\n静态文件部署\nnetlify-pages\nBuild command：留空；Publish dir：.\n本地生成 public，追求部署速度和稳定性\n\n\n源码云端构建\nmain\nBuild command：npm install &amp;&amp; hexo generate；Publish dir：public\n多设备开发，需要自动生成静态文件\n\n\n通过双分支策略，你可以根据需求灵活选择部署方式：想直接用public就选静态文件分支，想让云端自动处理就选源码分支。两种方式都能完美适配 Netlify，既保证源码安全，又能顺畅发布博客。\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo 常用命令使用和详解","url":"/2025/08/11/Hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%92%8C%E8%AF%A6%E8%A7%A3/","content":"Hexo 常用命令使用和详解Hexo 作为一款高性能的静态博客框架，其命令行工具设计简洁却功能强大。无论是新手搭建第一个博客，还是老手批量管理内容，掌握核心命令都是提升效率的关键。详细解析 Hexo 常用命令的用法与技巧。\n一、内容管理：文章与页面的创建与发布1. 创建文章（默认布局为 post）hexo new &quot;文章标题&quot;  # 等价于 hexo new post &quot;文章标题&quot;\n\n\n生成路径：source&#x2F;_posts&#x2F;文章标题.md\n\nMarkdown 头部信息（Front-matter）：自动生成包含标题、日期、标签等元数据的头部，例如：\n\n\n---title: 文章标题date: 2025-08-10 15:30:00tags:- Hexo---\n\n2. 创建独立页面（如关于页、分类页）hexo new page &quot;页面名称&quot;  # 如 hexo new page &quot;about&quot;\n\n\n生成路径：source&#x2F;页面名称&#x2F;index.md\n\n特点：页面 URL 为 域名&#x2F;页面名称（如 https://example.com/about），适合放置固定内容\n\n\n二、生成与预览：本地验证内容效果1. 生成静态文件hexo generate  # 简写：hexo g\n\n\n作用：将 Markdown 内容、主题模板编译为静态 HTML&#x2F;CSS&#x2F;JS，输出到 public 目录\n\n2. 本地预览博客hexo server  # 简写：hexo s\n\n\n默认访问地址：http://localhost:4000\n\n实用参数：\n\n\nhexo s -p 5000：指定端口（解决 4000 端口被占用问题）\n\n\n\nhexo s -i 0.0.0.0：允许局域网其他设备访问（如手机预览移动端效果）\n\n\n\n3. 清理缓存与生成文件hexo clean\n\n\n作用：删除 public 目录（生成的静态文件）和 db.json（缓存数据）\n\n何时使用：\n\n\n主题更换后（避免旧主题文件残留）\n\n\n\n内容更新后页面显示异常（如样式错乱、内容缺失）\n\n\n\n部署前（确保发布的是最新版本）\n\n\n\n4. 高效部署组合命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n\n清理→生成→本地预览\n默认访问地址：http://localhost:4000\nhexo clean &amp;&amp; hexo g -d  # 清理→生成→部署一站式操作\n\n先清理旧文件避免缓存干扰，再生成最新静态文件，最后直接部署，是日常发布的最佳实践\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"JDK7 与 JDK8 中 HashMap 的演进：从问题到优化的全面解析","url":"/2025/08/11/JDK7-%E4%B8%8E-JDK8-%E4%B8%AD-HashMap-%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8E%E9%97%AE%E9%A2%98%E5%88%B0%E4%BC%98%E5%8C%96%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/","content":"JDK7 与 JDK8 中 HashMap 的演进：从问题到优化的全面解析HashMap 作为 Java 集合框架中使用最广泛的工具类，在 JDK7 到 JDK8 的版本迭代中经历了根本性的设计升级。从单纯的 “数组 + 链表” 到引入红黑树优化，从线程不安全的头插法到更稳健的尾插法，这些变化不仅解决了旧版本的性能瓶颈，更体现了 Java 对实际开发需求的持续响应。本文将对比解析两个版本的核心设计，带你理解 HashMap 的演进逻辑。\n一、JDK7 HashMap：简单设计下的性能与安全隐患JDK7 的 HashMap 采用 “数组 + 单向链表” 的基础结构，实现简单但在高频场景下暴露了明显缺陷。\n1. 底层结构：数组 + 单向链表\n数组（Entry [] table）：作为存储节点的 “桶”，长度始终为 2 的幂（初始 16），通过(n-1) &amp; hash计算索引（等价于取模，效率更高）。\n\n链表（Entry 节点）：每个节点包含hash、key、value和next指针，用于解决哈希冲突 —— 当多个 key 计算出相同索引时，用链表串联节点。\n\n\n2. 核心问题点\n头插法导致的线程安全风险：新节点插入链表头部（newEntry.next &#x3D; table[i]; table[i] &#x3D; newEntry），多线程扩容时可能形成环形链表，导致get操作陷入无限循环。\n\n链表过长的性能瓶颈：无红黑树优化，当哈希冲突严重时，链表长度可能急剧增长，查询时间复杂度退化为 O (n)。\n\n扩容效率低：节点迁移时需重新计算哈希索引，且头插法会导致链表顺序反转。\n\n\n3. 关键方法：put 流程的隐患// JDK7 put核心逻辑简化public V put(K key, V value) &#123;    if (table == EMPTY_TABLE) &#123;        inflateTable(threshold); // 初始化数组    &#125;    if (key == null) return putForNullKey(value);    int hash = hash(key);    int i = indexFor(hash, table.length);    // 遍历链表检查重复key    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;        if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;            V oldValue = e.value;            e.value = value;            return oldValue;        &#125;    &#125;    modCount++;    addEntry(hash, key, value, i); // 头插法插入新节点    return null;&#125;\n\n二、JDK8 HashMap：红黑树带来的性能革命JDK8 针对 JDK7 的缺陷进行了全方位优化，引入红黑树和尾插法，彻底改写了 HashMap 的性能表现。\n1. 底层结构：数组 + 链表 + 红黑树的复合设计\n数组（Node [] table）：保留 2 的幂长度特性，但初始化时机推迟到首次put（延迟初始化，节省内存）。\n\n链表（Node 节点）：仅在哈希冲突较少时使用，新节点采用尾插法插入，避免链表反转。\n\n红黑树（TreeNode 节点）：当链表长度超过 8 且数组长度≥64时，链表转为红黑树（查询复杂度降至 O (logn)）；当节点数≤6 时，自动还原为链表（减少树结构维护成本）。\n\n\n2. 核心改进点\n哈希算法优化：通过高位异或（h ^ (h &gt;&gt;&gt; 16)）让高位信息参与索引计算，减少冲突概率：\n\nstatic final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;\n\n\n尾插法插入节点：新节点添加到链表尾部，避免多线程扩容时的环形链表问题（但仍非线程安全）。\n\n高效扩容机制：节点迁移时无需重新计算哈希，通过(hash &amp; oldCap)判断是否迁移至 “原索引 + 旧容量” 位置，大幅提升扩容效率。\n\n\n3. 关键方法：put 流程的优化// JDK8 put核心逻辑简化final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length; // 延迟初始化    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null); // 桶为空直接插入    else &#123;        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp; ((k = p.key) == key || key.equals(k)))            e = p; // 命中重复key        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 红黑树插入        else &#123;            // 链表插入，尾插法            for (int binCount = 0; ; ++binCount) &#123;                if ((e = p.next) == null) &#123;                    p.next = newNode(hash, key, value, null);                    // 满足条件时转为红黑树                    if (binCount &gt;= TREEIFY_THRESHOLD - 1)                        treeifyBin(tab, hash);                    break;                &#125;                if (e.hash == hash &amp;&amp; key.equals(e.key)) break;                p = e;            &#125;        &#125;        if (e != null) &#123; // 覆盖重复key的value            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            return oldValue;        &#125;    &#125;    ++modCount;    if (++size &gt; threshold) resize(); // 检查扩容    return null;&#125;\n\n三、JDK7 与 JDK8 HashMap 核心差异对比\n\n\n特性\nJDK7 HashMap\nJDK8 HashMap\n\n\n\n底层结构\n数组 + 单向链表\n数组 + 链表 + 红黑树\n\n\n节点插入方式\n头插法（链表反转）\n尾插法（顺序保留）\n\n\n哈希计算\n二次哈希（效果有限）\n高位异或（减少冲突）\n\n\n扩容节点迁移\n重新计算索引\n基于旧容量判断（高效迁移）\n\n\n极端查询性能\nO (n)（链表过长）\nO (logn)（红黑树优化）\n\n\n初始化时机\n构造器直接创建数组\n首次 put 时延迟初始化\n\n\n线程安全隐患\n多线程扩容可能形成环形链表\n尾插法避免环形链表（仍不安全）\n\n\n四、实战指南：不同版本下的使用建议1. 版本选择\n新系统优先使用 JDK8 及以上版本，享受红黑树和高效扩容带来的性能提升。\n\n维护 JDK7 旧系统时，避免在多线程场景使用 HashMap，改用ConcurrentHashMap。\n\n\n2. 初始容量设置无论哪个版本，均需根据预期数据量设置初始容量，减少扩容次数：\n初始容量 &#x3D; (预期元素数 &#x2F; 0.75) + 1（0.75 为默认加载因子）。\n例如：存储 1000 个元素，建议初始容量为(1000&#x2F;0.75)+1≈1334（实际会调整为 2048，2 的幂）。\n3. 线程安全处理\nJDK7&#x2F;8 的 HashMap 均线程不安全，多线程场景需替换为：\n\n\nConcurrentHashMap（推荐，JDK8 + 基于 CAS 实现，性能优异）；\n\n\n\nCollections.synchronizedMap()（全局锁，性能较差）。\n\n\n\n4. key 的设计原则\n优先使用不可变对象（如 String、Long），避免hashCode变化导致的查询异常。\n\n自定义类作为 key 时，必须同时重写hashCode()和equals()，保证逻辑一致。\n\n\n总结从 JDK7 到 JDK8，HashMap 的演进本质是 “解决实际问题” 的过程：用红黑树解决链表过长的性能问题，用尾插法规避线程安全风险，用延迟初始化优化内存占用。这些变化不仅提升了工具类的实用性，更体现了 “平衡时间与空间” 的设计哲学。\n理解两个版本的差异，不仅能帮助我们在开发中合理选型、规避风险，更能让我们从源码层面学到 “发现问题 - 解决问题” 的思维方式 —— 这正是深入学习 Java 集合框架的核心价值。\n","categories":["编程语言"],"tags":["JAVA","集合"]},{"title":"Hexo使用Butterfly主题配置页脚网站运行实时时间","url":"/2025/07/26/Hexo%E4%BD%BF%E7%94%A8Butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%A1%B5%E8%84%9A%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%97%B6%E9%97%B4/","content":"Hexo使用Butterfly主题配置页脚网站运行实时时间一、找配置文件寻找&#x2F;node_modules&#x2F;hexo-theme-butterfly&#x2F;layout&#x2F;includes&#x2F;footer.pug文件，添加完之后已经成功了，但是在左下角\n里面的代码直接全部替换为\n- const &#123; nav, owner, copyright, custom_text &#125; = theme.footerif nav  .footer-flex    for block in nav      .footer-flex-items(style=`$&#123; block.width ? &#x27;flex-grow:&#x27; + block.width : &#x27;&#x27; &#125;`)        for blockItem in block.content          .footer-flex-item            .footer-flex-title= blockItem.title            .footer-flex-content              for subitem in blockItem.item                if subitem.html                  div!= subitem.html                else if subitem.url                  a(href=url_for(subitem.url), target=&#x27;_blank&#x27; title=subitem.title)= subitem.title                else if subitem.title                  div!= subitem.title.footer-running-time  span 本站已运行：&lt;span id=&quot;running-time&quot;&gt;0 天 0 小时 0 分钟 0 秒&lt;/span&gt;script.  function updateRunningTime() &#123;    const startDate = new Date(&quot;2025-07-20T00:00:00&quot;); // 修改为你自己的建站时间    const now = new Date();    let diff = Math.floor((now - startDate) / 1000); // 时间差（秒）    const days = Math.floor(diff / 86400);    diff -= days * 86400;    const hours = Math.floor(diff / 3600) % 24;    diff -= hours * 3600;    const minutes = Math.floor(diff / 60) % 60;    const seconds = diff % 60;    document.getElementById(&quot;running-time&quot;).innerText =      `$&#123;days&#125; 天 $&#123;hours&#125; 小时 $&#123;minutes&#125; 分钟 $&#123;seconds&#125; 秒`;  &#125;  // 页面加载后立即执行一次，之后每秒更新一次  document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;    updateRunningTime();    setInterval(updateRunningTime, 1000);  &#125;);.footer-other  .footer-copyright    if owner.enable      - const currentYear = new Date().getFullYear()      - const sinceYear = owner.since      span.copyright        if sinceYear &amp;&amp; sinceYear != currentYear          != `&amp;copy;$&#123;sinceYear&#125; - $&#123;currentYear&#125; By $&#123;config.author&#125;`        else          != `&amp;copy;$&#123;currentYear&#125; By $&#123;config.author&#125;`    if copyright.enable      - const v = copyright.version ? getVersion() : false      span.framework-info        if owner.enable &amp;&amp; nav          span.footer-separator |        span= _p(&#x27;footer.framework&#x27;) + &#x27; &#x27;        a(href=&#x27;https://hexo.io&#x27;)= `Hexo$&#123; v ? &#x27; &#x27; + v.hexo : &#x27;&#x27; &#125;`        span.footer-separator |        span= _p(&#x27;footer.theme&#x27;) + &#x27; &#x27;        a(href=&#x27;https://github.com/jerryc127/hexo-theme-butterfly&#x27;)= `Butterfly$&#123; v ? &#x27; &#x27; + v.theme : &#x27;&#x27; &#125;`  if theme.footer.custom_text    .footer_custom_text!= theme.footer.custom_text\n\n自定义CSS样式（更加美观）找到&#x2F;source文件夹，新建css文件夹，在css文件夹中新建custom.css文件，将下面代码全部复制到custom.css文件中\n\n.footer-running-time &#123;  font-size: 18px;  font-weight: bold;  text-align: center;  margin: 15px 0;  padding: 12px 18px;  border-radius: 10px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);  background: linear-gradient(90deg, #ffc0fa, #f375f3);  -webkit-background-clip: text;  -webkit-text-fill-color: transparent;  display: flex;  justify-content: center;  align-items: center;  gap: 12px;  flex-wrap: wrap;  transition: all 0.3s ease;  position: relative;&#125;.footer-running-time::before &#123;  content: &#x27;&#x27;;  position: absolute;  top: 0;  left: 0;  width: 100%;  height: 100%;  background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 1px, transparent 1px);  background-size: 4px 4px;  opacity: 0.3;  z-index: 0;  pointer-events: none;&#125;.footer-running-time i.fas.fa-hourglass &#123;  font-size: 20px;  margin-right: 6px;  color: #ffffff;  background: #ffc0cb;  border-radius: 50%;  padding: 8px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);  animation: bounce 1.2s infinite;  z-index: 1;&#125;@keyframes bounce &#123;  0%, 100% &#123;    transform: translateY(0) scale(1);  &#125;  50% &#123;    transform: translateY(-6px) scale(1.05);  &#125;&#125;\n\n让CSS样式生效找到_config.butterfly.yml文件inject中的head属性\ninject:  head:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;&gt; #增加这一行\n效果图\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"LinkedHashMap、HashSet、LinkedHashSet 深度解析：从源码到实战","url":"/2025/08/11/LinkedHashMap%E3%80%81HashSet%E3%80%81LinkedHashSet-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%AE%9E%E6%88%98/","content":"LinkedHashMap、HashSet、LinkedHashSet 深度解析：从源码到实战在 Java 集合框架中，LinkedHashMap、HashSet 和 LinkedHashSet 是基于 HashMap 衍生出的高频使用类。它们看似独立，实则底层紧密关联，各自在 “有序性” 和 “去重性” 上形成互补。本文将从源码实现入手，解析三者的设计逻辑与适用场景，帮你在开发中精准选型。\n一、LinkedHashMap：HashMap 的 “有序升级版”LinkedHashMap 是 HashMap 的子类，核心优势是支持有序存储，通过维护双向链表记录元素顺序，完美解决了 HashMap”无序” 的痛点。\n1. 底层结构：HashMap + 双向链表LinkedHashMap 的底层由两部分组成：\n\n哈希表：继承自 HashMap 的 “数组 + 链表 + 红黑树” 结构，保证键值对的高效存取；\n\n双向链表：额外维护一条贯穿所有节点的双向链表，记录元素的插入顺序或访问顺序。\n\n\n节点结构在 HashMap 的 Node 基础上新增了两个指针：\nstatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;    Entry&lt;K,V&gt; before, after; // 双向链表指针    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;        super(hash, key, value, next);    &#125;&#125;\n\n2. 核心特性：两种有序模式LinkedHashMap 通过accessOrder属性控制有序性（默认false）：\n\n插入顺序（accessOrder&#x3D;false）：迭代时与元素插入顺序一致，新增元素放在链表尾部。\n\nMap&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;();map.put(&quot;b&quot;, 2);map.put(&quot;a&quot;, 1);map.put(&quot;c&quot;, 3);// 迭代结果：b→a→c（与插入顺序相同）\n\n\n访问顺序（accessOrder&#x3D;true）：调用get、put等方法访问元素后，该元素会被移到链表尾部（最近访问的元素在尾部），天然适配 LRU（最近最少使用）缓存场景。\n\n3. 关键方法：实现 LRU 缓存通过重写removeEldestEntry方法，可自定义 “当新增元素后是否删除最老元素”：\n// 实现容量为3的LRU缓存Map&lt;String, Integer&gt; lruCache = new LinkedHashMap&lt;&gt;(16, 0.75f, true) &#123;    @Override    protected boolean removeEldestEntry(Map.Entry&lt;String, Integer&gt; eldest) &#123;        return size() &gt; 3; // 超过3个元素则删除最老的    &#125;&#125;;\n\n4. 与 HashMap 的核心差异\n\n\n特性\nHashMap\nLinkedHashMap\n\n\n\n有序性\n无序\n支持插入顺序 &#x2F; 访问顺序\n\n\n性能\n插入 &#x2F; 删除略快\n因维护双向链表，迭代效率更高\n\n\n内存占用\n较低\n较高（多维护双向链表指针）\n\n\n二、HashSet：基于 HashMap 的 “去重容器”HashSet 是专门用于元素去重的集合，底层完全依赖 HashMap 实现，可理解为 “只存 key 的 HashMap”。\n1. 底层实现：HashMap 的包装类HashSet 内部持有一个 HashMap 实例，所有操作均通过该 map 完成：\npublic class HashSet&lt;E&gt; &#123;    private transient HashMap&lt;E, Object&gt; map;    private static final Object PRESENT = new Object(); // 固定value    public HashSet() &#123;        map = new HashMap&lt;&gt;();    &#125;    // 添加元素本质是map的put操作    public boolean add(E e) &#123;        return map.put(e, PRESENT) == null; // key存在则返回false    &#125;&#125;\n\n2. 核心特性\n去重规则：与 HashMap 的 key 一致 —— 两个元素hashCode相等且equals返回 true，则视为重复。\n\n无序性：存储顺序与插入顺序无关（同 HashMap 的 key 特性）。\n\n允许 null 元素：但仅能存一个（null 的 hashCode 固定为 0）。\n\n\n3. 基础用法示例Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;apple&quot;);set.add(&quot;banana&quot;);set.add(&quot;apple&quot;); // 重复元素，添加失败System.out.println(set.size()); // 输出2// 遍历（无序）for (String s : set) &#123;    System.out.println(s); // 顺序不确定&#125;\n\n三、LinkedHashSet：HashSet 的 “有序版”LinkedHashSet 是 HashSet 的子类，底层依赖 LinkedHashMap 实现，同时具备去重性和插入顺序性。\n1. 底层实现：LinkedHashMap 的包装类与 HashSet 类似，LinkedHashSet 通过父类构造器初始化 LinkedHashMap：\npublic class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;    public LinkedHashSet() &#123;        // 调用HashSet的构造器，实际创建LinkedHashMap        super(16, 0.75f, true);    &#125;&#125;// HashSet中对应的构造器HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125;\n\n2. 核心特性\n有序性：默认按插入顺序排序（迭代时与插入顺序一致），且顺序不随元素访问变化（区别于 LinkedHashMap 的访问顺序）。\n\n去重性：与 HashSet 一致，依赖 LinkedHashMap 的 key 去重逻辑。\n\n\n3. 用法示例Set&lt;String&gt; linkedSet = new LinkedHashSet&lt;&gt;();linkedSet.add(&quot;b&quot;);linkedSet.add(&quot;a&quot;);linkedSet.add(&quot;c&quot;);// 遍历（按插入顺序）for (String s : linkedSet) &#123;    System.out.println(s); // 输出：b→a→c&#125;\n\n四、三者对比与实战选型1. 核心差异对比表\n\n\n集合类型\n底层依赖\n有序性\n去重性\n典型应用场景\n\n\n\nLinkedHashMap\nHashMap + 双向链表\n插入顺序 &#x2F; 访问顺序\n键唯一\nLRU 缓存、有序映射、历史记录\n\n\nHashSet\nHashMap\n无序\n元素唯一\n标签去重、快速判重\n\n\nLinkedHashSet\nLinkedHashMap\n插入顺序\n元素唯一\n有序去重（如日志记录、流程步骤）\n\n\n2. 实战选型建议\n需要键值对且有序：用 LinkedHashMap（如配置参数按插入顺序输出）。\n\n仅需元素去重且无序：用 HashSet（如用户标签去重）。\n\n需去重且保留插入顺序：用 LinkedHashSet（如接口调用参数记录）。\n\n高频迭代操作：优先选 LinkedHashMap&#x2F;LinkedHashSet（迭代效率更高）。\n\n内存敏感场景：优先选 HashMap&#x2F;HashSet（内存占用更低）。\n\n\n总结LinkedHashMap、HashSet 和 LinkedHashSet 的设计充分体现了 Java 集合框架的 “复用性” 思想：\n\n给 HashMap 加双向链表，得到支持有序的 LinkedHashMap；\n\n封装 HashMap 的 key，得到用于去重的 HashSet；\n\n用 LinkedHashMap 替代 HashMap，得到有序去重的 LinkedHashSet。\n\n\n理解这种 “基于已有实现扩展功能” 的设计思路，不仅能帮你快速掌握 API 用法，更能在实际开发中学会 “站在巨人肩膀上” 设计简洁高效的代码。记住：没有最好的集合，只有最适合场景的选择。\n","categories":["编程语言"],"tags":["JAVA","集合"]},{"title":"MySQL 5.7 字符集设置指南：从乱码根源到彻底解决","url":"/2025/08/14/MySQL-5-7-%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8E%E4%B9%B1%E7%A0%81%E6%A0%B9%E6%BA%90%E5%88%B0%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3/","content":"MySQL 5.7 字符集设置指南：从乱码根源到彻底解决在 MySQL 使用中，“乱码” 是最让人头疼的问题之一 —— 明明输入的是中文，存储后却变成一堆问号或火星文。其实，这大多是字符集设置不当导致的。本文基于 MySQL 5.7 的字符集配置逻辑，教你从根源解决乱码问题，让数据存储和显示始终 “表里如一”。\n一、先搞懂：字符集到底是什么？简单说，字符集是数据库 “认识” 文字的字典。不同的字符集支持不同的文字范围：\n\nlatin1：只支持英文和少数符号，不支持中文；\n\nutf8：支持中文，但 MySQL 5.7 中的utf8是 “阉割版”，最多支持 3 个字节，无法存储 emoji（如😊）或某些生僻字；\n\nutf8mb4：“完整版” utf8，支持 4 个字节，能完美存储中文、emoji 和各种生僻字，是推荐选择。\n\n\n如果数据库的字符集不支持你要存储的文字，就会出现乱码。比如用latin1存储中文，结果必然是问号 “???”。\n二、MySQL 5.7 的字符集 “三层结构”MySQL 5.7 的字符集设置分为三个层级，层层递进，缺一不可：\n\n服务器级：数据库启动时的默认字符集，影响所有新建的数据库；\n\n数据库级：每个数据库可以单独指定字符集，覆盖服务器级设置；\n\n表 &#x2F; 字段级：创建表或字段时可指定字符集，覆盖数据库级设置。\n\n\n举个例子：如果服务器级用latin1，但某数据库单独设置了utf8mb4，那么该数据库的表默认会用utf8mb4。\n三、一步到位：全局字符集配置（推荐）最省心的方式是在配置文件中统一设置字符集，避免层级冲突。\n步骤 1：找到配置文件\nWindows：通常在 MySQL 安装目录的my.ini（如C:\\Program Files\\MySQL\\mysql-5.7\\my.ini）；\n\nLinux：一般在&#x2F;etc&#x2F;my.cnf或&#x2F;etc&#x2F;mysql&#x2F;my.cnf。\n\n\n步骤 2：修改配置参数用文本编辑器打开配置文件，在对应节点添加以下内容：\n# [mysqld] 节点：服务器级字符集[mysqld]character-set-server=utf8mb4  # 服务器默认字符集collation-server=utf8mb4_unicode_ci  # 对应的排序规则（不区分大小写）# [client] 节点：客户端连接时的字符集（避免连接环节乱码）[client]default-character-set=utf8mb4# [mysql] 节点：mysql命令行工具的字符集[mysql]default-character-set=utf8mb4\n\n关键说明：\n\ncollation-server是字符集的 “排序规则”，utf8mb4_unicode_ci支持多语言正确排序，推荐使用；\n\n必须同时配置client和mysql节点，否则客户端连接时可能用默认的latin1，导致 “写入乱码”。\n\n\n步骤 3：重启服务生效# Windows（管理员CMD）net stop mysql57  # 停止服务（mysql57是服务名，需替换）net start mysql57  # 启动服务# Linuxsudo systemctl restart mysqld  # 或 mysql\n\n四、临时调整：数据库 &#x2F; 表级字符集设置如果不想修改全局配置，也可以在创建数据库或表时单独指定字符集。\n1. 创建数据库时指定CREATE DATABASE mydb   CHARACTER SET utf8mb4   COLLATE utf8mb4_unicode_ci;\n\n2. 创建表时指定USE mydb;  # 切换到目标数据库CREATE TABLE user (  id INT,  name VARCHAR(50)) ENGINE=InnoDB   DEFAULT CHARSET=utf8mb4   COLLATE=utf8mb4_unicode_ci;\n\n注意：如果数据库级已设置utf8mb4，表级可以省略，但明确指定更稳妥。\n五、验证字符集设置是否生效配置后，用以下命令检查是否生效：\n\n查看服务器级字符集：\n\nshow variables like &#x27;character_set_server&#x27;;  # 应显示utf8mb4show variables like &#x27;collation_server&#x27;;      # 应显示utf8mb4_unicode_ci\n\n\n查看当前数据库字符集：\n\nuse mydb;show variables like &#x27;character_set_database&#x27;;  # 应显示utf8mb4\n\n\n查看表字符集：\n\nshow create table user;  # 查看表定义，确认CHARSET=utf8mb4\n\n六、常见问题：设置后仍乱码怎么办？\n连接环节的 “隐形坑”\n\n即使服务器和数据库字符集正确，客户端连接时如果用了其他字符集，仍会乱码。解决方法：连接时显式指定字符集：\n# 命令行连接时mysql -u root -p --default-character-set=utf8mb4# 程序中连接（以Python为例）import pymysqlconn = pymysql.connect(  host=&#x27;localhost&#x27;,  user=&#x27;root&#x27;,  password=&#x27;123456&#x27;,  db=&#x27;mydb&#x27;,  charset=&#x27;utf8mb4&#x27;  # 必须指定)\n\n\n已有数据乱码\n\n字符集修改后，新数据会正常存储，但旧的乱码数据需要重新插入。可以先导出数据，修改字符集后再导入。\n七、最佳实践总结\n优先用 utf8mb4：无论是新库还是旧库，都建议统一为utf8mb4，避免未来兼容问题；\n\n全局配置一步到位：修改my.ini&#x2F;my.cnf是最彻底的方式，减少后续维护成本；\n\n连接时显式指定字符集：程序或命令行连接必须带charset&#x3D;utf8mb4，堵住最后一个漏洞；\n\n新建库表时检查字符集：养成创建时显式指定utf8mb4的习惯，避免依赖默认配置。\n\n\n按照这些步骤操作，MySQL 5.7 的字符集问题就能迎刃而解，从此和乱码说再见。\n以上内容涵盖了 MySQL 5.7 字符集设置的关键要点。若你对某些内容有疑问，或想进一步细化某个步骤，欢迎随时告诉我。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 基础：SELECT 语句的核心语法与规范","url":"/2025/08/16/MySQL-%E5%9F%BA%E7%A1%80%EF%BC%9ASELECT-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%A7%84%E8%8C%83/","content":"MySQL 基础：SELECT 语句的核心语法与规范SELECT 语句是 MySQL 中最基础也最常用的查询命令，掌握其语法规则和使用规范，是高效处理数据的第一步。本文将聚焦 SELECT 语句的基本结构、关键规范及实用功能，帮助初学者建立扎实的 SQL 基础。\n一、SELECT 语句的基本语法结构1. 核心语法框架SELECT 语句的最基础结构用于从表中提取指定字段的数据，语法如下：\n-- 选择指定字段SELECT 字段1, 字段2, ... FROM 表名;-- 选择所有字段（不推荐在生产环境使用）SELECT * FROM 表名;\n\n2. 关键说明\nSELECT 后接需要查询的字段名，多个字段用英文逗号分隔；\n\nFROM 后必须指定数据来源的表名，否则会触发语法错误；\n\n语句必须以英文分号 ; 结束，这是 MySQL 语句的通用规则。\n\n\n二、SELECT * 的使用禁忌与替代方案SELECT * 能快速返回表中所有字段，但在实际开发中存在明显弊端，需谨慎使用：\n1. 不推荐使用的原因\n效率低下：会返回无关字段，增加数据库 IO 压力和网络传输成本，尤其对包含大量字段的大表影响显著；\n\n稳定性差：当表结构变更（如新增 &#x2F; 删除字段）时，查询结果会意外包含或丢失数据，可能导致依赖查询结果的应用程序出错；\n\n可读性低：无法直观判断查询的具体字段，不利于代码维护。\n\n\n2. 推荐做法明确指定所需字段，例如：\n-- 推荐：只查询必要字段SELECT id, username, register_time FROM user;-- 不推荐：返回所有字段SELECT id, username, register_time, password, email, phone, ...  -- 字段过多时可换行FROM user;\n\n三、SQL 大小写规范与书写建议MySQL 对大小写的敏感性随操作系统不同而变化，遵循统一规范可避免低级错误：\n1. 大小写规则\nWindows 环境：大小写不敏感（SELECT 与 select 等效）；\n\nLinux 环境：大小写敏感（数据库名、表名、表别名严格区分大小写）。\n\n\n2. 通用书写规范\n关键字（如 SELECT、FROM、WHERE）全部大写；\n\n表名、字段名、别名等全部小写；\n\n多字段或复杂语句分行书写并缩进，提升可读性：\n\n\n-- 规范示例SELECT     id,     product_name,     price FROM     product WHERE     stock &gt; 0;\n\n四、列别名：提升结果可读性的实用技巧列别名用于给查询结果中的字段临时命名，让输出更直观，不影响原表结构。\n1. 语法格式-- 格式1：使用 AS 关键字（推荐，可读性强）SELECT 字段名 AS 别名 FROM 表名;-- 格式2：省略 AS（需在字段名与别名间加空格）SELECT 字段名 别名 FROM 表名;\n\n2. 注意事项\n若别名包含空格、特殊字符（如括号、中文），需用双引号 “ 或反引号 &#96; 包裹：\n\nSELECT     user_id AS &quot;用户 ID&quot;,  -- 别名含空格    order_no `订单编号(2023)`  -- 别名含特殊字符FROM order;\n\n\n别名仅在当前查询结果中生效，不会修改表中实际字段名。\n\n五、去重查询：DISTINCT 关键字的正确用法DISTINCT 用于提取唯一值，消除结果中的重复记录，适用于统计不重复数据的场景。\n1. 基本语法SELECT DISTINCT 字段名 FROM 表名;\n\n2. 关键特性\nDISTINCT 作用于其后的所有字段，而非单个字段。例如 SELECT DISTINCT a, b 会对 a 和 b 的组合去重；\n\n若字段包含 NULL，DISTINCT 会将所有 NULL 视为相同值，仅保留一条。\n\n\n3. 示例-- 对单个字段去重：查询所有不重复的部门 IDSELECT DISTINCT department_id FROM employee;-- 对多个字段去重：查询不重复的&quot;部门-职位&quot;组合SELECT DISTINCT department_id, job_title FROM employee;\n\n六、空值（NULL）的特殊处理规则NULL 表示 “未知值”，与空字符串 “” 完全不同（空字符串长度为 0，NULL 长度未知且占用存储空间），处理方式需特别注意：\n1. 核心规则\n不能用 &#x3D; 或 !&#x3D; 判断 NULL，必须使用 IS NULL（判断为空）或 IS NOT NULL（判断非空）；\n\nNULL 与任何值运算的结果都为 NULL（如 NULL + 1、NULL || ‘abc’ 均返回 NULL）。\n\n\n2. 示例-- 查询未填写邮箱的用户SELECT username FROM user WHERE email IS NULL;-- 查询已填写手机号的用户SELECT username FROM user WHERE phone IS NOT NULL;\n\n七、着重号：解决关键字冲突的必备技巧若表名、字段名与 SQL 关键字（如 order、select）重名，需用反引号 &#96; 包裹，避免语法错误。\n-- 表名是关键字 order，用着重号包裹SELECT * FROM `order`;-- 字段名是关键字 desc，用着重号包裹SELECT `desc` FROM product;\n\n八、常数查询：为结果添加固定标识SELECT 语句支持直接查询常数，在结果中增加固定值列，常用于标记数据来源或整合多数据源。\n1. 应用场景\n区分不同表的查询结果（如多表数据合并时）；\n\n为结果添加业务标识（如数据归属、统计版本）。\n\n\n2. 示例-- 为员工表查询结果添加公司标识SELECT     &#x27;技术部&#x27; AS department,  -- 固定常数列    emp_name,     hire_date FROM employee;\n\n查询结果：\n\n\n\ndepartment\nemp_name\nhire_date\n\n\n\n技术部\n张三\n2023-01-15\n\n\n技术部\n李四\n2023-03-20\n\n\n九、显示表结构：DESCRIBE &#x2F; DESC 命令使用 DESCRIBE 或 DESC 可查看表的字段详情，是分析表结构的常用工具。\n1. 语法-- 完整写法DESCRIBE 表名;-- 简写DESC 表名;\n\n2. 输出字段含义执行 DESC user; 后，输出结果包含以下信息：\n\nField：字段名称；\n\nType：字段数据类型（如 INT、VARCHAR(50)）；\n\nNull：是否允许存储 NULL 值（YES 表示允许）；\n\nKey：索引类型（PRI 为主键，UNI 为唯一索引）；\n\nDefault：字段默认值；\n\nExtra：附加信息（如 AUTO_INCREMENT 表示自增）。\n\n\n十、条件过滤：WHERE 子句的基础用法WHERE 子句用于筛选符合条件的记录，必须紧跟 FROM 子句，是数据过滤的核心工具。\n1. 语法结构SELECT 字段名 FROM 表名 WHERE 条件表达式;\n\n2. 示例-- 查询价格大于 100 且库存大于 0 的商品SELECT name, price FROM product WHERE price &gt; 100 AND stock &gt; 0;-- 查询注册时间在 2023 年的用户SELECT username FROM user WHERE register_time BETWEEN &#x27;2023-01-01&#x27; AND &#x27;2023-12-31&#x27;;\n\n总结：核心要点速览\n避免SELECT *，明确指定需要的字段，提升效率和稳定性；\n\n善用列别名让结果更易读，特殊别名用双引号包裹；\n\nDISTINCT对其后所有字段去重，注意NULL的处理；\n\nNULL需用IS NULL判断，与空字符串不同；\n\n关键字冲突用着重号（&#96;）解决；\n\n常数查询可标记数据来源，DESC用于查看表结构；\n\nWHERE子句紧随FROM，用于筛选符合条件的记录。\n\n\n掌握这些技巧，能让你的 SQL 查询更高效、更易维护，为复杂查询打下坚实基础。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 分页查询：用 LIMIT 高效处理大量数据","url":"/2025/08/19/MySQL-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%EF%BC%9A%E7%94%A8-LIMIT-%E9%AB%98%E6%95%88%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/","content":"MySQL 分页查询：用 LIMIT 高效处理大量数据在实际开发中，当查询结果包含成百上千条记录时，一次性展示所有数据会导致加载缓慢、用户体验差。分页查询能将数据分段展示，既减轻服务器压力，又方便用户浏览。MySQL 中通过LIMIT子句实现分页，本文将详细讲解其用法、原理及实战技巧。\n一、分页的必要性：为什么需要分页？分页查询的核心价值在于高效处理大量数据，主要解决以下问题：\n\n数据过载：一次性返回 10 万条记录会占用大量内存和网络带宽，导致页面卡顿；\n\n用户体验：用户通常只关注前几页数据，分页可聚焦核心内容；\n\n查询效率：数据库无需扫描全表，仅返回指定范围的记录，减少资源消耗。\n\n\n示例场景：\n\n电商平台的商品列表（每页显示 20 条）；\n\n后台系统的用户管理（每页显示 50 条）；\n\n日志查询（按时间分页加载）。\n\n\n二、MySQL 分页核心：LIMIT 子句的用法MySQL 中通过LIMIT子句实现分页，语法简洁且功能灵活，支持指定起始位置和返回条数。\n1. 基本语法结构SELECT 字段1, 字段2, ...FROM 表名[WHERE 条件]  -- 可选，筛选数据[ORDER BY 排序字段]  -- 可选，排序后再分页LIMIT [偏移量,] 行数;  -- 必须放在语句最后\n\n\n参数说明：\n\n\n行数：必填，指定返回的记录条数；\n\n\n\n偏移量：可选，指定从第几条记录开始返回（从 0 开始计数，默认值为 0）；\n\n\n\nMySQL 8.0 支持LIMIT 行数 OFFSET 偏移量（与LIMIT 偏移量, 行数等效，更易读）。\n\n\n\n2. 基础示例：获取指定范围的记录假设employees表有 100 条数据，每页显示 10 条，分页查询示例如下：\n-- 第1页：返回前10条（偏移量0，取10条）SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESC  -- 先排序再分页，确保顺序一致LIMIT 10;  -- 等价于 LIMIT 0, 10-- 第2页：返回11-20条（偏移量10，取10条）SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESCLIMIT 10, 10;  -- 偏移量=10，行数=10-- 第3页：返回21-30条（偏移量20，取10条）SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESCLIMIT 20, 10;-- MySQL 8.0写法（第2页，更直观）SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESCLIMIT 20 OFFSET 10;  -- 行数=20，偏移量=10\n\n3. 通用分页公式：快速计算偏移量当已知 “当前页码” 和 “每页条数” 时，可通过公式快速计算偏移量：\n偏移量 = (当前页码 - 1) × 每页条数\n\n示例：\n\n每页显示 15 条，查询第 5 页数据：\n\nSELECT * FROM productsORDER BY create_time DESCLIMIT (5-1)*15, 15;  -- 偏移量=60，行数=15\n\n三、关键特性与注意事项1. LIMIT 的位置：必须放在语句最后LIMIT是 SQL 语句中最后执行的子句，其执行顺序如下：\n\nFROM：确定数据来源表；\n\nWHERE：筛选符合条件的记录；\n\nORDER BY：对筛选后的记录排序；\n\nLIMIT：从排序后的结果中截取指定范围的记录。\n\n\n\n错误示例：LIMIT放在ORDER BY之前会导致分页基于未排序的数据，结果混乱。\n\n-- 错误：LIMIT位置错误SELECT * FROM employees LIMIT 10 ORDER BY salary DESC;\n\n2. 偏移量的特殊性：从 0 开始计数LIMIT的偏移量从 0 开始（即第一条记录的偏移量为 0），而非 1，这是初学者常犯的错误。\n\n正确：第 1 条记录的偏移量为 0（LIMIT 0,1）；\n\n错误：误认为第 1 条记录的偏移量为 1（LIMIT 1,1会返回第 2 条记录）。\n\n\n3. 提升效率的技巧\n结合排序使用：分页前务必排序（如ORDER BY id DESC），否则每次分页的结果顺序可能不一致；\n\n限制返回行数：若已知结果只有 1 条（如查询唯一用户），用LIMIT 1可让数据库找到结果后立即停止扫描，大幅提升效率：\n\n\n-- 高效：找到1条后立即返回SELECT * FROM users WHERE username = &#x27;admin&#x27; LIMIT 1;\n\n\n避免超大偏移量：当偏移量很大（如LIMIT 100000, 10），查询效率会下降，可通过条件过滤优化：\n\n-- 优化前：偏移量过大SELECT * FROM logs LIMIT 100000, 10;-- 优化后：用索引字段过滤（假设id自增）SELECT * FROM logs WHERE id &gt; 100000 LIMIT 10;\n\n四、跨数据库分页对比：不同数据库的实现方式不同数据库的分页语法不同，迁移时需注意差异：\n\n\n\n数据库\n分页关键字 &#x2F; 语法\n示例（取前 5 条）\n\n\n\nMySQL\nLIMIT\nSELECT * FROM heros LIMIT 5;\n\n\nSQL Server\nTOP\nSELECT TOP 5 * FROM heros;\n\n\nDB2\nFETCH FIRST … ROWS ONLY\nSELECT * FROM heros FETCH FIRST 5 ROWS ONLY;\n\n\nOracle\nROWNUM（需子查询）\nSELECT * FROM (SELECT * FROM heros ORDER BY id) WHERE ROWNUM &lt;&#x3D; 5;\n\n\n五、总结：核心要点速览\n\n\n内容\n关键说明\n\n\n\n基本语法\nLIMIT [偏移量,] 行数 或 LIMIT 行数 OFFSET 偏移量（MySQL 8.0+）\n\n\n分页公式\n偏移量 &#x3D; (当前页码 - 1) × 每页条数，确保分页逻辑正确\n\n\n执行顺序\n放在语句最后，在ORDER BY之后，基于排序后的结果分页\n\n\n效率技巧\n结合排序使用，结果唯一时用LIMIT 1，避免超大偏移量（用条件过滤替代）\n\n\n跨库差异\nMySQL 用LIMIT，SQL Server 用TOP，Oracle 用ROWNUM，迁移时需调整语法\n\n\n掌握LIMIT分页不仅能提升数据展示效率，还能减少服务器负载，是处理大量数据的必备技能。实际开发中，建议结合业务场景合理设置每页条数（通常 10-50 条），并通过排序和索引优化进一步提升查询性能。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 安装避坑指南：服务启动与登录问题全解析","url":"/2025/08/14/MySQL-%E5%AE%89%E8%A3%85%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98%E5%85%A8%E8%A7%A3%E6%9E%90/","content":"MySQL 安装避坑指南：服务启动与登录问题全解析MySQL 作为最流行的关系型数据库之一，安装过程中难免遇到各种问题，尤其是服务启动失败和登录报错，常常让初学者头疼。本文结合实战经验，总结了 MySQL 安装后服务启动与用户登录的常见问题及解决方案，帮你快速排查故障，顺利开启数据库之旅。\n一、服务启动常见问题与解决方法MySQL 安装完成后，首先需要启动服务才能正常使用。服务启动失败是最常见的 “拦路虎”，主要集中在这几个场景：\n1. 服务未安装或安装失败现象：执行net start mysql时提示 “服务名无效”，或安装过程中提示 “服务安装失败”。\n原因：\n\n安装包损坏或权限不足；\n\n之前的 MySQL 服务未彻底卸载，残留注册表信息冲突。\n\n\n解决步骤：\n\n手动安装服务：\n\n以管理员身份打开命令提示符（CMD），进入 MySQL 的bin目录（如C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin），执行：\nmysqld --install [服务名]  # 服务名默认是mysql，可自定义\n\n提示 “Service successfully installed” 即为成功。\n\n彻底卸载残留服务：\n\n\n若提示 “服务已存在”，先删除旧服务：\n\nsc delete mysql  # 删除默认服务名mysql\n\n\n清理注册表：按下Win+R输入regedit，删除HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services中与 MySQL 相关的项。\n\n2. 端口被占用现象：服务启动后立即停止，查看错误日志（data目录下的.err文件）提示 “Port 3306 is already in use”。\n原因：默认端口 3306 被其他程序（如其他 MySQL 实例、Docker 容器）占用。\n解决步骤：\n\n查找占用程序：\n\nnetstat -ano | findstr 3306  # 找到占用3306端口的进程ID（PID）\n\n在任务管理器中结束对应 PID 的进程（若为无关程序）。\n\n修改 MySQL 端口：\n\n打开配置文件my.ini（或my.cnf），在[mysqld]下添加：\nport=3307  # 改为未占用的端口（如3307）\n\n重启服务后，登录时需指定端口：mysql -u root -P 3307 -p。\n3. 配置文件错误现象：服务启动失败，日志提示 “Unknown variable” 或 “Invalid configuration”。\n原因：my.ini配置文件存在语法错误（如拼写错误、参数值格式错误）。\n解决步骤：\n\n检查核心配置：确保[mysqld]下的基础配置正确：\n\nbasedir = C:/Program Files/MySQL/MySQL Server 8.0  # 安装目录（注意用斜杠/）datadir = C:/Program Files/MySQL/MySQL Server 8.0/data  # 数据目录default-character-set = utf8mb4  # 字符集\n\n\n恢复默认配置：若无法定位错误，可删除自定义配置，使用安装包自带的默认my.ini（通常在ProgramData目录下）。\n\n二、用户登录常见错误与解决方案服务启动成功后，登录时可能遇到密码错误、权限不足等问题，以下是高频场景的处理方法：\n1. 密码错误或忘记密码现象：登录提示 “Access denied for user ‘root‘@’localhost‘ (using password: YES)”。\n原因：密码输入错误，或安装时未记录随机密码（MySQL 8.0 + 默认生成随机密码）。\n解决步骤：\n\n重置 root 密码：\n\n\n停止服务：net stop mysql\n\n跳过权限验证启动：\n\n\nmysqld --console --skip-grant-tables --shared-memory\n\n\n新打开一个 CMD 窗口，无密码登录：\n\nmysql -u root  # 直接回车，无需输入密码\n\n\n刷新权限并修改密码（MySQL 8.0 + 语法）：\n\nFLUSH PRIVILEGES;  # 刷新权限ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;新密码&#x27;;  # 新密码需包含大小写、数字和符号\n\n\n重启服务：关闭所有窗口，执行net start mysql，用新密码登录。\n\n2. 主机访问权限限制现象：远程登录提示 “Access denied for user ‘root‘@’192.168.1.100‘ (using password: YES)”。\n原因：默认情况下，root 用户仅允许localhost（本地）登录，未授权远程主机访问。\n解决步骤：\n\n本地登录 MySQL：\n\nmysql -u root -p  # 输入密码登录\n\n\n授权远程访问：\n\n-- 允许root从任意主机登录（生产环境不建议，可指定具体IP如192.168.1.%）CREATE USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;密码&#x27;;  GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; WITH GRANT OPTION;  FLUSH PRIVILEGES;  # 刷新权限\n\n3. 字符集或编码错误现象：登录后执行 SQL 提示 “Illegal mix of collations”，或中文显示乱码。\n原因：客户端与服务器字符集不一致。\n解决步骤：\n\n查看服务器字符集：\n\nSHOW VARIABLES LIKE &#x27;character_set_%&#x27;;\n\n\n统一字符集：在my.ini中添加：\n\n[mysqld]character-set-server = utf8mb4collation-server = utf8mb4_unicode_ci[client]default-character-set = utf8mb4\n\n重启服务后生效。\n三、最佳实践：避免问题的预防措施\n安装时注意事项：\n\n\n选择 “Custom” 自定义安装，明确记录basedir和datadir路径；\n\n若为 MySQL 8.0+，安装后及时记录临时密码（在data目录的.err文件中）。\n\n\n\n配置文件管理：\n\n\n备份my.ini，修改前复制一份副本；\n\n路径使用斜杠&#x2F;而非反斜杠\\（避免转义字符问题）。\n\n\n\n服务与端口管理：\n\n\n定期检查 3306 端口占用情况，避免与其他程序冲突；\n\n非必要不开放 root 用户远程访问，创建专用用户并分配最小权限。\n\n\n\n密码管理：\n\n\n使用强密码（长度≥8 位，包含大小写、数字和特殊符号）；\n\n定期通过ALTER USER命令修改密码，避免明文存储。\n\n\n总结MySQL 服务启动与登录问题多源于配置错误、资源冲突或权限设置，解决的核心是：善用错误日志定位原因，通过规范配置和权限管理预防问题。本文涵盖的场景和方法适用于 MySQL 5.7 和 8.0 版本，遇到问题时先查看data目录下的错误日志（.err文件），大部分故障都能从中找到线索。\n掌握这些技巧后，不仅能快速解决安装后的问题，更能培养排查数据库故障的思路，为后续的 MySQL 学习和使用打下坚实基础。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 基础操作与编码设置：从入门到避坑","url":"/2025/08/16/MySQL-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%81%BF%E5%9D%91/","content":"MySQL 基础操作与编码设置：从入门到避坑掌握 MySQL 的基础操作是使用数据库的第一步，而字符集设置不当导致的乱码问题则是新手常踩的 “坑”。本文从实际操作出发，带你快速上手数据库基本操作，并解决中文存储的常见问题。\n一、MySQL 基础操作：从数据库到表的核心命令1. 查看所有数据库登录 MySQL 后，首先可以查看当前服务器中的所有数据库：\nSHOW DATABASES;\n\n系统默认包含 4 个核心数据库：\n\ninformation_schema：存储数据库元信息（如库名、表名、字段类型等）；\n\nperformance_schema：用于监控数据库性能；\n\nsys：简化性能监控的视图集合；\n\nmysql：存储用户权限、系统配置等核心信息。\n\n\n2. 创建自己的数据库使用create database命令创建自定义数据库，名称需唯一：\n-- 创建名为cyforkkdb的数据库CREATE DATABASE cyforkkdb;\n\n3. 切换到目标数据库对数据库操作前需先指定目标库，使用use命令：\n-- 切换到cyforkkdb数据库USE cyforkkdb;\n\n\n提示：若未执行use命令直接操作表，会报错No database selected。\n\n4. 查看数据库中的表切换到目标库后，查看所有表：\n-- 查看当前数据库的表show tables;SHOW TABLES;-- 查看指定数据库的表（无需切换库） SHOW TABLES FORM 数据库名;\n\n5. 创建数据表使用create table定义表结构，需指定字段名和数据类型：\n-- 创建student表（包含id和name字段）CREATE TABLE student(  id int,  -- 整数类型  name varchar(20)  -- 字符串类型，最长20个字符);\n\n6. 查看表数据新表默认无数据，可通过select命令查看：\n-- 查看student表的所有数据SELECT * FROM student;\n\n7. 插入数据使用insert into添加记录：\n-- 向student表插入两条记录INSERT INTO student VALUES(1, &#x27;张三&#x27;);INSERT INTO student VALUES(2, &#x27;李四&#x27;);\n\n\n注意：若插入中文时出现Incorrect string value错误，大概率是字符集不支持中文，需按后文方法配置。\n\n8. 查看表 &#x2F; 库的创建信息通过show create命令可查看表或数据库的详细配置（包括字符集）：\n-- 查看student表的创建信息（\\G用于格式化输出）SHOW CREATE TABLE student\\G-- 查看cyforkkdb数据库的创建信息SHOW CREATE DATABASE cyforkkdb\\G\n\n9. 删除表和数据库删除操作需谨慎，执行后数据无法恢复：\n-- 删除student表DROP TABLE student;-- 删除atguigudb数据库DROP DATABASE cyforkkdb;\n\n二、字符集设置：解决中文乱码问题1. 问题表现插入中文时提示ERROR 1366 (HY000): Incorrect string value，或查询时显示乱码，本质是字符集不支持中文（默认latin1）。\n2. 查看当前字符集通过以下命令检查字符集配置：\n-- 查看字符集相关变量SHOW VARIABLES LIKE &#x27;character_%&#x27;;SHOW VARIABLES LIKE &#x27;collation_%&#x27;;\n\n3. MySQL 5.7 配置方法步骤 1：修改配置文件my.ini找到安装目录下的my.ini（默认路径：C:\\ProgramData\\MySQL\\MySQL Server 5.7），添加以下配置：\n[mysql]default-character-set=utf8  -- 客户端默认字符集[mysqld]character-set-server=utf8  -- 服务器默认字符集collation-server=utf8_general_ci  -- 服务器默认排序规则\n\n步骤 2：重启服务-- 停止服务（mysql57是服务名）net stop mysql57-- 启动服务net start mysql57\n\n步骤 3：验证配置重新登录后执行show variables like ‘character_%’;，确认character_set_server等参数为utf8。\n4. MySQL 8.0 的优势MySQL 8.0 默认字符集为utf8mb4（支持所有中文、emoji 和生僻字），无需手动配置即可正常存储中文，从根源解决乱码问题。\n5. 已有库 &#x2F; 表的字符集修改若修改配置前已创建库或表，需手动调整：\n-- 修改数据库字符集ALTER DATABASE 数据库名 charset utf8;-- 修改表字符集（仅影响新字段）ALTER TABLE 表名 charset utf8;-- 修改字段字符集（需指定字段类型）ALTER TABLE 表名 MODIFY 字段名 varchar(20) charset utf8;\n\n总结MySQL 基础操作围绕 “库 - 表 - 数据” 三层结构展开，核心命令包括create、use、insert、select等。中文乱码问题的关键是字符集配置，MySQL 5.7 需手动修改my.ini为utf8，而 8.0 默认utf8mb4更省心。掌握这些内容，即可完成日常数据存储与查询需求。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 实战：5 道基础 SELECT 语句练习题解析","url":"/2025/08/19/MySQL-%E5%AE%9E%E6%88%98%EF%BC%9A5-%E9%81%93%E5%9F%BA%E7%A1%80-SELECT-%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/","content":"MySQL 实战：5 道基础 SELECT 语句练习题解析在 MySQL 学习中，实战练习是掌握基础语法的关键。本文通过 5 道经典 SELECT 语句练习题，带你巩固查询操作的核心知识点，从简单查询到条件筛选，逐步提升 SQL 应用能力。\n一、计算员工年薪（算术运算与别名）需求查询员工 12 个月的工资总和，并起别名为ANNUAL SALARY。\n解决方案-- 基础版：仅计算基本工资的年薪SELECT employee_id, last_name, salary * 12 &quot;ANNUAL SALARY&quot;FROM employees;-- 进阶版：包含佣金的年薪（处理NULL值）SELECT employee_id, last_name,        salary * 12 * (1 + IFNULL(commission_pct, 0)) &quot;ANNUAL SALARY&quot;FROM employees;\n\n知识点解析\n算术运算：salary * 12 实现月工资到年薪的转换，* 为乘法运算符；\n\n别名：用双引号 “” 定义别名 ANNUAL SALARY（含空格需加引号）；\n\nNULL 处理：IFNULL(commission_pct, 0) 将佣金率（可能为 NULL）转换为 0，避免因NULL * 数值导致结果为 NULL。\n\n\n二、查询去重的职位 ID（DISTINCT 关键字）需求查询employees表中去除重复的job_id以后的数据。\n解决方案SELECT DISTINCT job_idFROM employees;\n\n知识点解析\nDISTINCT 作用：对其后的字段（此处为job_id）进行去重，仅保留唯一值；\n\n注意：DISTINCT 作用于所有指定字段，若写 SELECT DISTINCT job_id, department_id，则对两个字段的组合去重。\n\n\n三、筛选高工资员工（WHERE 条件过滤）需求查询工资大于 12000 的员工姓名和工资。\n解决方案SELECT last_name, salaryFROM employeesWHERE salary &gt; 12000;\n\n知识点解析\nWHERE 子句：用于筛选符合条件的记录，紧跟FROM子句；\n\n比较运算符：&gt; 表示 “大于”，其他常用比较符有 &lt;、&gt;&#x3D;、&lt;&#x3D;、&#x3D; 等；\n\n性能建议：若salary字段有索引，WHERE salary &gt; 12000可利用索引提升查询效率。\n\n\n四、查询指定员工信息（精确匹配）需求查询员工号为 176 的员工的姓名和部门号。\n解决方案SELECT last_name, department_idFROM employeesWHERE employee_id = 176;\n\n知识点解析\n精确匹配：&#x3D; 用于判断字段值与指定值是否相等（此处employee_id为整数，直接写数值即可）；\n\n主键查询：employee_id通常为主键，主键查询效率极高，因为主键默认是唯一索引。\n\n\n五、查看表结构与全量数据（DESC 与 SELECT *）需求显示表departments的结构，并查询其中的全部数据。\n解决方案-- 显示表结构DESC departments;  -- 或使用 DESCRIBE departments;-- 查询全部数据（仅建议在测试环境使用）SELECT * FROM departments;\n\n知识点解析\nDESC 命令：查看表的字段信息，包括字段名（Field）、类型（Type）、是否允许 NULL（Null）、索引（Key）等；\n\n**SELECT ***：返回表中所有字段的全部记录，缺点是效率低（尤其大表）且结构变更时易出错，生产环境不推荐。\n\n\n总结：基础查询的核心要点\n算术运算：支持+、-、*、&#x2F;，注意用IFNULL处理NULL值；\n\n去重：DISTINCT 用于提取唯一值，作用于其后所有字段；\n\n条件筛选：WHERE 子句结合比较运算符（&gt;、&#x3D;等）实现精准过滤；\n\n表结构查看：DESC 命令快速了解表设计；\n\n别名规范：用双引号定义含特殊字符的别名，提升结果可读性。\n\n\n通过这 5 道题，可掌握 SELECT 语句的基本用法。实际开发中，需根据业务需求灵活组合这些技巧，同时注意查询效率和代码规范性。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 排序操作：用 ORDER BY 让查询结果更有序","url":"/2025/08/19/MySQL-%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%EF%BC%9A%E7%94%A8-ORDER-BY-%E8%AE%A9%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%9B%B4%E6%9C%89%E5%BA%8F/","content":"MySQL 排序操作：用 ORDER BY 让查询结果更有序在数据查询中，无序的结果往往难以分析 —— 比如查看员工薪资时，无序的数字无法快速找到最高或最低值。ORDER BY子句是 MySQL 中实现结果排序的核心工具，能让数据按指定规则有序展示。本文将详细讲解其用法、规则及实战技巧。\n一、排序基础：ORDER BY 的核心规则ORDER BY的作用是对查询结果按指定字段进行排序，其基本语法和核心规则如下：\n1. 基本语法结构SELECT 字段1, 字段2, ...FROM 表名[WHERE 过滤条件]  -- 可选，先筛选再排序ORDER BY 排序字段1 [ASC|DESC], 排序字段2 [ASC|DESC] ...;  -- 必须放在语句结尾\n\n2. 关键规则\n排序方向：\n\n\nASC（ascend）：升序排列（默认，可省略），即从最小值到最大值（如 1→2→3，a→b→c）；\n\n\n\nDESC（descend）：降序排列，即从最大值到最小值（如 3→2→1，c→b→a）。\n\n\n位置要求：ORDER BY必须放在SELECT语句的最后，在WHERE、FROM之后，若有LIMIT则在LIMIT之前。\n\n排序依据：可基于表中字段、计算字段（如salary*12）或别名进行排序。\n\n\n二、单列排序：按单个字段整理数据单列排序是最常用的排序方式，适用于按单一维度（如时间、价格、姓名）整理结果。\n1. 升序排序（默认 ASC）当不指定ASC或DESC时，默认按升序排列。\n示例：按员工入职时间升序排列（最早入职的在前）\nSELECT last_name, job_id, department_id, hire_dateFROM employeesORDER BY hire_date;  -- 等价于 ORDER BY hire_date ASC\n\n2. 降序排序（DESC）需显式指定DESC，适用于需要从大到小展示的场景（如薪资、销量）。\n示例：按员工入职时间降序排列（最新入职的在前）\nSELECT last_name, job_id, department_id, hire_dateFROM employeesORDER BY hire_date DESC;\n\n3. 按计算字段或别名排序排序依据可以是计算得到的字段（如年薪 &#x3D; 月薪 ×12），或字段的别名。\n示例：按员工年薪（月薪 ×12）升序排列\n-- 方法1：按计算字段排序SELECT employee_id, last_name, salary*12FROM employeesORDER BY salary*12;-- 方法2：按别名排序（更简洁，推荐）SELECT employee_id, last_name, salary*12 AS annsal  -- 别名annsal表示年薪FROM employeesORDER BY annsal;  -- 直接使用别名排序\n\n三、多列排序：按多个维度组合排序当单一字段无法满足排序需求时（如先按部门分组，再按部门内薪资排序），可使用多列排序。\n1. 基本语法与规则SELECT 字段1, 字段2, ...FROM 表名ORDER BY 字段A [DESC], 字段B [ASC];  -- 先按字段A排序，再按字段B排序\n\n核心规则：\n\n排序优先级：先按第一个字段（字段 A）排序；\n\n仅当第一个字段存在相同值时，才会按第二个字段（字段 B）排序；\n\n若第一个字段的所有值都是唯一的，第二个字段的排序规则会被忽略。\n\n\n2. 实战示例需求：查询员工信息，先按部门 ID 升序排列，同一部门内按薪资降序排列（高薪在前）。\nSELECT last_name, department_id, salaryFROM employeesORDER BY department_id ASC, salary DESC;  -- 先部门升序，再薪资降序\n\n执行逻辑：\n\n所有员工先按department_id从小到大排序（如部门 10→20→30）；\n\n对于department_id相同的员工（如都在部门 30），再按salary从大到小排序。\n\n\n3. 特殊用法：使用未查询的字段排序ORDER BY支持使用不在 SELECT 列表中的字段进行排序，不影响结果展示但需确保字段存在。\n示例：查询员工姓名和薪资，按部门 ID 升序排序（部门 ID 不显示在结果中）\nSELECT last_name, salaryFROM employeesORDER BY department_id;  -- 用未查询的department_id排序，结果仍只显示name和salary\n\n四、SQL 执行顺序：为什么 ORDER BY 要放在最后？理解 SQL 的执行顺序，能帮助你更好地掌握ORDER BY的用法：\n\n先执行FROM：确定数据来源的表；\n\n再执行WHERE：筛选出符合条件的记录；\n\n然后执行SELECT：提取需要的字段（或计算字段）；\n\n接着执行ORDER BY：对提取的结果进行排序；\n\n最后执行LIMIT（若有）：截取排序后的部分记录。\n\n\n\n关键结论：ORDER BY是对WHERE筛选后的结果进行排序，且必须放在语句最后，确保排序的是最终需要展示的数据。\n\n五、实用技巧与注意事项\n排序字段加索引：对ORDER BY的字段建立索引（如CREATE INDEX idx_hire_date ON employees(hire_date)），可大幅提升排序效率，尤其对大表查询；\n\n避免无意义排序：若结果无需有序展示（如随机取 10 条数据），可省略ORDER BY，减少数据库开销；\n\n多列排序的字段顺序：将区分度高的字段放在前面（如大多数值唯一的字段），可减少后续字段的排序压力；\n\n字符排序规则：字符串排序基于字符的 ASCII 码（如大写字母在小写字母前），若需按中文拼音排序，需确保字段编码为utf8mb4_general_ci等支持中文排序的格式。\n\n\n总结：核心要点速览\n\n\n分类\n关键内容\n示例代码\n\n\n\n基本规则\n用ORDER BY排序，ASC升序（默认），DESC降序，放在语句最后\nORDER BY salary DESC\n\n\n单列排序\n可按字段、计算字段或别名排序\nORDER BY salary*12 或 ORDER BY annsal\n\n\n多列排序\n先按第一个字段排序，相同值时再按第二个字段排序，支持未查询字段\nORDER BY department_id ASC, salary DESC\n\n\n执行顺序\n在FROM、WHERE、SELECT之后，LIMIT之前\n-\n\n\n效率建议\n排序字段加索引，避免不必要的排序，合理安排多列排序的字段顺序\n-\n\n\n掌握ORDER BY的用法，能让你的查询结果从 “杂乱无章” 变为 “井然有序”，显著提升数据可读性和分析效率。实际开发中，需根据业务场景选择合适的排序方式，并注意索引优化以应对大数据量查询。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 排序与分页实战：3 道经典练习题解析","url":"/2025/08/18/MySQL-%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5%E5%AE%9E%E6%88%98%EF%BC%9A3-%E9%81%93%E7%BB%8F%E5%85%B8%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/","content":"MySQL 排序与分页实战：3 道经典练习题解析排序（ORDER BY）和分页（LIMIT）是 MySQL 查询中处理结果集的核心操作，常用于数据展示、报表生成等场景。本文通过 3 道实战练习题，详解排序与分页的组合用法，帮你掌握复杂结果集的处理技巧。\n一、多条件排序：按年薪和姓名组合排序题目 1查询员工的姓名、部门号和年薪，按年薪降序、姓名升序显示。\n解决方案SELECT   last_name,   department_id,   salary * 12 AS annual_sal  -- 计算年薪并起别名FROM employeesORDER BY annual_sal DESC,  -- 先按年薪降序（高薪在前）         last_name ASC;    -- 年薪相同时按姓名升序（A-Z）\n\n知识点解析\n计算字段与别名：salary * 12 计算年薪，用 AS 定义别名 annual_sal，简化排序条件；\n\n多列排序规则：\n\n\n\n\n先按第一个字段（annual_sal）排序，DESC 表示降序；\n\n\n\n当第一个字段值相同时，再按第二个字段（last_name）排序，ASC 表示升序（默认可省略）；\n\n\n\n\n排序依据：支持使用计算字段或别名排序，无需重复写计算逻辑（如直接用 annual_sal 而非 salary*12）。\n\n二、条件筛选 + 排序 + 分页：精准提取指定范围数据题目 2选择工资不在 8000 到 17000 的员工的姓名和工资，按工资降序，显示第 21 到 40 位置的数据。\n解决方案SELECT   last_name,   salaryFROM employeesWHERE salary NOT BETWEEN 8000 AND 17000  -- 筛选工资不在8000-17000的员工ORDER BY salary DESC  -- 按工资降序排序LIMIT 20, 20;  -- 从第21条开始（偏移量20），取20条（21-40）\n\n知识点解析\n范围筛选：NOT BETWEEN 8000 AND 17000 等价于 salary &lt; 8000 OR salary &gt; 17000，用于排除指定区间的数据；\n\n分页逻辑：\n\n\n\n\nLIMIT 偏移量, 行数 中，偏移量从 0 开始计数；\n\n\n\n第 21 到 40 条记录：偏移量 &#x3D; 20（前 20 条跳过），行数 &#x3D; 20（取 20 条）；\n\n\n\n\n执行顺序：先筛选（WHERE）、再排序（ORDER BY）、最后分页（LIMIT），确保分页基于筛选后的有序结果。\n\n三、函数 + 排序：按字段长度排序题目 3查询邮箱中包含字母e的员工信息，先按邮箱的字节数降序，再按部门号升序。\n解决方案SELECT   last_name,   email,   department_idFROM employeesWHERE email REGEXP &#x27;[e]&#x27;  -- 筛选邮箱包含e的员工（等价于 LIKE &#x27;%e%&#x27;）ORDER BY LENGTH(email) DESC,  -- 按邮箱字节数降序（长邮箱在前）         department_id ASC;   -- 字节数相同时按部门号升序\n\n知识点解析\n模糊筛选：\n\n\n\nemail REGEXP ‘[e]’ 与 email LIKE ‘%e%’ 功能相同，均匹配包含e的邮箱；\n\n\n\nREGEXP 支持更复杂的正则匹配，LIKE 适合简单通配符场景；\n\n\n\n\n字符串长度函数：LENGTH(email) 计算邮箱的字节数（注意：中文在不同编码下字节数可能不同，此处针对英文邮箱）；\n\n多维度排序：先按 “邮箱长度” 这一动态计算值排序，再按 “部门号” 这一字段排序，满足复杂业务需求。\n\n\n总结：排序与分页核心要点\n\n\n操作场景\n关键语法 &#x2F; 函数\n注意事项\n\n\n\n多列排序\nORDER BY 字段1 DESC, 字段2\n先按字段 1 排序，值相同时再按字段 2 排序\n\n\n分页查询\nLIMIT 偏移量, 行数\n偏移量从 0 开始，需结合ORDER BY确保顺序\n\n\n范围筛选\nBETWEEN…AND&#x2F;NOT BETWEEN\n闭区间包含边界值，反向筛选用NOT\n\n\n字符串长度计算\nLENGTH(字段)\n返回字节数，适合英文等单字节字符\n\n\n模糊匹配\nLIKE ‘%e%’&#x2F;REGEXP ‘[e]’\n简单场景用LIKE，复杂模式用REGEXP\n\n\n通过这 3 道题可以看出，排序与分页很少单独使用，通常需结合条件筛选、函数计算等操作。掌握它们的组合逻辑，能帮你高效处理各类结果集展示需求，无论是前端列表分页还是后台数据导出，都能应对自如。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 运算符实战：9 道经典练习题解析","url":"/2025/08/18/MySQL-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E6%88%98%EF%BC%9A9-%E9%81%93%E7%BB%8F%E5%85%B8%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/","content":"MySQL 运算符实战：9 道经典练习题解析运算符是 MySQL 查询的 “灵魂”，灵活运用各类运算符能让数据筛选更加精准高效。本文通过 9 道实战练习题，详解逻辑运算符、比较运算符及模糊匹配的用法，帮你快速掌握运算符的核心应用场景。\n一、范围查询：NOT BETWEEN 与 OR 的灵活运用题目 1：选择工资不在 5000 到 12000 的员工的姓名和工资解决方案-- 方法1：使用OR逻辑运算符SELECT last_name, salaryFROM employeesWHERE salary &lt; 5000 OR salary &gt; 12000;-- 方法2：使用NOT BETWEEN（更简洁）SELECT last_name, salaryFROM employeesWHERE salary NOT BETWEEN 5000 AND 12000;\n\n知识点解析\nBETWEEN AND：表示闭区间范围（包含边界值），salary BETWEEN 5000 AND 12000 等价于 salary &gt;&#x3D; 5000 AND salary &lt;&#x3D; 12000；\n\nNOT 取反：NOT BETWEEN 直接排除范围内的数据，比 OR 更简洁，可读性更高；\n\n适用场景：连续范围的反向筛选，优先用 NOT BETWEEN。\n\n\n二、集合查询：IN 与 OR 的效率对比题目 2：选择在 20 或 50 号部门工作的员工姓名和部门号解决方案-- 方法1：使用OR逻辑运算符SELECT last_name, department_idFROM employeesWHERE department_id = 20 OR department_id = 50;-- 方法2：使用IN集合运算符（推荐）SELECT last_name, department_idFROM employeesWHERE department_id IN (20, 50);\n\n知识点解析\nIN 运算符：用于匹配离散的多个值，IN (20,50) 等价于 &#x3D;20 OR &#x3D;50，但代码更简洁；\n\n性能优势：当集合元素较多（如 10 个以上），IN 的执行效率通常高于多个 OR 拼接；\n\n注意：IN 列表中若包含 NULL，不会影响非 NULL 值的匹配，但结果可能包含 NULL。\n\n\n三、NULL 值处理：IS NULL 与 IS NOT NULL题目 3：选择公司中没有管理者的员工姓名及 job_id解决方案SELECT last_name, job_idFROM employeesWHERE manager_id IS NULL;\n\n题目 4：选择公司中有奖金的员工姓名、工资和奖金级别解决方案SELECT last_name, salary, commission_pctFROM employeesWHERE commission_pct IS NOT NULL;\n\n知识点解析\nNULL 的特殊性：NULL 表示 “未知值”，不能用 &#x3D; 或 !&#x3D; 判断，必须用 IS NULL（为空）或 IS NOT NULL（非空）；\n\n应用场景：判断字段是否未填写（如管理者 ID、奖金比例），避免因 NULL 导致的筛选遗漏；\n\n注意：IFNULL(commission_pct, 0) 可将 NULL 转换为 0（如计算年薪时），但筛选时仍需用 IS NOT NULL。\n\n\n四、模糊匹配：LIKE 通配符的精准用法题目 5：选择员工姓名的第三个字母是 a 的员工姓名解决方案SELECT last_nameFROM employeesWHERE last_name LIKE &#x27;__a%&#x27;;\n\n解析\nLIKE 通配符：_ 匹配单个任意字符，% 匹配 0 个或多个任意字符；\n\n模式说明：a% 表示前两个字符任意，第三个字符为a，后续字符不限（ 对应两个位置）。\n\n\n题目 6：选择姓名中有字母 a 和 k 的员工姓名解决方案SELECT last_nameFROM employeesWHERE last_name LIKE &#x27;%a%k%&#x27; OR last_name LIKE &#x27;%k%a%&#x27;;\n\n解析\n多条件模糊匹配：需考虑两种顺序（a在前k在后或k在前a在后），用 OR 连接；\n\n注意：% 可匹配任意长度字符（包括 0），确保不遗漏包含两个字符的所有情况。\n\n\n题目 7：显示表 employees 中 first_name 以 ‘e’ 结尾的员工信息解决方案-- 方法1：使用LIKESELECT employee_id, first_name, last_nameFROM employeesWHERE first_name LIKE &#x27;%e&#x27;;-- 方法2：使用REGEXP正则（更灵活）SELECT employee_id, first_name, last_nameFROM employeesWHERE first_name REGEXP &#x27;e$&#x27;;\n\n解析\n结尾匹配：%e 表示以e结尾（LIKE），e$ 表示以e结尾（REGEXP正则）；\n\nREGEXP 优势：支持更复杂的模式（如多字符结尾），适合高级字符串匹配。\n\n\n五、区间与集合综合运用题目 8：显示表 employees 部门编号在 80-100 之间的姓名、工种解决方案SELECT last_name, job_idFROM employeesWHERE department_id BETWEEN 80 AND 100;\n\n解析\n连续区间优选 BETWEEN：BETWEEN 80 AND 100 等价于 &gt;&#x3D;80 AND &lt;&#x3D;100，代码更简洁；\n\n注意：区间包含边界值（80 和 100），若需排除边界需用 &gt; 和 &lt;。\n\n\n题目 9：显示表 employees 的 manager_id 是 100、101、110 的员工姓名、工资、管理者 id解决方案SELECT last_name, salary, manager_idFROM employeesWHERE manager_id IN (100, 101, 110);\n\n解析\n离散值集合用 IN：IN (100,101,110) 清晰表达 “属于指定集合”，比 &#x3D;100 OR &#x3D;101 OR &#x3D;110 更易读；\n\n扩展：若集合元素来自子查询，可写成 IN (SELECT …)，实现动态匹配。\n\n\n总结：运算符核心用法速查表\n\n\n运算符 &#x2F; 语法\n作用\n典型场景\n\n\n\nBETWEEN A AND B\n匹配 A 到 B 的闭区间\n工资、年龄等连续范围查询\n\n\nNOT BETWEEN\n排除 A 到 B 的区间\n反向范围筛选\n\n\nIN (值1,值2…)\n匹配离散集合中的值\n部门 ID、管理者 ID 等固定选项\n\n\nIS NULL\n判断字段为空\n查找未分配管理者、无奖金的记录\n\n\nIS NOT NULL\n判断字段非空\n查找有奖金、已填写信息的记录\n\n\nLIKE ‘%a%’\n模糊匹配包含 a 的字符串\n姓名、职位等包含特定字符的查询\n\n\nLIKE ‘__a%’\n匹配第三个字符为 a 的字符串\n固定位置字符匹配\n\n\nREGEXP ‘e$’\n正则匹配以 e 结尾的字符串\n复杂模式的字符串匹配\n\n\n通过这 9 道题，可掌握运算符在实际场景中的灵活应用。记住：优先用 IN 替代多 OR、用 BETWEEN 简化连续范围、用 IS NULL 处理空值，能让你的 SQL 更简洁高效。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"SQL 概述与分类：零基础也能懂的核心知识","url":"/2025/08/14/SQL-%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%88%86%E7%B1%BB%EF%BC%9A%E9%9B%B6%E5%9F%BA%E7%A1%80%E4%B9%9F%E8%83%BD%E6%87%82%E7%9A%84%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/","content":"SQL 概述与分类：零基础也能懂的核心知识无论学习哪种数据库（MySQL、Oracle、SQL Server），SQL 都是绕不开的基础。它是操作数据库的 “通用语言”，掌握其核心概念和分类，能让你在写代码时思路更清晰。本文用最简单的语言讲解 SQL 的本质和分类，新手也能快速入门。\n一、什么是 SQL？一句话讲明白SQL（Structured Query Language，结构化查询语言）是一种专门用来操作数据库的编程语言。它的作用就像 “数据库的遥控器”—— 通过简单的命令，你可以让数据库执行 “查数据”“存数据”“建表”“改权限” 等操作。\nSQL 的 3 个核心特点：\n标准化：几乎所有数据库（MySQL、Oracle 等）都支持 SQL，学会一种，其他数据库的 SQL 用法也大同小异。\n\n非过程化：你只需要告诉数据库 “要做什么”（比如 “查所有学生的名字”），不用管 “怎么做”（数据库会自己优化执行步骤）。\n\n简单易学：基本命令都是英文单词（如SELECT“查询”、INSERT“插入”），逻辑和日常语言接近。\n\n\n二、SQL 分类：5 大类命令，各司其职根据功能不同，SQL 可以分为 5 大类。记住每类的核心命令和作用，写 SQL 时就不会 “无从下手”。\n1. 数据查询语言（DQL）：查数据的 “放大镜”作用：从数据库中查询数据（最常用的一类命令）。\n核心命令：SELECT（唯一命令，但用法灵活）。\n示例：\n-- 从student表中查询所有学生的姓名和年龄SELECT name, age FROM student;-- 查询年龄大于18的学生SELECT * FROM student WHERE age &gt; 18;\n\n2. 数据操纵语言（DML）：改数据的 “编辑工具”作用：对表中的数据进行 “增删改”（不改变表结构，只改内容）。\n核心命令：INSERT（新增）、UPDATE（修改）、DELETE（删除）。\n示例：\n-- 新增一条学生数据INSERT INTO student (name, age) VALUES (&#x27;张三&#x27;, 20);-- 修改张三的年龄为21UPDATE student SET age = 21 WHERE name = &#x27;张三&#x27;;-- 删除年龄小于18的学生DELETE FROM student WHERE age &lt; 18;\n\n3. 数据定义语言（DDL）：建结构的 “建筑师”作用：创建、修改、删除数据库或表的结构（比如建表、删库、改字段类型）。\n核心命令：CREATE（创建）、ALTER（修改）、DROP（删除）。\n示例：\n-- 创建名为school的数据库CREATE DATABASE school;-- 在school库中创建student表（包含id和name字段）CREATE TABLE student (  id INT,  name VARCHAR(20));-- 给student表增加age字段ALTER TABLE student ADD age INT;-- 删除student表（谨慎使用！数据会丢失）DROP TABLE student;\n\n4. 数据控制语言（DCL）：管权限的 “保安”作用：控制用户对数据库的操作权限（比如 “允许张三查 student 表，不允许他删表”）。\n核心命令：GRANT（授权）、REVOKE（收回权限）。\n示例：\n-- 允许用户zhangsan查询student表GRANT SELECT ON school.student TO &#x27;zhangsan&#x27;@&#x27;localhost&#x27;;-- 收回zhangsan查询student表的权限REVOKE SELECT ON school.student FROM &#x27;zhangsan&#x27;@&#x27;localhost&#x27;;\n\n5. 事务控制语言（TCL）：保安全的 “后悔药”作用：管理数据库事务（确保一组操作要么全成功，要么全失败，比如转账时 “扣钱” 和 “加钱” 必须同时成功）。\n核心命令：COMMIT（提交事务）、ROLLBACK（回滚事务，即 “撤销操作”）。\n示例：\n-- 开启事务（MySQL默认自动提交，需手动关闭）SET autocommit = 0;-- 执行转账操作（扣A的钱，加B的钱）UPDATE account SET money = money - 100 WHERE name = &#x27;A&#x27;;UPDATE account SET money = money + 100 WHERE name = &#x27;B&#x27;;-- 确认操作无误，提交事务（数据永久生效）COMMIT;-- 若操作出错，回滚事务（恢复到操作前的状态）ROLLBACK;\n\n三、总结：记分类，更要会用SQL 分类的核心是 “按功能记命令”：\n\n查数据 → 想SELECT（DQL）；\n\n改数据内容 → 想INSERT&#x2F;UPDATE&#x2F;DELETE（DML）；\n\n改表 &#x2F; 库结构 → 想CREATE&#x2F;ALTER&#x2F;DROP（DDL）；\n\n管权限 → 想GRANT&#x2F;REVOKE（DCL）；\n\n保证操作安全 → 想COMMIT&#x2F;ROLLBACK（TCL）。\n\n\n掌握这些分类，后续学习复杂 SQL 时会更有条理。下一篇我们会深入讲解最常用的 DQL（查询命令），带你搞定各种数据查询场景。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"Windows 端口占用解决指南：如何找到并杀死占用端口的进程","url":"/2026/01/07/Windows%20%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E6%8C%87%E5%8D%97%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%B9%B6%E6%9D%80%E6%AD%BB%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B/","content":"Windows 端口占用解决指南：如何找到并杀死占用端口的进程在使用开发工具或运行服务器时，你可能遇到过这样的错误：”Port 4000 has been used”（端口 4000 已被占用）。这意味着该端口已被其他程序占用，导致你的服务无法正常启动。本文将详细介绍如何在 Windows 系统中找到并杀死占用特定端口的进程。\n一、问题现象当你尝试启动服务（如 Hexo 本地服务器）时，可能会看到类似以下错误：\nFATAL Port 4000 has been used. Try other port instead.Error: listen EADDRINUSE: address already in use :::4000\n\n这表明端口 4000 已被其他进程占用，你需要找到并终止该进程，或者使用其他端口（如 hexo s -p 4001）。\n二、解决方法方法一：使用命令行解决（推荐）这是最常用、最有效的方法，适用于所有 Windows 版本。\n步骤 1：打开命令提示符按下 Win + R 键，输入 cmd，然后按下 Enter 键，打开命令提示符窗口。\n步骤 2：查找占用端口的进程输入以下命令，替换 4000 为你要查询的端口号：\nnetstat -ano | findstr :4000\n\n注意：命令中 : 和端口号之间不能有空格！\n执行命令后，你会看到类似以下输出：\nTCP    0.0.0.0:4000           0.0.0.0:0              LISTENING       51160TCP    [::]:4000              [::]:0                 LISTENING       51160\n\n最后一列的数字 51160 就是占用该端口的进程 ID（PID）。\n步骤 3：查看进程信息（可选）如果你想知道这个进程是什么程序，可以输入以下命令，替换 51160 为你的进程 ID：\ntasklist | findstr 51160\n\n执行命令后，你会看到类似以下输出：\nnode.exe                     51160 Console                    1    123,456 K\n\n这表明是 node.exe 进程占用了端口 4000，通常是 Node.js 应用程序。\n步骤 4：杀死占用端口的进程输入以下命令，替换 51160 为你的进程 ID：\ntaskkill /PID 51160 /F\n\n\n/PID：指定进程 ID\n/F：强制终止进程\n\n执行命令后，你会看到类似以下输出：\n成功: 已终止 PID 为 51160 的进程。\n\n现在端口 4000 已经被释放，你可以重新启动你的服务了。\n方法二：使用任务管理器解决如果你不喜欢使用命令行，也可以通过任务管理器来解决。\n步骤 1：打开任务管理器按下 Ctrl + Shift + Esc 键，打开任务管理器。\n步骤 2：显示 PID 列点击任务管理器顶部的 详细信息 选项卡，然后点击 视图 → 选择列，勾选 PID (进程标识符)，然后点击 确定。\n步骤 3：找到并终止进程在详细信息列表中，找到你通过命令行获取到的进程 ID，右键点击该进程，然后选择 结束任务。\n三、常见问题问题 1：命令执行失败如果执行 netstat -ano | findstr :4000 命令时出现以下错误：\nFINDSTR: 无法打开 4000\n\n这是因为你在 : 和端口号之间添加了空格！正确的命令是 netstat -ano | findstr :4000（注意 : 和 4000 之间没有空格）。\n问题 2：没有权限终止进程如果执行 taskkill /PID 51160 /F 命令时出现权限不足的错误，可以尝试以管理员身份运行命令提示符：\n\n按下 Win + X 键，选择 Windows PowerShell (管理员)\n在管理员权限的命令提示符中重新执行命令\n\n四、预防措施\n使用固定端口：为不同的服务分配固定的端口，避免端口冲突\n正确关闭服务：使用 Ctrl + C 等正确方式关闭服务，避免进程异常退出\n定期清理进程：定期检查并关闭不需要的进程\n使用端口管理工具：可以使用一些端口管理工具，如 TCPView，更方便地管理端口\n\n五、总结遇到端口占用问题时，使用命令行方法是最快捷、最有效的解决方式。只需要简单的几个步骤，就能找到并杀死占用端口的进程：\n\nnetstat -ano | findstr :端口号 - 查找占用端口的进程 ID\ntaskkill /PID 进程ID /F - 强制终止该进程\n\n希望本文能帮助你解决 Windows 端口占用问题，让你的开发工作更加顺畅！\n","categories":["计算机"],"tags":["Windows","命令行","端口管理"]},{"title":"MySQL 运算符详解：逻辑、位运算与正则表达式应用","url":"/2025/08/18/MySQL-%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%80%BB%E8%BE%91%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E7%94%A8/","content":"MySQL 运算符详解：逻辑、位运算与正则表达式应用在 MySQL 中，运算符是构建复杂查询条件的基础。除了基础的算术和比较运算符，逻辑运算符、位运算符以及正则表达式的灵活运用，能让数据筛选更加精准高效。本文将系统讲解这些运算符的用法、规则及实战技巧，帮助你掌握复杂查询的核心技能。\n一、逻辑运算符：多条件组合的核心逻辑运算符用于组合多个条件，判断表达式的真假，返回结果为1（真）、0（假）或NULL（未知）。常用的有四种：\n1. 逻辑非（NOT &#x2F; !）作用：对条件结果取反\n语法：NOT 条件 或 ! 条件\n规则：\n\n条件为0（假）时返回1；\n\n条件为非0（真）时返回0；\n\n条件为NULL时返回NULL。\n\n\n示例：\n-- 查询薪资不在9000-12000之间的员工SELECT employee_id, salary FROM employees WHERE NOT (salary &gt;= 9000 AND salary &lt;= 12000);\n\n2. 逻辑与（AND &#x2F; &amp;&amp;）作用：所有条件同时为真时返回1\n语法：条件1 AND 条件2 或 条件1 &amp;&amp; 条件2\n规则：\n\n所有条件非0且非NULL时返回1；\n\n任意条件为0时返回0；\n\n存在NULL且无0时返回NULL。\n\n\n示例：\n-- 查询部门30中薪资&gt;5000的员工SELECT last_name, salary FROM employees WHERE department_id = 30 AND salary &gt; 5000;\n\n3. 逻辑或（OR &#x2F; ||）作用：任意条件为真时返回1\n语法：条件1 OR 条件2 或 条件1 || 条件2\n规则：\n\n任意条件非0时返回1；\n\n所有条件为0时返回0；\n\n存在NULL且无真条件时返回NULL。\n\n\n注意：AND优先级高于OR，建议用括号明确逻辑\n示例：\n-- 正确：查询薪资&gt;10000 或 （岗位含MAN且薪资&gt;5000）的员工SELECT last_name, job_id, salary FROM employees WHERE salary &gt; 10000 OR (job_id LIKE &#x27;%MAN%&#x27; AND salary &gt; 5000);\n\n4. 逻辑异或（XOR）作用：两个条件一真一假时返回1（“异” 即不同）\n语法：条件1 XOR 条件2\n规则：\n\n一真一假（非0和0）时返回1；\n\n同真或同假时返回0；\n\n任意条件为NULL时返回NULL。\n\n\n示例：\n-- 查询部门为10/20 或 薪资&gt;8000，但不同时满足的员工SELECT last_name, department_id, salary FROM employees WHERE department_id IN (10, 20) XOR salary &gt; 8000;\n\n二、位运算符：二进制层面的运算位运算符直接对数值的二进制位进行操作，适用于底层数据处理（如权限控制）。运算时先将数值转为二进制，计算后再转回十进制。\n\n\n\n运算符\n名称\n作用说明\n示例（6→110，3→011）\n\n\n\n&amp;\n按位与\n对应位都为 1 则返回 1，否则 0\n6 &amp; 3 &#x3D; 2（110 &amp; 011&#x3D;010）\n\n\n|\n|\n按位或\n对应位有一个为 1 则返回 1，否则 0\n\n\n^\n按位异或\n对应位不同则返回 1，相同则 0\n6 ^ 3 &#x3D; 5（110 ^ 011&#x3D;101）\n\n\n~\n按位取反\n0→1，1→0（结果为原数的补码）\n~6 &#x3D; -7（补码运算）\n\n\n&gt;&gt;\n按位右移\n二进制位右移指定位数，高位补 0\n6 &gt;&gt; 1 &#x3D; 3（110→11）\n\n\n&lt;&lt;\n按位左移\n二进制位左移指定位数，低位补 0\n6 &lt;&lt; 1 &#x3D; 12（110→1100）\n\n\n示例：\n-- 判断权限位是否包含某角色（假设8对应二进制1000，代表管理员权限）SELECT user_id, role_bits FROM users WHERE (role_bits &amp; 8) = 8;  -- 结果为8表示包含管理员权限\n\n三、运算符优先级：避免逻辑混乱运算符优先级决定计算顺序，优先级高的先执行。记不清时，用括号**()**强制指定顺序（推荐）。\n优先级从高到低（核心）：\n\n括号()（最高）\n\n位运算符（~、&lt;&lt;、&gt;&gt;、&amp;、^、|）\n\n算术运算符（*、&#x2F;、% 高于 +、-）\n\n比较运算符（&#x3D;、&gt;、BETWEEN、IN等）\n\n逻辑运算符（NOT &gt; AND &gt; OR、XOR）\n\n赋值运算符（&#x3D;，最低）\n\n\n示例：\n-- 错误：因AND优先级高，可能不符合预期SELECT * FROM employees WHERE salary&gt;5000 OR salary&lt;3000 AND department_id=30;-- 正确：用括号明确先算OR的两边SELECT * FROM employees WHERE (salary&gt;5000 OR salary&lt;3000) AND department_id=30;\n\n四、正则表达式：复杂字符串匹配REGEXP支持灵活的字符串模式匹配，比LIKE更适合复杂场景。常用匹配规则如下：\n\n\n\n模式符号\n作用\n示例\n\n\n\n^\n匹配开头\n‘^b’ 匹配以 b 开头的字符串\n\n\n$\n匹配结尾\n‘y$’ 匹配以 y 结尾的字符串\n\n\n.\n匹配任意单个字符\n‘a.g’ 匹配 a 和 g 之间有一个任意字符\n\n\n*\n匹配前面字符 0 次或多次\n‘ba*’ 匹配 b 后接 0 个或多个 a（b、ba 等）\n\n\n+\n匹配前面字符至少 1 次\n‘ba+’ 匹配 b 后接 1 个或多个 a（ba、baa）\n\n\n&#96;\n&#96;\n匹配多个选项之一\n\n\n[]\n匹配括号内任意单个字符\n‘[ot]’ 匹配 o 或 t\n\n\n[^]\n匹配括号外任意字符\n‘[^0-9]’ 匹配非数字字符\n\n\n{n,}\n匹配前面字符至少 n 次\n‘x{2,}’ 匹配 x 至少出现 2 次\n\n\n{n,m}\n匹配前面字符 n 到 m 次\n‘ba{1,3}’ 匹配 ba、baa、baaa\n\n\n示例：\n-- 1. 匹配以b开头且后面有至少1个a的字符串SELECT f_name FROM fruits WHERE f_name REGEXP &#x27;^ba+&#x27;;-- 2. 匹配包含on或ap的字符串SELECT f_name FROM fruits WHERE f_name REGEXP &#x27;on|ap&#x27;;-- 3. 匹配x连续出现至少2次的字符串SELECT f_name FROM fruits WHERE f_name REGEXP &#x27;x&#123;2,&#125;&#x27;;\n\n与 LIKE 的区别：\n\nREGEXP匹配字符串中任意位置的模式（如’bon’ REGEXP ‘on’返回 1）；\n\nLIKE需用通配符才能匹配中间内容（如’bon’ LIKE ‘%on%’才返回 1）。\n\n\n五、总结：核心要点速览\n逻辑运算符：\n\n\n\nNOT取反，AND需全真，OR需一真，XOR需一真一假；\n\n\n\n注意AND优先级高于OR，用括号明确逻辑。\n\n\n\n\n位运算符：\n\n\n\n对二进制位操作，适用于权限控制等底层场景；\n\n\n\n常用&amp;（判断位是否为 1）、&lt;&lt;&#x2F;&gt;&gt;（移位运算）。\n\n\n\n\n优先级：\n\n\n\n括号最高，赋值最低；不确定时用括号强制顺序。\n\n\n\n\n正则表达式：\n\n\n\nREGEXP支持复杂模式匹配，灵活度远超LIKE；\n\n\n\n掌握^&#x2F;$&#x2F;[]&#x2F;{}等符号，可应对多数字符串筛选需求。\n\n\n\n熟练运用这些运算符，能让你在处理多条件查询和复杂字符串匹配时更加得心应手，写出高效、精准的 SQL 语句。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 插入数据提示字段超出范围？一招解决 DECIMAL 类型踩坑","url":"/2025/08/16/MySQL-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%8F%90%E7%A4%BA%E5%AD%97%E6%AE%B5%E8%B6%85%E5%87%BA%E8%8C%83%E5%9B%B4%EF%BC%9F%E4%B8%80%E6%8B%9B%E8%A7%A3%E5%86%B3-DECIMAL-%E7%B1%BB%E5%9E%8B%E8%B8%A9%E5%9D%91/","content":"MySQL 插入数据提示字段超出范围？一招解决 DECIMAL 类型踩坑在日常数据库操作中，我们经常会遇到各种字段类型相关的问题。今天就来聊聊一个常见的错误：插入数据时提示字段值超出范围，以实际案例带你搞懂 MySQL 中 DECIMAL 类型的使用要点。\n问题场景再现先看一下我创建表和插入数据的操作：\n-- 创建商品表CREATE TABLE mini_product (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20) NOT NULL,    price DECIMAL(6,2)) ENGINE=InnoDB;-- 插入商品数据INSERT INTO mini_product (name, price) VALUES(&#x27;iPhone&#x27;, 6999.00),(&#x27;小米电视&#x27;, 3299.00),(&#x27;华为耳机&#x27;, 899.00),(&#x27;联想笔记本&#x27;, 5699.00),(&#x27;大疆无人机&#x27;, 7999.00),(&#x27;Kindle&#x27;, 998.00),(&#x27;Switch&#x27;, 2099.00),(&#x27;索尼相机&#x27;, 12999.00),  -- 此行报错(&#x27;机械键盘&#x27;, 599.00),(&#x27;移动硬盘&#x27;, 699.00);\n\n执行后，数据库直接抛出错误：\nERROR 1264 (22003): Out of range value for column ‘price’ at row 8\n错误原因分析这个错误的根源在于price字段的类型定义 ——DECIMAL(6,2)。\nDECIMAL 类型的格式是DECIMAL(M,D)，其中：\n\nM表示总位数（整数部分 + 小数部分），范围 1-65\n\nD表示小数部分的位数，范围 0-30，且D ≤ M\n\n\n对于DECIMAL(6,2)来说：\n\n总位数是 6 位\n\n小数部分固定占 2 位\n\n因此整数部分最多只能有 4 位（6-2&#x3D;4）\n\n最大可存储的值为 9999.99\n\n\n而第 8 行数据中，”索尼相机” 的价格是 12999.00，整数部分有 5 位（12999），明显超过了DECIMAL(6,2)能容纳的最大整数位数（4 位），所以导致了超出范围的错误。\n解决办法只需要调整price字段的精度，使其能够容纳更大的数值。\n根据我们的数据，最大价格是 12999.00，整数部分有 5 位，小数部分 2 位，所以总位数至少需要 7 位（5+2&#x3D;7）。\n执行以下 SQL 语句修改表结构：\nALTER TABLE mini_product MODIFY COLUMN price DECIMAL(7,2);\n\n修改后，DECIMAL(7,2)表示：\n\n总位数 7 位\n\n小数部分 2 位\n\n整数部分最多 5 位\n\n最大可存储的值为 99999.99，足以容纳 12999.00\n\n\n此时再重新执行插入语句，就能成功插入所有数据了。\n扩展知识：DECIMAL 类型使用建议\n根据实际业务数据范围选择合适的精度，既不要过大（浪费存储空间），也不要过小（无法存储有效数据）\n\n对于价格、金额等精确数值，优先使用 DECIMAL 类型，避免使用 FLOAT&#x2F;DOUBLE（可能存在精度丢失问题）\n\n设计表结构时，预估可能的最大数值，给字段预留一定的扩展空间\n\n常见场景参考：\n\n\n\n\n小额商品价格：DECIMAL (6,2)（最大 9999.99）\n\n\n\n中额商品价格：DECIMAL (8,2)（最大 999999.99）\n\n\n\n大额交易金额：DECIMAL (10,2)（最大 99999999.99）\n\n\n\n掌握 DECIMAL 类型的使用要点，能帮你避免很多数据存储相关的问题，让数据库设计更合理、更健壮。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"从 MySQL 5.7 迁移到 8.0：别让 SQL 文件 “坑” 了你","url":"/2025/08/16/%E4%BB%8E-MySQL-5-7-%E8%BF%81%E7%A7%BB%E5%88%B0-8-0%EF%BC%9A%E5%88%AB%E8%AE%A9-SQL-%E6%96%87%E4%BB%B6-%E2%80%9C%E5%9D%91%E2%80%9D-%E4%BA%86%E4%BD%A0/","content":"从 MySQL 5.7 迁移到 8.0：别让 SQL 文件 “坑” 了你最近处理了一个 MySQL 迁移的棘手问题：把 5.7 环境的数据库打包成 SQL 文件，直接在 8.0 里恢复后，各种报错接踵而至 —— 系统表引擎异常、密码修改失败、甚至服务启动崩溃。其实这类问题很常见，核心原因在于5.7 和 8.0 的底层设计差异，直接 “照搬” 数据很容易踩坑。今天就聊聊如何正确迁移，以及出问题后该怎么补救。\n一、为什么 5.7 的 SQL 文件在 8.0 里会 “水土不服”？很多人觉得 “都是 MySQL，备份恢复一下就行”，但 5.7 到 8.0 的变化远超想象，直接恢复 SQL 文件可能触发一系列连锁反应：\n1. 引擎规则 “红线” 被触碰5.7 中用户表默认引擎可能是 MyISAM（取决于配置），而 8.0 默认是 InnoDB。如果 SQL 文件里显式写了ENGINE&#x3D;MyISAM，恢复到 8.0 后：\n\n普通用户表可以用 MyISAM（8.0 仍支持，但不推荐）；\n\n但如果误操作涉及系统表（如mysql.db），就会触发Storage engine ‘MyISAM’ does not support system tables错误 —— 因为 8.0 强制要求系统表必须用 InnoDB。\n\n\n2. 系统表结构 “暗改” 了5.7 和 8.0 的系统表（存储用户、权限的核心表）长得不一样：\n\n5.7 的mysql.user表有password字段，8.0 早就改成了authentication_string；\n\n权限相关的mysql.db表，字段数量和含义都有变化（比如新增了部分权限枚举值）。\n\n\n如果你的 SQL 文件里不小心包含了mysql系统库的表（比如用–all-databases导出），恢复后会直接 “污染” 8.0 的系统表，导致权限加载失败。\n3. 语法 “过期” 引发隐性错误8.0 废弃了一些 5.7 的语法，比如：\n\n密码函数PASSWORD()在 8.0 里不能用了；\n\n某些索引类型和表选项（如ENGINE&#x3D;MyISAM的分区表）兼容性下降。\n\n\n这些语法在恢复时可能不直接报错，但会导致后续操作（如修改密码、授权）出现奇怪的失败。\n二、正确迁移姿势：只搬 “该搬的东西”迁移的核心原则：只迁移业务数据，远离系统库，兼容新规则。分四步走，稳如老狗：\n步骤 1：导出 5.7 数据时 “精准定位”用mysqldump导出时，只打包自己的业务库（比如mydb），坚决排除系统库：\n# 在5.7环境执行，只导出业务库mysqldump -u root -p --databases mydb --skip-lock-tables --default-character-set=utf8mb4 &gt; mydb_backup.sql\n\n⚠️ 千万别用–all-databases！会把mysql、information_schema这些系统库也导出来，堪称 “定时炸弹”。\n步骤 2：编辑 SQL 文件，“过滤” 不兼容内容用记事本或 VS Code 打开mydb_backup.sql，做三件事：\n\n删掉所有ENGINE&#x3D;MyISAM，要么改成ENGINE&#x3D;InnoDB，要么直接删掉（让 8.0 用默认引擎）；\n\n搜索并删除涉及mysql库的操作（比如USE mysql;、CREATE TABLE mysql.xxx）；\n\n把PASSWORD(‘密码’)改成直接写密码（如’123456’），8.0 会自动用新加密方式。\n\n\n步骤 3：在 8.0 里 “干净” 恢复先在 8.0 里创建空库，再恢复数据，最后用官方工具修复兼容性：\n# 1. 登录8.0，创建业务库mysql -u root -pCREATE DATABASE IF NOT EXISTS mydb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;exit# 2. 恢复数据mysql -u root -p mydb &lt; mydb_backup.sql# 快捷方式（新建了一个数据库名为mydb_backup，数据一并放入库中）mysql -u root -p  &lt; mydb_backup.sql# 3. 关键：执行8.0兼容性修复（自动处理表结构差异）mysql_upgrade -u root -p\n\n步骤 4：验证迁移结果恢复后登录 8.0，检查两个关键点：\n-- 1. 业务表引擎是否正确（推荐InnoDB）USE mydb;SHOW TABLE STATUS;  -- 看Engine列，尽量都是InnoDB-- 2. 系统表是否“纯净”（必须全是InnoDB）USE mysql;SHOW TABLE STATUS LIKE &#x27;db&#x27;;  -- Engine必须是InnoDB，否则有问题\n\n三、已经 “踩坑” 了？这样补救如果已经直接恢复了包含系统库的 SQL 文件，导致系统表异常，按以下步骤救场：\n1. 先修复系统表按之前提到的方法，把mysql.db、mysql.user等系统表转回 InnoDB 并重建结构：\n# 以跳过权限模式启动8.0（窗口保持打开）mysqld --console --skip-grant-tables --shared-memory# 新窗口登录，修复引擎mysql -u root --protocol=memoryuse mysql;ALTER TABLE db ENGINE=InnoDB;ALTER TABLE user ENGINE=InnoDB;FLUSH PRIVILEGES;\n\n2. 重新迁移业务数据\n先删除 8.0 中已恢复的业务库：DROP DATABASE mydb;；\n\n按 “正确迁移步骤” 重新导出、编辑、恢复数据；\n\n执行mysql_upgrade确保兼容性。\n\n\n总结从 MySQL 5.7 迁移到 8.0，不是简单的 “复制粘贴”。核心是要明白：两个版本的系统表和规则已经不同，迁移时必须 “划清界限”—— 只搬业务数据，让 8.0 的系统表保持原生状态。\n记住这三句话：\n\n导出时，只导业务库，不碰系统表；\n\n恢复前，编辑 SQL，删兼容问题；\n\n恢复后，用mysql_upgrade，扫尾保平安。\n\n\n按这个思路操作，迁移过程会顺畅很多，少走很多弯路。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"内外兼备的得分后卫都在用!1.5motion新单动投篮","url":"/2025/07/19/%E5%86%85%E5%A4%96%E5%85%BC%E5%A4%87%E7%9A%84%E5%BE%97%E5%88%86%E5%90%8E%E5%8D%AB%E9%83%BD%E5%9C%A8%E7%94%A8!1.5motion%E6%96%B0%E5%8D%95%E5%8A%A8%E6%8A%95%E7%AF%AE/","content":"\n  07d75588653f466133359cc81f040bdca1bcf910cd813fa7632e0918d7ee55dc1bfabedf5a51e237502b87e85f90176b395c433c69e338c820b7e4d8f2113ae88a3c8b7ab31040b3f22d17f64f07bcdef92fd5bc3eaa572b83fe2cc0b450c8a70eddec29f505e3a5f3b614339f5f3b7067ad47bab4674a57dc1e2c954766174efa19f81e6ff852bcffdd39792a27f43c7d12782501f1e2835ebbbe63b156f97a816e0f56fc19bde4ba139bd901267278dab20b18cdeed4adcf91438541e957183628e922a04cda71dda65652a30feac11151e84d62991fad52ce2249d7e785b4f698e0c0cf27b34aa712c05eb9b3abdef7b19f071f89881e44ce52419b6e9d1a4b09e86e6dc69e9708a8f87e4b9a60b403612d6d30c152555c98f7960c600c9b20fb43504ded10e103b45d85d780d19ce432d06867849f8258c1654c4239784395aa36c0efc963fcb0648e70df5cde5479bb1689458b0964a79cb08d2239c746031177adfea43f0f18dc4ab9986bec189a3107ab0406e9211f3a925a820e803f2ce3dbd1dd784be89012050d54b47f1eaf25fb92ad304565a51a7cc53c98dfb667249379b52fa58c848d65f32b6e7905cb0a09a3ea320cb710de3482f065aab1a932a1b2850f173de4fae0ceeaf9e0efd0b3073857006ed719b74be524d126a4fbe63480aae03909f521a3f788df7b0f708f2b29dff0ec4152a6bf226de77ee8ef3958d97fc829ee7391fc8e09129a3636a158d1a848d6da94e087065a8812bdfec5b665d067bb4c0cf8301c0fd7e1c729402fc6b908ac45f30f22df83e5c1d9db0039e6c6dd9159dbe45cf690390f64a65a00715f9da5239e3d718c45398215e02bc15fc6abee70922e639a7b63a5d55a66f12e6c0dfef949565910fe27a20e802a2a2959f6f5af3ba6b37008195aa50bac5b89473b3a8a8403ba8b62fb9f2d8335b99b49f8aecb4b00ef18dcb0e5b3965a2202d241af16edbb3279657a89d498a588a892f51cb8abf62db828f16eecf44278d9051c7243672bc0b7dad81c3c94d094b314bd02f6d5444bdfc16dc70711ec562f847d4d0b6d8d3943ddee4342b4b5c3ca6ce5803c2fd95e9ff0d763270f77db0db02087a7f697e2f1afb448ab950ce6a26065fc1a269896e6bb4963b0d85b0d23a83efaaea4e68d9eaa58782da1c5aadd1beb7a17aa56009e32fe319cc2262e71dca73ac5d056c0b27e95f04636ce7df148ed5b3fb48e66e10e0257bf0de42f57cff4139a8e6337bab0d011d9357117ee23f651b8b07279a6454570483f6bd936c8dbabe991e9d02132a2afe626a37b87fb6018d6624f93efc01f5c82cb07e0abfaf29bbe46671f617799600cfd58800015a5701f2d7ccc58c27257f32df855e6576895dc1bd284daaeef4a5fd53c382006c06260bfba9cc1e1de32f9f96a3b5abf12920f4d901478bbc58c9fb17674b54a9e602d0839f5983f77857556f181e58ba52f0d067b5c3dd9d131a4ec8d5909acdfff341a466fdea7e15cfe80460eb2154c99d723b93ab5672d3605c956414f592cc92b9133a8825c142a4d1d9359b1dd4baf7fcb044b218cd910c6a08284c5bab965bc362d1fa317f82f6cfaf97cad6995b63adb9088c3c62b989ecf46c6b9bd758c83aa183232ba2793a4c3c806a018425dc61f90348c7110be6fa95b1c5f3d20a8bcc8b942bafbeb5edfdd39651bd91147d56e36fa08359f7fea1324e059fc10f40a8361c780d9157e72aa8a0536469407c13aed4162a7155226429c86901dec42567ad44ca19f1f43473f0068561073620b2c1b4826f5c61e33718a4a9dfdfa980b2b2eeaa7d1b768ac52650e7caf9a2f825b94ffb411b6da1ebf5f877f37597febee2f759641ffe9e723e15a87d5366839f4860fd61f5da8720ec50ce6df50d2ca97361523eabbcaf1d5fa0b303cd4452c49a6abe3d1890a0868e583b8a566ea4d4281c0ed241ba03622298af7a5b6b2aa7656527a2c4752181adc088dceff6cb6601b3464a015ae75fc54818b18a8db0947b4e1b36bd55dcb75075a525fb74506e6968e13f66733d2fbdfe98f0a260e1859786a81e29cd41d0bc24c0d58be8fab1a701e1216bdbde2e74dbc129dbc4a9c6e93b462b244cd21119462691437a6d4ad486601b234b2d1bd34b9a953eb357af998279a54d697b1bf34d009c2bf1bed928efecc01e19c72be4e41a83f39c20edc0d0aec83ce06bb868ba51f5227ac3dfec4eeb2853cddc949c749721a75010ac7e62ef96f8a2c0d86552660e55ae872cec3bd1c9a55ba3cbdbefe8f23ddd042f532ea0196d99b60f3d2ef48cdf7b128f1541b431eb5c266aec7e39895aff5331a0bb71114563fea84b86039c8e815c0933728ab86e4d19c144fb75859c2aa7bc0f69469ff26f6b778e54d666e78c4fafef51030471c15fc48d323e3bf147c498d6061bba5ff11b46b9a1cf3dd0fd3982a063ce093d5a4e5d4ca9174c4e8b234f7d5ac4868c21a2f7b3ff9afa4217783babc199c74c0a2bd64606527346d597d5c3a2889711d1efd342ff28c5b11d5f3fbb69ce7293f953a6bd2b26df0325ecfac6a6a84a4462d057eb889e94fbf1014974293060ce6ccd23eb6487073a1ddd003b42af611455b1f175ce669f7089e66c9637ec785d7df213898611e12fd791cc69783a50b9e1e14aa952ace6e56c30e146d1c21e888815b14d17e77038a38f0433e9cf4c922e27f851a4ea1052aee460d741dfff1060c3c7204c64104d9a0a1bc9aff154a2a531bfdd3f6567b5f56c8f8193ba129cfc1486876c6b81a6e4f4b7bf6d4197caf1126a763eba58aae635ff90c2cd35b124b54e3a99745464c103cd46db17714811e5a1ab03afb56e0ad8de48655962c2a2fc99116f8e9a1a7e991ff7b1e7ed5cfa4a8714ffc1800c3574bc63dc9c8b343fa155cd93205a17150185c4eea8654128aa9d02eedcb17a739fdaf7de68e0236be8776216e822e71fea77f566838fa27f3e35bade7960687aed8af4851c77fdbd7704b6445e8200230bc796c1cf724be9241430047eddfd1077a9cf6c9876d396eee80b31864639305591002f0ae195f3e351c965a27a5274cc3725a6e5c27109d72e6dfc6e2cb89a0ccc94b412c1edc1f645a469f265dbf6c7ac6f5fd7a7155396ba3d78306b97aec81f7e5de52faec8a4e14a2b118de05553b030fbe84bf45291b5461417888e48e27c6bd0df8d52ad5608885f983aaa5f05d018e05f4b00949e3bc06383d16adaae778e54a9304c29ae7edc7fd267c9843bad0846284928e08019ffdf5ca3b7f574d05f4ef55e0de7cb0ecfc1f9b52087d4786659fa51ac33a6feda1280994c93dda754e310585e315d3b1e9da0bbd6e85da1ed474fb0f26da94b018bc662b1d940b492f901182b1b4e675fd2eb057d8d3c4ebfcd1420a3e3326640f9ccc4a7fef24dd35c44e155bc18b729b205e0940532a08804aa84f99ac2bd43526b4900ba0386552bf70d91a6aadd7fb4eee3437e6a4ab3225ac5bf6e223a859795ddd883349fce2fe5047d82f8f80a220034837c3c2db2aa852ea45093c596ea6e2ca2b7760e38dde68f03cc107892b55748da3103568ae7c7b14995f75fc73373896bdfd25b8c76fd599fa71f2e00e27f058c5f6d65b42d0e3dd305db455d0dee7350f6fde529b454ddaa6a941ef4e067464ba1930b5e7ece89a53f0465adc1b1e148b7f620532043b3624b47545f3d6c8b807bf693d05f1c77325017fca1fc2f1b49b409c19842530bb83742eb2f8770c8e6b82d11f7c1a1b88b7155a13a9e2494d286c06ada635a29afa71c09fc9890289ee0e013e89d3e288c4950701796c99d7e505364699db434b26cdc581732c7eecddb8d0d2fb5eb0d415b73ca7fdfcf538dd230628a67404703756490d4f42b306bd3624c6cd879d37aa96a4deed357d8b9bb88b94e995652177ae8985a4559eb6f75b55109b3a7904e0c93bfc5ea4ed95928278c6075c273d97f3addedfe388708cafd14cb0338a5eaa7db07c07004b5945e23c39eb37276bbdf672e53c0fc6d989f23d03d4cca8c3aee9f769a2f841f720893242cf12ed99fca277f44038ee7ea412330aa8791aa81acfff91e4b500bfc59d80db7de8ef68173d3a3e2dcd3d3327ef327b761ee769224a9dc2b8641cd097a495da7e4cee138ee580a2ad6ef085bcab26a169e3e11d067908748a7d50097d9cd1ebf6d36d92b3c80b8079e9365d60c7d8829fd4b64a12e19fea2d0e08a66e4355ce994e9c8bf34217d944e21a7a147e056ede4e3e23e84105561eef675df53aa2d65dba7497ad8066532d160c82c70e8222e33e5b01d2d5325d8ebbabca9cf01f2dac0b5553726006a2d1a0eccac58f2f3b35f0ba1dc0294908c97254c25e7fdf64acfc827bacd29dd3882833c591e525f95f2ee7143d5598ceedc88ce5abba82274fde417dd866d226e191f64ea3b5b4a8a714505166cff91db24e4f842bd3368ff66cf68cb202bc016b1bafc4a5248c9298183130683e313026532d8e995d419b9cd37d97567cbedd6928028645a83b8647052cd73df3f7210032a368df99aab9c19ffe71a021d43bad34d6f43f8db87a6542c68f6249827b36f25a8daad55aace8b9438ee21267cb874106ff4a261e65a5169470645d86f47d50baf155c313f1675d565cc803e13b9e8aded147c8bd70f750c7777ee540541fdcbca045e4522820fd6707ce13328e3227a42ed90d39ac32f6ac3a52a65d282e3fe9d1b53eee4942a74f15d5e28cf13e972e3512527d9cc8812571a612a9834ffa9afa4c4e785d1dc51abfff8d1c69638917b3ebe5d243cd3f4a3560ab118d1a7168a0e0d9f01d824166408d321272a7a694b822e03dc493b0422366481eee7c987d4c946278b3d0eece4566964ac83a5f65adeaec5576d84e8df5ae58cfaaa025b610f9b34b29da4ead62bcea406a4c9548fcb5bee8d7527fea7cb27434102df8805d9404f5965e8ca0eb9e57b4a9f825dd597a131542691782c80dfdda2d3c6dd40c3ee817c3d53eb42699e4702ee3d3aef317bd8b81ae3cda82daaa34206b896b44b8452f447f051ed8e56965d3eda6fe7af5c2ae1e3006daecfb00af31b1eea041468283c5f9623e1380eb6f13104850d8c349dafe4750c6a12c84dbd538b7ec21655fd10671b270782f34533a9de1f6bb08d9b6bfbebc094e2e3e5c437ed3a8963938fe7db5097dbc463dc4498298d3db880373104be88544a594bab25e93ff5dbb501094fc08fe33e771abc186e3f123c2c436025366a6b9d05472092269b8f1bcd7c5a689f31e0c885d65708dec30ef3a47bc95c77ab7ef121b1c98ea0dbb19dd848e41f1a173dfed7c51248fb7b92393986762ff96bbf9dc4b223715a8a5f90ffa7b4c6032476ef79ca3b79fe433a72e3f91e08036ecc088d8fb57f05d8fc94286cee507eceb7d83f38feb75528a472a11908b4edf87b0e8246435f650ff9c180e576d366a466b66b111f447f40ac054d1d0fa600b18cec1917ede8dde9751eca7c0dc0e407a58ecd31bec15bed8a900753a7f38e334e2228b177c8a7ee91d75969fc6aaf1d29dc5b9202d1dbdcd688ff56a652ccceb7eaf4e7528d005f020a4955d1deccefd3135028e45319fd53375a327d8e38872c8f4e130f9aed82e697aaf25d12e03158ae2d120d9d1c13763176f1a0d37cdb516aa2b4304c815fbd5a68dbf95a15b196cf2fc63dbb40a60c31af8610ee99a3ab338c208c41d551490cc3b9e4e485212081b7a157397a3c2525bc1b6cfe47020bc6e0930ad01465c5bf11a976ad78d13b8653ee3dcabf40005afc453978c1e4bc64e90648293eebb40431ff9ee42bf157f7495283de14876168536cab3476a7296eb1f21d4e5e24d1ef1f408cef7ef595f664d718ad77e50526d1a371120e0ae7faaa4b52b272214548a91d6c5aa43f06f3551b4150d18b1b5dc11f3321fa7ec455bcb1d26500ea959b004bbe7c5f9fde3c03bb5eb106dc71663fe167a5045e0f8a455fd3790faa3c4d91eb64406356944eb393bab69c631a78c24bd5e70ac2c9126a635d73730fa1ec2134fcd3d902eb03b90d4740751e6b9f6f386e664491e9a752b545792941bf20e4a91997a5a005ef6732c6f632a2ce634aa22c4ca4b6c33129b695dcf32a31929e8118981ec95a2f1012cf924c48255edfe525717fc6f598d3c33d9eb15ad53ffa9b555d898f7342df4b47a2044a967d0dbbedce353c9e8fd209acb7de7347d4442bfcc13421a433a5ea70fb4de9caa5c3a0cf7fe3fba1a459fbef50ec43251e3d946d62fbfaf6eeb5fad17c3c866fea36b0dd22d8ab862cc8eb3356e11db8b49e21dd1c0cb2ba9425b5bfe5d30e7a4a960ab0dbb05e44d986344638b43f129d74c9375a233db7d47897360ef75457d0145aaf934c9e1ced77eae3e4b6243b5abd6faa226a0ca6d9f8131b71d1d2610633c1f627b2f4b82e002fb9be767cd6a1d6cdcc5147edfb3296255f67d17bbbbd4d2500dfbc04455549084306c0205b4862140a2df79487629cb8b17a6ce384d02c67e4ce78ab2a5d2b9e9c3b9fc0a9a92c0c3d882af442df0c3417b5d35cb12a169fe164319153f762d637d1774c75d74136599130c103ec1b6e454fb01fa6997e388e231504f0226154fcbc179ba90c89c8e70739b0d0fdfdc8423104c4caa896824f4101c35dcab4055d7320eaa856c0921dca8a2fe31173f2f97b5a5a3b9d9eae2d858e64436c29987a17f2530d6a455d8da954ed15e17bd1a0809f0a91549b36fe6d2458246e840e38f70b93c17d2fe6c109fef203494b3b8e59916c710820fe944956634d7cdb1f34d80489f6a2a2ece62c8a2f9ae1a31de37d323dc082abb39d960a787b6454890c137b087365b00f38403ee1ed035837ab4880a81d9488c4ee625be395c5b5a677e3b23c7afc9f7cb9b82133cbc00ae8b82829f5fe82d8d86038deb03f634b560a8587ec7db8ede62716b3a847dfac7c1c61c02906154d8ab8a8134418cefa5f50fa39985c718f84b2277cb88ae60b8c7bcdf34b733ac537a414a69bd9b2ae3d5c433b46494d04c7e7c069391518c26c470b4be9092951f34542ab6e73fe761fcb608abcefc5fc7ce29f1e7905ca0ff4150766e9f1ec263e16714cae164520045464f824759ee466264ffcb021cb21fa9a1ad628651011e122c36a347129fa29e2059d7b4d57048378d3fd8d2e3b04a0f33cb5dfb38356e9744ff4503e75954e04e0a32622ef65da3a684b5091caf44fc242dc1bf18ec9428f0d3acb2341157a933657ede9363a94ab44888afde9391fbeefdb41f103fd1bbd6f9a6a525cf8b9e9a7fb68d99c5977ac7867f45ef8968868a9cd5bec00bab8f6136fb4bad469419e211b4c45481e0158c385cec2a5da88d85d6ba3d76a0d369f573b33ba132e270f3b8455f33b21e4b8ec106fd871ab19ce4016dcf9b404fab11bed8ff82cfdd414f81311c14947d34b40cdd56344f29602532086bef96c0717a7b7b2aaef2d6e66f13251dc6fe6d2e606006e9bb76b1971770ee226390ef650265e7b41e1f305b696a347e95515541bf22c900773f840c209f3da1125a9f429551506a72be51fd40df320a38cf8c5ef39c2040936840cf1329a8ea9c3706c64437e93badd7ec4ce6270dd722c7c2eb7c61e22f2107a17d3d51f7e2301ab6af83365af0ea9827fb0b53356c59b032d809e1be7a9927ba9cf0505a6b7930dfb52f4d83011ab0a20a5c773f2f40288a99f38c77e9e2e2224e050b36cf5d4ee16bf806cc5ccbd2ec5cbb0ce6713b0addac18129332513011409ff4641bfa0623f46394fefb537599fa7e3b9945accea5177d726bd9e63c83baa5549dc9432a6825c938a52b8fc925f878efa70f0a498142be8c3c3e4553086bb4e3f62ea160f198a2eb7c195999d5798864f7209de3ab43b9e55caed79bdcd39892d4f49b502da68faeefc6908852dcdd43624ffe9d3443038380e6d72f015d07279fdd5659801b5711fb788d34407b8646e3dda04d4bf22567b04cc5754510ed70fba7fefca609eeaa7a4ac7686c4c10a991ed48213b63a93ddf9ca95d663aece69fad5a9b417aca62a9f37b25d9c7320c1803842b8960a04f4c77cfea4816f1d8753593c74bd1a66c44e76772b90f6705c0a27a89ded90d8f9a62b872a93bbaa7a83a4a8e5b430e4ac28e2a876abd21c23be290a39ba204fd8e05c684fbca40a62823871343cb2983e1762eb789909cda8115d43f622b8e71d8430f60c5bb9bf95afe0092b9ad633d2b71e27f7b962e4952b3dcaf990b752903fd068562592e6937abda705f283a3c7922d616e18f7ed573b833c33edea21efc4b1480a8e68ad7971d01273c55bafc7ccc9e4aa67bebc8b3b5c743ded828bc99e60e3a080277fa99ddb2a6ed104cebeb771c9845a3e039d2a6183f07285c12588bffc263dd51e8c7e9a3362b10b5d901a0c95da0fca4e73e62f4623564da1d340da9b17e326c5cfa5d0f98505b15333095e18ea7ac5df87901a9ce4c406ff888a5400f7a8599cfa785d99f3a24ed5930fdc267e94c293dc1b8fdf9ee2364505d354e257aa8bd078ac07262f60229693e20f9c2c2b1ad02df97f134b4ef13aa0ea4f190cabccf2f836a8d91a6eb3bbd9117c32642ecde43d6f8854556813bac2a442b2ab99d6574330f792659727be748a5952b8d44e3b015ee0865b063ee113a8779d95ff38854fd934f71dc6241ad92616b8c499a5faabf2fd8e535542a85802979574420b64e86ac4850b04ec823fe5e48071aa178defc050733be8dc364733f4f5037b4bd7e71dbb960b44605aa4c0f8820f2da740479adb930d1a65930e78f4e4ccdbe402e50d69d8e928a34ee2cd9a41d8d9799b7d970e5973276722f6e8487fec2edbdb448858d3e1e0ec1e2c4c59fe6a7e4256c21515bdaabb5d2f44bee671d5b6fb5f0f9dd981743ff497f925f5a13eb462463fb6dc9108401c646f0ffd58f3e620faa2f82a0502eef4636eb597c3413ba04fbbce052829f2258be89d87e66edb390de5a56b54f6004cb9bc5928f39532e00f78cee9953a8c4e6df3b85541b114513b5c76772bf445942955a6c2af71a180411f31b6bb7059a248563220cc8537de0d42b4942fcb7ef2515fe31d0306ad284fd4d96627cd52b6a7cf3ef8d48cd1912340c67b0f0e3f330da67d667060f0fb9b327b230ff4304db03bd5e9a284003d9dbd46da02965cae2f66510da6e66742399cabdc01bc5a8f85cd324eab2090b4a23dcfce5806d196e1d2222afc19e089dcd06176931ddd80c7e81fd605b173c3a86c93781bfbb70ca60670e7e0ca9818802a4a54cdac756e948794826007e32c00e71fe65eea62e4a2acc37d99e2a9f7f5efca84fe1032268bf2298f8517888\n  \n    \n      \n      \n        当前文章暂不对外可见，请输入访问密码后查看！\n      \n    \n  \n\n","categories":["篮球"],"tags":["投篮"]},{"title":"Hello World","url":"/2025/07/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["Markdown","教程"]},{"title":"在 Hexo 博客中插入图片的完整指南","url":"/2025/07/28/%E5%9C%A8-Hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","content":"在 Hexo 博客中插入图片的完整指南Hexo 是一个基于 Node.js 的静态博客生成器，因其灵活性和扩展性而广受欢迎。然而，在使用 Markdown 编写博客时，插入图片可能会遇到路径问题或格式限制。本文将详细介绍如何在 Hexo 中插入图片的多种方法\n\n一、插入图片的三种种方法方法 1：使用文章资源文件夹（推荐）Hexo 提供了一个 post_asset_folder 功能，允许为每篇文章创建独立的资源文件夹。修改 Hexo 根目录下的 _config.yml 文件：\npost_asset_folder: truemarked:  prependRoot: true  postAsset: true \n\n\n说明：此配置会为每篇新文章自动生成一个与文章同名的文件夹，用于存放图片等资源。\n\n\n创建新文章：\nhexo new &quot;你的文章标题&quot;\n\n这会在 source/_posts/ 目录下生成一个同名文件夹（如 你的文章标题）和 .md 文件。\n\n存放图片：将图片放入生成的文件夹中（例如 source/_posts/你的文章标题/）。\n\n插入图片：在 .md 文件中使用以下语法：\n![替代文字](图片名.jpg)\n\n\n提示：如果图片无法显示，检查路径是否正确（图片名.jpg&#96;）。\n\n\n\n\n方法 2：使用固定资源文件夹（最简单）\n创建统一图片文件夹：在 source/ 目录下新建一个文件夹（例如 images/），用于存放所有文章的图片。\n\n插入图片：在 .md 文件中使用以下语法：\n![替代文字](/images/图片名.jpg)\n\n\n说明：/images/ 表示从 Hexo 根目录的 source/ 文件夹开始查找图片。\n\n\n\n\n方法 3：使用网络图床（氪金玩家）如果不想将图片存储在本地，可以使用图床服务（如阿里云 OSS、GitHub Pages）：\n\n上传图片：将图片上传至图床，并获取图片的 URL（例如 https://example.com/images/图片名.jpg）。\n\n插入图片：在 .md 文件中使用以下语法：\n![替代文字](https://example.com/images/图片名.jpg)\n\n\n隐私保护建议：  \n\n避免使用第三方图床（如免费图床服务），以防图片被他人盗用或丢失。  \n推荐使用私有对象存储（如阿里云 OSS、AWS S3）或 GitHub Pages 搭建私有图床。\n\n\n\n参考链接：\n\nHexo 官方文档\nTypora 图片管理指南\nhexo-asset-img GitHub 仓库\n\n\n希望这篇指南能帮助你更好地管理 Hexo 博客中的图片资源！\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"SQL 语言规范与基础操作指南","url":"/2025/08/16/SQL-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/","content":"SQL 语言规范与基础操作指南SQL 作为数据库操作的核心语言，遵循规范的语法和书写习惯不仅能提高代码可读性，还能减少错误。本文整理了 SQL 的基础规则、书写规范及常用操作，适合初学者快速上手。\n一、SQL 基本规则1. 书写格式\nSQL 语句可写在一行或多行，推荐各子句分行书写并适当缩进，例如：\n\nSELECT id, name FROM student WHERE age &gt; 18;\n\n\n每条命令必须使用下列其中一个用在末尾用结束语句（; 最常用）\n; \n\\g\n\\G\n\n\n\n2. 关键字与标点\n关键字（如SELECT、FROM、WHERE）不可缩写或分行，需完整书写。\n\n标点符号必须使用英文半角（如’、”、()），且需成对出现（如引号、括号不能遗漏闭合）。\n\n字符串和日期时间类型的值需用单引号（’ ‘） 包裹，例如 ‘2023-01-01’。\n\n列的别名建议用双引号（” “），且AS关键字可省略（但不建议），例如：\n\n\nSELECT id AS &quot;编号&quot;, name &quot;姓名&quot; FROM student; -- 正确\n\n二、大小写规范MySQL 的大小写敏感性与操作系统相关，遵循以下规则可避免混淆：\n\nWindows 环境：大小写不敏感（例如select和SELECT等效）。\n\nLinux 环境：大小写敏感（数据库名、表名、表别名严格区分大小写）。\n\n\n推荐书写规范：\n\n数据库名、表名、字段名、别名等全部小写（如student_info、user_id）。\n\nSQL 关键字、函数名全部大写（如SELECT、INSERT、COUNT()）。\n\n\n示例：\n-- 推荐写法SELECT id, name FROM student WHERE age &gt; 20;-- 不推荐（大小写混乱）Select ID, Name from Student where Age&gt;20;\n\n三、SQL 注释用法注释是代码的 “说明书”，SQL 支持三种注释方式：\n\n单行注释（#）：MySQL 特有的方式，#后直接写注释内容\n\n# 查询所有学生信息SELECT * FROM student;\n\n\n单行注释（– ）：通用方式，–后必须加空格\n\n-- 查询年龄大于18的学生SELECT * FROM student WHERE age &gt; 18;\n\n\n多行注释（&#x2F;* *&#x2F;）：适合大段说明\n\n/*功能：查询学生表中年龄大于20且性别为男的记录*/SELECT * FROM student WHERE age &gt; 20 AND gender = &#x27;男&#x27;;\n\n四、命名规则合理的命名是规范的核心，需注意以下几点：\n\n长度限制：数据库名、表名最多 30 个字符，变量名最多 29 个字符。\n\n允许字符：只能包含 A-Z、a-z、0-9、_（下划线），不可包含空格。\n\n唯一性：\n\n\n\n\n同一 MySQL 实例中，数据库名不可重复；\n\n\n\n同一数据库中，表名不可重复；\n\n\n\n同一表中，字段名不可重复。\n\n\n\n\n避免保留字：若字段名与关键字（如order、select）重名，需用 ** 着重号（&#96;）** 包裹：\n\n-- 正确：用`包裹关键字作为表名CREATE TABLE `order` (  id INT,  order_no VARCHAR(20));\n\n\n类型一致性：同一字段在不同表中类型需一致（如user_id在 A 表是INT，在 B 表也应是INT）。\n\n五、数据导入指令当需要批量导入数据时，可通过source命令导入 SQL 文件，步骤如下：\n\n打开命令行客户端，登录 MySQL：\n\nmysql -u 用户名 -p\n\n\n输入密码后，使用source指令导入（文件路径需用绝对路径）：\n\nsource D:\\data\\mydb.sql; -- Windows系统-- 或source /home/user/data/mydb.sql; -- Linux系统\n\n六、基础 SELECT 语句SELECT是 SQL 中最常用的查询语句，基础语法如下：\n1. 选择全部列SELECT * FROM 表名; -- 查询表中所有字段的所有记录-- 示例：查询student表所有数据SELECT * FROM student;\n\n2. 选择指定列SELECT 列1, 列2, ... FROM 表名;-- 示例：查询student表的id和name字段SELECT id, name FROM student;\n\n3. 列的别名规则\n别名无空格时，可省略双引号：\n\nSELECT id AS 编号, name 姓名 FROM student; -- 正确\n\n\n别名有空格时，必须加双引号：\n\nSELECT id AS &quot;学生编号&quot;, name &quot;学生姓名&quot; FROM student; -- 正确SELECT id AS 学生 编号; -- 错误（空格未加引号）\n\n总结遵循 SQL 规范不仅能让代码更易读、易维护，还能减少因语法问题导致的错误。核心要点包括：统一大小写、规范命名、正确使用注释、遵循标点规则。熟练掌握这些基础，能为复杂的数据库操作打下坚实基础。                                                    \n","categories":["数据库"],"tags":["MySQL"]},{"title":"键盘灯光切换和系统切换的基本使用","url":"/2025/07/22/%E9%94%AE%E7%9B%98%E7%81%AF%E5%85%89%E5%88%87%E6%8D%A2%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%88%87%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"RK-G98 键盘灯光切换和系统切换的基本使用涵盖灯光控制、系统切换、连接方式等实用操作，、系统切换与键位适配\n1. Windows 与 Mac 模式切换\n切换至 Windows 系统：Fn + A\n\n适配 Windows 快捷键（如Win键、Ctrl+C&#x2F;V等）。\n\n切换至 Mac 系统：Fn + S\n\n适配 Mac 快捷键（如⌘键、⌥键映射等）。\n\n模式切换验证：\n\n切换后键盘指示灯会闪烁 3 次，部分功能键（如Caps Lock）逻辑会自动调整。\n2. 特殊键位互换\nCaps Lock 与左 Ctrl 互换：Fn + Caps\n\n适合习惯使用Ctrl键位于左下角的用户。\n\nWin 键屏蔽 &#x2F; 开启：Fn + Win\n\n游戏时防止误触 Win 键导致卡顿。\t\t\t\n二、灯光控制与自定义1. 基础灯光调节\n亮度调节：\n\n\n增加亮度：Fn + ↑（共 5 档，最大亮度时指示灯闪烁）。\n\n\n\n降低亮度：Fn + ↓（可关闭背光，指示灯闪烁提示最小值）。\n\n\n动态速度调节：\n\n\n减慢速度：Fn + ←（适用于跑马灯、呼吸灯等动态模式）。\n\n\n\n加快速度：Fn + →（最高速时指示灯闪烁）。\n\n\n\n2. 预设背光模式切换(有两种版本)\n全模式循环  Fn + prtsc（ps） 或者 Fn + \\| 遍历所有预设背光模式\n\n","categories":["其他"]}]