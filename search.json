[{"title":"Git基本使用（Windows版）","url":"/2025/07/19/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"Git基本使用（Windows版）参考Git教程 - 廖雪峰的官方网站\n\n安装gitgit\n测试是否安装成功\n方式一\n\nwin + r 打开控制台输入\ngit --version\n\n\n方式二\n\n右击&#x3D;&#x3D;》显示更多选项&#x3D;&#x3D;》git bash here\n或快捷键（shift + f10）\n\n配置Git$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;\n\n注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n创建版本库新建文件夹$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit\n\n注意：如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n\n$ mkdir learngit 创建一个空目录 为learngit\n$ cd learngit 进入目录 \n$ pwd 显示当前目录的路径\n$ cd  返回上一级目录 \ncd d:cyfor\\\\ggg\n$ ls 列出当前文件夹的所有文件或文件夹(不包括隐藏的文件)\n$ ls -ah 列出当前文件夹的所有文件或文件夹(包括隐藏的文件)\n\n变为Git仓库（将当前目录变成git可以管理的仓库）$ git init\n\n当前目录会多一个.git的目录\n\n$ git init          \tgit仓库初始化，把这个目录变成Git可以管理的仓库\n\n小结初始化一个Git仓库，使用git init命令。\n添加文件到Git仓库，分两步：\n\n使用命令git add ，注意，可反复多次使用，添加多个文件；\n如果有多个文件夹可以用 git add . 命令\n使用命令git commit -m ，完成。\n\n\n把文件添加到版本库$ git add 文件名/目录名（文件夹名）$ git commit -m &quot;本次提交的说明&quot;\n\n\n$ git add readme.txt\n 把文件添加到仓库\n$ git commit -m “wrote a readme file”\n 把文件提交到仓库 -m后面输入的是本次提交的说明\n$ git add . \t\n当前目录所有元素都加入（文件和文件夹）\n\n$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot;\n\ncommit可以一次提交很多文件，所以你可以多次add不同的文件\n查看仓库当前的状态$ git status\n\n查看具体修改的内容$ git diff\n\n\n时光穿梭显示所有日志提交$ git log 显示从最近到最远的提交日志$ git log --pretty=oneline 简朴显示\n\n版本回退首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n$ git reset --hard HEAD^\n\n--hard参数有啥意义？--hard会回退到上个版本的已提交状态，而--soft会回退到上个版本的未提交状态，--mixed会回退到上个版本已添加但未提交的状态。现在，先放心使用--hard。\n版本恢复方式一：知道版本号恢复\n办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：\n$ git reset --hard 1094a\n\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n方式二：寻找版本号恢复\n$ git reflog\n\n小结\nHEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。\n穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。\n要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。\n\n\n工作区和暂存区电脑中可以看到的目录（文件夹） &#x3D;&#x3D; 工作区\n版本库（工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库）\n版本库有stage和master（分支）、head（头指针）组成\n$ git status 是对工作区的情况$ git add xxx 是将工作区的内容提交到stage中$ git commit -m &quot;xxx&quot; 是将stage的内容提交到master分支中\n\n总结\n每次修改完文件，就add 放入stage中，再commit到分支，因为commit只会提交stage中的文件\n\n\n撤销修改情况一（未添加到stage中）：直接撤销\n$ git checkout -- readme.txt\n\n情况二（放入到stage中）：撤销到工作区再直接撤销\n用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区\n$ git reset HEAD readme.txt\n\n情况三（commit到分支中）：直接回退版本（前提是没有将本地版本库推送到远程）小结场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](##### 版本恢复)一节，不过前提是没有推送到远程库。\n\n删除文件流程：\n\n先删除工作区的文件（命令或手动）\n使用git rm 和git add\n\n删除工作区的文件\n$ rm test.txt\n\n删除版本库中的文件\n$ git rm test.txt$ git commit -m &quot;remove test.txt&quot;\n\n删错文件，从版本库中恢复\ngit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n$ git checkout -- test.txt\n\n 注意\n从来没有被添加到版本库就被删除的文件，是无法恢复的！\n小结\n命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。\n\n远程仓库添加远程仓库第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n第2步：登陆GitHub，点击右上角的头像，settings，SSH与GPG公钥\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n第3步：在主页右上角找到“Create a new repo”按钮，创建一个新的仓库\n第4步：连接对应的仓库\n$ git remote add origin git@github.com:michaelliao/learngit.git\n\n添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n第5步：把本地库的所有内容推送到远程库上\n$ git push -u origin master\n\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n从现在起，只要本地作了提交，就可以通过命令：\n$ git push origin master\n\nSSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：\nThe authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?\n\n这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。\nGit会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：\nWarning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.\n\n这个警告只会出现一次，后面的操作就不会有任何警告了。\n如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。\n查看远程库信息如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm &lt;name&gt;命令。使用前，建议先用git remote -v查看远程库信息：\n$ git remote -v\n\n删除远程库根据名字删除，比如删除origin：\n$ git remote rm origin\n\n此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。\n小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；\n关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；\n关联后，使用命令git push -u origin master第一次推送master分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n从远程库克隆git clone 目标地址.git\n$ git clone git@github.com:michaelliao/gitskills.git\n\n你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n小结要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。\nGit支持多种协议，包括https，但ssh协议速度最快。\n\n分支处理创建dev分支，然后切换到dev分支$ git checkout -b devSwitched to a new branch &#x27;dev&#x27;\n\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n$ git branch dev$ git checkout devSwitched to branch &#x27;dev&#x27;\n\ngit branch&#96;命令查看当前分支$ git branch* dev  master\n\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n切换分支git checkout 分支名\n$ git checkout master\n\n现在，我们把dev分支的工作成果合并到master分支上：\n合并分支$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+)\n\ngit merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n合并完成后，就可以放心地删除dev分支了：\n删除分支$ git branch -d devDeleted branch dev (was b17d20e).\n\n删除后，查看branch，就只剩下master分支了：\n查看分支$ git branch* master\n\n小结Git鼓励大量使用分支：\n查看分支：git branch\n创建分支：git branch &lt;name&gt;\n切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;\n创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;\n合并某分支到当前分支：git merge &lt;name&gt;\n删除分支：git branch -d &lt;name&gt;\n\n冲突分支修改的当行，commit后。主分支有修改当行，commit。会有冲突。\n解决方案（修改再提交）\n我们可以直接查看readme.txt的内容：\nGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1\n\nGit用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：\nGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.Creating a new branch is quick and simple.\n\n其他用带参数的git log也可以看到分支的合并情况：\n$ git log --graph --pretty=oneline --abbrev-commit\n\n尝试拉取远程更改时允许合并不相关的提交历史：\ngit pull origin master --allow-unrelated-histories\n\n\n\ncd(Change directory)    改变文件夹\nmkdir(Make directory)    新建文件夹\npwd(Print working directory)   显示当前目录\ninit(Initialization)    初始化\nstatus    情况\ncommit    提交\nstage\t暂存区\n添加某个文件时，该文件必须在当前目录下存在，用ls或者dir命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名\n$ git remote add origin git@github.com:michaelliao&#x2F;learngit.git\n请千万注意，把上面的michaelliao替换成你自己的GitHub账户名\n添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n$ git push -u origin master\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n只要本地作了提交，就可以通过命令：\n$ git push origin master\ngit remote rm 命令。使用前，建议先用git remote -v查看远程库信息：\n$ git remote -v\n根据名字删除，比如删除origin：\n$ git remote rm origin\n此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。\n要关联一个远程库，使用命令git remote add origin git@server-name:path&#x2F;repo-name.git；\n关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；\n关联后，使用命令git push -u origin master第一次推送master分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；\n","categories":["计算机"],"tags":["Git"]},{"title":"CentOS7网络配置失败？从报错到解决的完整指南","url":"/2025/07/26/CentOS7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5%EF%BC%9F%E4%BB%8E%E6%8A%A5%E9%94%99%E5%88%B0%E8%A7%A3%E5%86%B3%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","content":"CentOS 7 网络配置失败？从报错到解决的完整指南在使用 CentOS 7 时，网络配置是日常操作的基础，但偶尔会遇到「重启网络服务失败」的问题。本文结合实际场景，详细讲解如何排查网络服务报错（Job for network.service failed），从配置文件到服务依赖，一步步定位问题并解决，适用于新手和有一定经验的用户。\n一、问题现象：网络服务重启失败执行重启网络服务的命令后，出现如下错误：\n[root@server01 ~]# systemctl restart networkJob for network.service failed because the control process exited with error code. See &quot;systemctl status network.service&quot; and &quot;journalctl -xe&quot; for details.\n\n此时网络可能完全不可用，或配置不生效。这种情况多由 配置文件错误 或 服务冲突 导致，无需慌张，按步骤排查即可解决。\n二、核心排查步骤1. 先看配置文件：语法错误是重灾区网络配置文件是最容易出错的地方，路径为：\n&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-&lt;网卡名&gt;（如 ifcfg-ens33）\n检查配置文件内容执行命令查看当前配置：\ncat /etc/sysconfig/network-scripts/ifcfg-ens33\n\n以静态 IP 配置为例，正确的格式应类似这样（关键参数已标注）：\nTYPE=Ethernet         # 网络类型：以太网BOOTPROTO=static      # 启动协议：静态IP（手动配置）NAME=ens33            # 连接名称（需与网卡名对应）DEVICE=ens33          # 网卡设备名（必须与实际网卡一致）ONBOOT=yes            # 开机自动激活网卡IPADDR=192.168.10.101 # 静态IP地址（根据实际网段修改）NETMASK=255.255.255.0 # 子网掩码（或用 PREFIX=24 表示）GATEWAY=192.168.10.2  # 网关地址（通常是路由器IP）DNS1=192.168.10.2     # DNS服务器（可填公共DNS如114.114.114.114）\n\n配置文件常见错误\n参数拼写错误：如 IPADRR（少打一个 D）、GATEWY（少打 A），这类错误会直接导致服务启动失败。\n\n网卡名不匹配：DEVICE&#x3D;ens33 需与实际网卡名一致，可通过 ip link show 查看真实网卡名（可能是 ens37 等）。\n\n重复参数：同时存在 NETMASK 和 PREFIX 且值冲突（如 NETMASK&#x3D;255.255.255.0 与 PREFIX&#x3D;23 不匹配）。\n\n多余空格：参数值前后有空格（如 IPADDR&#x3D; 192.168.10.101），会被识别为无效值。\n\n\n2. 服务冲突：NetworkManager 与 network 的 “恩怨”CentOS 7 中有两个网络管理服务：\n\nnetwork：传统网络服务，配置文件驱动。\n\nNetworkManager：现代网络管理工具，图形化界面和命令行均支持，默认启用。\n\n\n两者同时运行时可能冲突，导致 network 服务启动失败。\n检查服务状态# 查看 NetworkManager 状态systemctl status NetworkManager# 查看 network 服务状态（包含错误日志）systemctl status network -l\n\n若输出中包含 conflict（冲突）或 dependency failed（依赖失败），大概率是服务冲突导致。\n3. 特殊场景：克隆虚拟机的 “隐藏坑”如果你的系统是从其他虚拟机克隆而来，可能会遇到 网卡硬件信息冲突：\n\n克隆会复制原虚拟机的 UUID（网络连接唯一标识）和 MAC 地址，导致新系统无法识别网卡。\n\n表现为：ip addr 中看不到网卡（如 ens33 缺失），或 lspci 检测不到网络硬件。\n\n\n三、解决方案：分场景处理场景 1：配置文件错误导致的启动失败修复配置文件直接编辑配置文件，修正错误参数：\nvim /etc/sysconfig/network-scripts/ifcfg-ens33\n\n确保关键参数正确（以静态 IP 为例）：\nTYPE=EthernetBOOTPROTO=staticNAME=ens33DEVICE=ens33ONBOOT=yesIPADDR=192.168.10.101 #替换为自己的ipPREFIX=24GATEWAY=192.168.10.2 #替换为自己的网关DNS1=192.168.10.2 #替换为自己的DNS\n\n保存后重启网络服务：\nsystemctl restart network\n\n场景 2：服务冲突导致的启动失败方案 A：禁用 NetworkManager（仅用 network 服务）适合纯命令行环境，或习惯用配置文件管理网络：\n 重复上面场景一的操作（在末尾加上）\nNM_CONTROLLED=no  # 关键：禁用 NetworkManager 管理\n\n# 停止并禁用 NetworkManagersystemctl stop NetworkManagersystemctl disable NetworkManager# 启用并重启 network 服务systemctl enable networksystemctl restart network\n\n场景 3：克隆虚拟机的网卡识别问题克隆后系统未识别网卡，表现为 ip addr 中无 ens33，且 lspci | grep -i network 无输出。\n解决步骤：\n检查虚拟机网络适配器（以 VMware 为例）：\n\n关闭虚拟机 → 右键「设置」→「网络适配器」→ 确认「已连接」和「启动时连接」已勾选，网络模式选择「NAT」或「桥接」。\n\n重建网卡配置：\n\n# 删除原网卡配置文件rm -f /etc/sysconfig/network-scripts/ifcfg-ens33# 删除 udev 规则（克隆残留的硬件信息）rm -f /etc/udev/rules.d/70-persistent-net.rules# 重启系统（自动生成新配置）reboot\n\n\n重启后，用 ip link show 确认网卡已识别（如 ens33），再按场景 1 配置网络即可。\n\n四、验证网络是否正常配置完成后，通过以下命令验证：\n# 查看IP是否生效ip addr show ens33  # 应显示配置的静态IP# 查看路由是否正确（默认网关是否生效）ip route show       # 应包含 &quot;default via 网关IP dev ens33&quot;# 测试连通性ping 网关IP -c 3    # 如 ping 192.168.10.2 -c 3ping 114.114.114.114 -c 3  # 测试公网连通性\n\n若均正常，说明网络配置已生效。\n五、总结：避坑指南\n配置文件是基础：仔细检查参数拼写、网卡名匹配，避免多余空格。\n\n服务二选一：要么用 network 服务（禁用 NetworkManager），要么用 NetworkManager（禁用 network），不要同时启用。\n\n克隆虚拟机注意：必须删除原网卡配置和 udev 规则，否则会因硬件信息冲突导致网卡不识别。\n\n公共 DNS 更可靠：配置 DNS1&#x3D;114.114.114.114 或 8.8.8.8，避免依赖网关 DNS。\n\n\n通过以上步骤，90% 以上的网络服务启动失败问题都能解决。如果仍有问题，可通过 journalctl -xe | grep network 查看详细错误日志，针对性排查即可。\n","categories":["VMWare"]},{"title":"Hexo+Butterfly 优雅配置音乐播放器","url":"/2025/08/14/Hexo-Butterfly-%E4%BC%98%E9%9B%85%E9%85%8D%E7%BD%AE%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","content":"Hexo+Butterfly 优雅配置音乐播放器在博客中嵌入音乐播放器，能为访客营造更沉浸的阅读氛围。Hexo 搭配 Butterfly 主题时，借助 APlayer 和 Meting.js 可快速实现这一功能，无需复杂开发。本文将详细讲解配置流程、参数含义及实用技巧，帮你轻松打造专属音乐博客。\n一、核心工具与原理配置音乐播放器需依赖两个关键工具，二者分工明确：\n\nAPlayer：轻量级 HTML5 音乐播放器内核，负责渲染播放界面、控制播放逻辑（如暂停、切换歌曲）；\n\nMeting.js：音乐平台 API 封装工具，支持直接调用网易云、QQ 音乐等平台的播放列表，无需自建音乐文件库。\n\n\n工作流程：Meting.js 从音乐平台获取播放列表数据，APlayer 将数据渲染为可视化播放器，实现 “一键接入在线音乐” 的效果。\n二、前置准备\n环境要求：\n\n已安装 Hexo 博客框架及 Butterfly 主题（建议使用最新版本，兼容性更好）。\n若未安装主题，可参考 Butterfly 官方文档 完成部署。\n\n获取音乐资源 ID：\n\n以网易云音乐为例，打开目标播放列表，URL 中 id&#x3D; 后的数字即为播放列表 ID（如 https://music.163.com/playlist?id=13293433925 中，13293433925 就是需用到的 ID）。\n支持的平台：网易云（netease）、QQ 音乐（qq）、虾米（xiami）等。\n三、详细配置步骤1. 修改主题配置文件Butterfly 主题通过 _config.butterfly.yml 管理注入代码，无需修改主题源码，步骤如下：\n（1）打开配置文件在 Hexo 根目录中找到 _config.butterfly.yml（主题配置文件，非 Hexo 根目录的 _config.yml）。\n（2）配置注入资源搜索 inject 配置项，注入 APlayer 样式、Meting.js 脚本及播放器容器：\ninject:  head:  # 注入到&lt;head&gt;标签，加载样式    - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;    bottom:  # 注入到页面底部，加载脚本和播放器    - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&quot;&gt;&lt;/script&gt;    # 播放器容器配置    - &lt;div class=&quot;aplayer no-destroy&quot;          data-id=&quot;13293433925&quot;  # 替换为你的播放列表ID\t\t\t(修改你自己的id)         data-server=&quot;netease&quot;  # 音乐平台（netease/qq/xiami）   (修改,选择你自己的音乐平台)         data-type=&quot;playlist&quot;   # 资源类型（playlist/song/album）         data-fixed=&quot;true&quot;      # 是否固定在底部（true/false）         data-mini=&quot;true&quot;       # 固定时是否迷你显示（true/false）         data-listFolded=&quot;false&quot; # 是否折叠播放列表（true/false）         data-order=&quot;random&quot;    # 播放顺序（random/normal/single）         data-preload=&quot;auto&quot;    # 预加载模式（auto/none/metadata）         data-autoplay=&quot;false&quot;  # 是否自动播放（建议false，避免浏览器拦截）         data-theme=&quot;#409EFF&quot;&gt;  # 主题色（与Butterfly主题色匹配）      &lt;/div&gt;\n\n2. 配置播放器全局开关在 _config.butterfly.yml 中找到 aplayerInject 配置，控制播放器是否启用及显示范围：\naplayerInject:  enable: true  # 全局启用播放器（true/false）  per_page: true  # 所有页面均显示（true）或仅在指定页面显示（false）\n\n3. 生效配置执行以下命令清理缓存并启动本地服务，查看效果：\nhexo clean &amp;&amp; hexo s  # 清理缓存后启动服务，访问 http://localhost:4000 验证\n\n四、关键参数详解播放器的核心功能由 data-* 参数控制，理解这些参数可灵活定制播放器行为：\n\n\n\n参数名\n含义与可选值\n推荐配置\n\n\n\ndata-id\n音乐资源唯一标识（播放列表 &#x2F; 歌曲 ID）\n替换为自己的播放列表 ID\n\n\ndata-server\n音乐平台\nnetease（资源丰富，稳定性好）\n\n\ndata-type\n资源类型\nplaylist（播放列表，多首歌循环）\n\n\ndata-fixed\n是否固定在页面底部\ntrue（不遮挡内容，体验更佳）\n\n\ndata-mini\n固定模式下是否迷你显示\ntrue（节省空间）\n\n\ndata-order\n播放顺序\nrandom（随机播放，增加新鲜感）\n\n\ndata-autoplay\n是否自动播放\nfalse（浏览器默认拦截自动播放）\n\n\ndata-theme\n主题色（十六进制颜色码）\n与 Butterfly 主题主色一致（如 #409EFF）\n\n\n五、实用技巧与个性化切换音乐平台只需修改 data-server 和对应平台的 data-id：\n\nQQ 音乐：data-server&#x3D;”qq” data-id&#x3D;”QQ播放列表ID”\n\n虾米音乐：data-server&#x3D;”xiami” data-id&#x3D;”虾米播放列表ID”\n\n\n六、注意事项\nAPI 访问限制：\n\n音乐平台 API 可能存在防盗链机制，若播放器加载失败，可尝试：\n\n\n更换播放列表（避免版权受限的资源）；\n\n\n\n使用 HTTPS 协议（部分平台要求）。\n\n\n\n\n性能优化：\n\n\n\n播放列表不宜过大（建议 10-30 首歌），减少加载时间；\n\n\n\n关闭不必要的参数（如 data-preload&#x3D;”none” 关闭预加载）。\n\n\n\n\n兼容性问题：\n\n\n\n确保 APlayer 和 Meting.js 版本匹配（本文使用官方推荐的 CDN 版本，兼容性最佳）；\n\n\n\n低版本浏览器（如 IE）可能不支持，建议使用现代浏览器（Chrome、Edge 等）。\n\n\n\n总结：核心要点速览\n\n\n环节\n关键操作\n\n\n\n核心工具\nAPlayer（播放器界面）+ Meting.js（音乐 API 对接）\n\n\n配置入口\n主题配置文件 _config.butterfly.yml 的 inject 项\n\n\n必改参数\ndata-id（播放列表 ID）、data-server（音乐平台）\n\n\n显示控制\n全局 &#x2F; 单页显示通过 aplayerInject.per_page 和 Front-matter 控制\n\n\n避坑指南\n关闭自动播放、控制播放列表大小、注意 API 限制\n\n\n通过以上步骤，你的 Hexo 博客将拥有一个美观且功能完善的音乐播放器。如需进一步定制，可参考 APlayer 官方文档 和 Meting.js 文档 探索更多高级功能（如歌词显示、自定义控件）。\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo 中 Butterfly 主题修改字体大小教程","url":"/2025/08/11/Hexo-%E4%B8%AD-Butterfly-%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E6%95%99%E7%A8%8B/","content":"Hexo 中 Butterfly 主题修改字体大小教程在使用 Hexo 搭建博客并采用 Butterfly 主题时，有时我们需要根据自己的阅读习惯调整字体大小，下面就来介绍具体的修改方法。\n找到配置文件首先，我们需要找到字体大小设置所在的文件，路径为：\n\\node_modules\\hexo-theme-butterfly\\source\\css\\var.styl\n\n可以通过文件管理器导航到该路径，也可以在博客的开发工具中直接定位到这个文件。\n修改字体大小参数打开var.styl文件后，我们会看到关于字体大小的配置代码：\n// Global Variables$font-size = hexo-config(&#x27;font.global_font_size&#x27;) ? convert(hexo-config(&#x27;font.global_font_size&#x27;)) : 18px  // 全局字体大小$code-font-size = hexo-config(&#x27;font.code_font_size&#x27;) ? convert(hexo-config(&#x27;font.code_font_size&#x27;)) : var(--global-font-size)  // 代码字体大小$font-color = #1F2D3D  // 字体颜色\n\n\n$font-size：这是全局字体大小的设置。代码的意思是，如果在 Hexo 的配置文件中设置了font.global_font_size，则使用该配置的值；如果没有设置，则默认使用 18px（如示例中修改后的数值）。我们可以直接修改这里的默认值（如 18px）来调整全局字体大小。\n\n$code-font-size：这是代码块字体大小的设置。同理，如果配置了font.code_font_size则使用该值，否则默认使用全局字体大小（var(–global-font-size)）。\n\n\n生效修改修改完成后，保存文件，然后在终端中执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s命令，重新生成并预览博客，就可以看到字体大小的变化了。如果是部署在服务器上，还需要执行hexo d命令重新部署。\n通过这种方式，我们可以简单有效地调整 Butterfly 主题下的字体大小，让博客更符合自己的阅读需求。\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo使用Butterfly主题配置页脚网站运行实时时间","url":"/2025/07/26/Hexo%E4%BD%BF%E7%94%A8Butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%A1%B5%E8%84%9A%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%97%B6%E9%97%B4/","content":"Hexo使用Butterfly主题配置页脚网站运行实时时间一、找配置文件寻找&#x2F;node_modules&#x2F;hexo-theme-butterfly&#x2F;layout&#x2F;includes&#x2F;footer.pug文件，添加完之后已经成功了，但是在左下角\n里面的代码直接全部替换为\n- const &#123; nav, owner, copyright, custom_text &#125; = theme.footerif nav  .footer-flex    for block in nav      .footer-flex-items(style=`$&#123; block.width ? &#x27;flex-grow:&#x27; + block.width : &#x27;&#x27; &#125;`)        for blockItem in block.content          .footer-flex-item            .footer-flex-title= blockItem.title            .footer-flex-content              for subitem in blockItem.item                if subitem.html                  div!= subitem.html                else if subitem.url                  a(href=url_for(subitem.url), target=&#x27;_blank&#x27; title=subitem.title)= subitem.title                else if subitem.title                  div!= subitem.title.footer-running-time  span 本站已运行：&lt;span id=&quot;running-time&quot;&gt;0 天 0 小时 0 分钟 0 秒&lt;/span&gt;script.  function updateRunningTime() &#123;    const startDate = new Date(&quot;2025-07-20T00:00:00&quot;); // 修改为你自己的建站时间    const now = new Date();    let diff = Math.floor((now - startDate) / 1000); // 时间差（秒）    const days = Math.floor(diff / 86400);    diff -= days * 86400;    const hours = Math.floor(diff / 3600) % 24;    diff -= hours * 3600;    const minutes = Math.floor(diff / 60) % 60;    const seconds = diff % 60;    document.getElementById(&quot;running-time&quot;).innerText =      `$&#123;days&#125; 天 $&#123;hours&#125; 小时 $&#123;minutes&#125; 分钟 $&#123;seconds&#125; 秒`;  &#125;  // 页面加载后立即执行一次，之后每秒更新一次  document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;    updateRunningTime();    setInterval(updateRunningTime, 1000);  &#125;);.footer-other  .footer-copyright    if owner.enable      - const currentYear = new Date().getFullYear()      - const sinceYear = owner.since      span.copyright        if sinceYear &amp;&amp; sinceYear != currentYear          != `&amp;copy;$&#123;sinceYear&#125; - $&#123;currentYear&#125; By $&#123;config.author&#125;`        else          != `&amp;copy;$&#123;currentYear&#125; By $&#123;config.author&#125;`    if copyright.enable      - const v = copyright.version ? getVersion() : false      span.framework-info        if owner.enable &amp;&amp; nav          span.footer-separator |        span= _p(&#x27;footer.framework&#x27;) + &#x27; &#x27;        a(href=&#x27;https://hexo.io&#x27;)= `Hexo$&#123; v ? &#x27; &#x27; + v.hexo : &#x27;&#x27; &#125;`        span.footer-separator |        span= _p(&#x27;footer.theme&#x27;) + &#x27; &#x27;        a(href=&#x27;https://github.com/jerryc127/hexo-theme-butterfly&#x27;)= `Butterfly$&#123; v ? &#x27; &#x27; + v.theme : &#x27;&#x27; &#125;`  if theme.footer.custom_text    .footer_custom_text!= theme.footer.custom_text\n\n自定义CSS样式（更加美观）找到&#x2F;source文件夹，新建css文件夹，在css文件夹中新建custom.css文件，将下面代码全部复制到custom.css文件中\n\n.footer-running-time &#123;  font-size: 18px;  font-weight: bold;  text-align: center;  margin: 15px 0;  padding: 12px 18px;  border-radius: 10px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);  background: linear-gradient(90deg, #ffc0fa, #f375f3);  -webkit-background-clip: text;  -webkit-text-fill-color: transparent;  display: flex;  justify-content: center;  align-items: center;  gap: 12px;  flex-wrap: wrap;  transition: all 0.3s ease;  position: relative;&#125;.footer-running-time::before &#123;  content: &#x27;&#x27;;  position: absolute;  top: 0;  left: 0;  width: 100%;  height: 100%;  background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 1px, transparent 1px);  background-size: 4px 4px;  opacity: 0.3;  z-index: 0;  pointer-events: none;&#125;.footer-running-time i.fas.fa-hourglass &#123;  font-size: 20px;  margin-right: 6px;  color: #ffffff;  background: #ffc0cb;  border-radius: 50%;  padding: 8px;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);  animation: bounce 1.2s infinite;  z-index: 1;&#125;@keyframes bounce &#123;  0%, 100% &#123;    transform: translateY(0) scale(1);  &#125;  50% &#123;    transform: translateY(-6px) scale(1.05);  &#125;&#125;\n\n让CSS样式生效找到_config.butterfly.yml文件inject中的head属性\ninject:  head:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;&gt; #增加这一行\n效果图\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"Hexo 常用命令使用和详解","url":"/2025/08/11/Hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%92%8C%E8%AF%A6%E8%A7%A3/","content":"Hexo 常用命令使用和详解Hexo 作为一款高性能的静态博客框架，其命令行工具设计简洁却功能强大。无论是新手搭建第一个博客，还是老手批量管理内容，掌握核心命令都是提升效率的关键。详细解析 Hexo 常用命令的用法与技巧。\n一、内容管理：文章与页面的创建与发布1. 创建文章（默认布局为 post）hexo new &quot;文章标题&quot;  # 等价于 hexo new post &quot;文章标题&quot;\n\n\n生成路径：source&#x2F;_posts&#x2F;文章标题.md\n\nMarkdown 头部信息（Front-matter）：自动生成包含标题、日期、标签等元数据的头部，例如：\n\n\n---title: 文章标题date: 2025-08-10 15:30:00tags:- Hexo---\n\n2. 创建独立页面（如关于页、分类页）hexo new page &quot;页面名称&quot;  # 如 hexo new page &quot;about&quot;\n\n\n生成路径：source&#x2F;页面名称&#x2F;index.md\n\n特点：页面 URL 为 域名&#x2F;页面名称（如 https://example.com/about），适合放置固定内容\n\n\n二、生成与预览：本地验证内容效果1. 生成静态文件hexo generate  # 简写：hexo g\n\n\n作用：将 Markdown 内容、主题模板编译为静态 HTML&#x2F;CSS&#x2F;JS，输出到 public 目录\n\n2. 本地预览博客hexo server  # 简写：hexo s\n\n\n默认访问地址：http://localhost:4000\n\n实用参数：\n\n\nhexo s -p 5000：指定端口（解决 4000 端口被占用问题）\n\n\n\nhexo s -i 0.0.0.0：允许局域网其他设备访问（如手机预览移动端效果）\n\n\n\n3. 清理缓存与生成文件hexo clean\n\n\n作用：删除 public 目录（生成的静态文件）和 db.json（缓存数据）\n\n何时使用：\n\n\n主题更换后（避免旧主题文件残留）\n\n\n\n内容更新后页面显示异常（如样式错乱、内容缺失）\n\n\n\n部署前（确保发布的是最新版本）\n\n\n\n4. 高效部署组合命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n\n清理→生成→本地预览\n默认访问地址：http://localhost:4000\nhexo clean &amp;&amp; hexo g -d  # 清理→生成→部署一站式操作\n\n先清理旧文件避免缓存干扰，再生成最新静态文件，最后直接部署，是日常发布的最佳实践\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"JDK7 与 JDK8 中 HashMap 的演进：从问题到优化的全面解析","url":"/2025/08/11/JDK7-%E4%B8%8E-JDK8-%E4%B8%AD-HashMap-%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8E%E9%97%AE%E9%A2%98%E5%88%B0%E4%BC%98%E5%8C%96%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/","content":"JDK7 与 JDK8 中 HashMap 的演进：从问题到优化的全面解析HashMap 作为 Java 集合框架中使用最广泛的工具类，在 JDK7 到 JDK8 的版本迭代中经历了根本性的设计升级。从单纯的 “数组 + 链表” 到引入红黑树优化，从线程不安全的头插法到更稳健的尾插法，这些变化不仅解决了旧版本的性能瓶颈，更体现了 Java 对实际开发需求的持续响应。本文将对比解析两个版本的核心设计，带你理解 HashMap 的演进逻辑。\n一、JDK7 HashMap：简单设计下的性能与安全隐患JDK7 的 HashMap 采用 “数组 + 单向链表” 的基础结构，实现简单但在高频场景下暴露了明显缺陷。\n1. 底层结构：数组 + 单向链表\n数组（Entry [] table）：作为存储节点的 “桶”，长度始终为 2 的幂（初始 16），通过(n-1) &amp; hash计算索引（等价于取模，效率更高）。\n\n链表（Entry 节点）：每个节点包含hash、key、value和next指针，用于解决哈希冲突 —— 当多个 key 计算出相同索引时，用链表串联节点。\n\n\n2. 核心问题点\n头插法导致的线程安全风险：新节点插入链表头部（newEntry.next &#x3D; table[i]; table[i] &#x3D; newEntry），多线程扩容时可能形成环形链表，导致get操作陷入无限循环。\n\n链表过长的性能瓶颈：无红黑树优化，当哈希冲突严重时，链表长度可能急剧增长，查询时间复杂度退化为 O (n)。\n\n扩容效率低：节点迁移时需重新计算哈希索引，且头插法会导致链表顺序反转。\n\n\n3. 关键方法：put 流程的隐患// JDK7 put核心逻辑简化public V put(K key, V value) &#123;    if (table == EMPTY_TABLE) &#123;        inflateTable(threshold); // 初始化数组    &#125;    if (key == null) return putForNullKey(value);    int hash = hash(key);    int i = indexFor(hash, table.length);    // 遍历链表检查重复key    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;        if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;            V oldValue = e.value;            e.value = value;            return oldValue;        &#125;    &#125;    modCount++;    addEntry(hash, key, value, i); // 头插法插入新节点    return null;&#125;\n\n二、JDK8 HashMap：红黑树带来的性能革命JDK8 针对 JDK7 的缺陷进行了全方位优化，引入红黑树和尾插法，彻底改写了 HashMap 的性能表现。\n1. 底层结构：数组 + 链表 + 红黑树的复合设计\n数组（Node [] table）：保留 2 的幂长度特性，但初始化时机推迟到首次put（延迟初始化，节省内存）。\n\n链表（Node 节点）：仅在哈希冲突较少时使用，新节点采用尾插法插入，避免链表反转。\n\n红黑树（TreeNode 节点）：当链表长度超过 8 且数组长度≥64时，链表转为红黑树（查询复杂度降至 O (logn)）；当节点数≤6 时，自动还原为链表（减少树结构维护成本）。\n\n\n2. 核心改进点\n哈希算法优化：通过高位异或（h ^ (h &gt;&gt;&gt; 16)）让高位信息参与索引计算，减少冲突概率：\n\nstatic final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;\n\n\n尾插法插入节点：新节点添加到链表尾部，避免多线程扩容时的环形链表问题（但仍非线程安全）。\n\n高效扩容机制：节点迁移时无需重新计算哈希，通过(hash &amp; oldCap)判断是否迁移至 “原索引 + 旧容量” 位置，大幅提升扩容效率。\n\n\n3. 关键方法：put 流程的优化// JDK8 put核心逻辑简化final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length; // 延迟初始化    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null); // 桶为空直接插入    else &#123;        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp; ((k = p.key) == key || key.equals(k)))            e = p; // 命中重复key        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 红黑树插入        else &#123;            // 链表插入，尾插法            for (int binCount = 0; ; ++binCount) &#123;                if ((e = p.next) == null) &#123;                    p.next = newNode(hash, key, value, null);                    // 满足条件时转为红黑树                    if (binCount &gt;= TREEIFY_THRESHOLD - 1)                        treeifyBin(tab, hash);                    break;                &#125;                if (e.hash == hash &amp;&amp; key.equals(e.key)) break;                p = e;            &#125;        &#125;        if (e != null) &#123; // 覆盖重复key的value            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            return oldValue;        &#125;    &#125;    ++modCount;    if (++size &gt; threshold) resize(); // 检查扩容    return null;&#125;\n\n三、JDK7 与 JDK8 HashMap 核心差异对比\n\n\n特性\nJDK7 HashMap\nJDK8 HashMap\n\n\n\n底层结构\n数组 + 单向链表\n数组 + 链表 + 红黑树\n\n\n节点插入方式\n头插法（链表反转）\n尾插法（顺序保留）\n\n\n哈希计算\n二次哈希（效果有限）\n高位异或（减少冲突）\n\n\n扩容节点迁移\n重新计算索引\n基于旧容量判断（高效迁移）\n\n\n极端查询性能\nO (n)（链表过长）\nO (logn)（红黑树优化）\n\n\n初始化时机\n构造器直接创建数组\n首次 put 时延迟初始化\n\n\n线程安全隐患\n多线程扩容可能形成环形链表\n尾插法避免环形链表（仍不安全）\n\n\n四、实战指南：不同版本下的使用建议1. 版本选择\n新系统优先使用 JDK8 及以上版本，享受红黑树和高效扩容带来的性能提升。\n\n维护 JDK7 旧系统时，避免在多线程场景使用 HashMap，改用ConcurrentHashMap。\n\n\n2. 初始容量设置无论哪个版本，均需根据预期数据量设置初始容量，减少扩容次数：\n初始容量 &#x3D; (预期元素数 &#x2F; 0.75) + 1（0.75 为默认加载因子）。\n例如：存储 1000 个元素，建议初始容量为(1000&#x2F;0.75)+1≈1334（实际会调整为 2048，2 的幂）。\n3. 线程安全处理\nJDK7&#x2F;8 的 HashMap 均线程不安全，多线程场景需替换为：\n\n\nConcurrentHashMap（推荐，JDK8 + 基于 CAS 实现，性能优异）；\n\n\n\nCollections.synchronizedMap()（全局锁，性能较差）。\n\n\n\n4. key 的设计原则\n优先使用不可变对象（如 String、Long），避免hashCode变化导致的查询异常。\n\n自定义类作为 key 时，必须同时重写hashCode()和equals()，保证逻辑一致。\n\n\n总结从 JDK7 到 JDK8，HashMap 的演进本质是 “解决实际问题” 的过程：用红黑树解决链表过长的性能问题，用尾插法规避线程安全风险，用延迟初始化优化内存占用。这些变化不仅提升了工具类的实用性，更体现了 “平衡时间与空间” 的设计哲学。\n理解两个版本的差异，不仅能帮助我们在开发中合理选型、规避风险，更能让我们从源码层面学到 “发现问题 - 解决问题” 的思维方式 —— 这正是深入学习 Java 集合框架的核心价值。\n","categories":["编程语言"],"tags":["JAVA","集合"]},{"title":"LinkedHashMap、HashSet、LinkedHashSet 深度解析：从源码到实战","url":"/2025/08/11/LinkedHashMap%E3%80%81HashSet%E3%80%81LinkedHashSet-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%AE%9E%E6%88%98/","content":"LinkedHashMap、HashSet、LinkedHashSet 深度解析：从源码到实战在 Java 集合框架中，LinkedHashMap、HashSet 和 LinkedHashSet 是基于 HashMap 衍生出的高频使用类。它们看似独立，实则底层紧密关联，各自在 “有序性” 和 “去重性” 上形成互补。本文将从源码实现入手，解析三者的设计逻辑与适用场景，帮你在开发中精准选型。\n一、LinkedHashMap：HashMap 的 “有序升级版”LinkedHashMap 是 HashMap 的子类，核心优势是支持有序存储，通过维护双向链表记录元素顺序，完美解决了 HashMap”无序” 的痛点。\n1. 底层结构：HashMap + 双向链表LinkedHashMap 的底层由两部分组成：\n\n哈希表：继承自 HashMap 的 “数组 + 链表 + 红黑树” 结构，保证键值对的高效存取；\n\n双向链表：额外维护一条贯穿所有节点的双向链表，记录元素的插入顺序或访问顺序。\n\n\n节点结构在 HashMap 的 Node 基础上新增了两个指针：\nstatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;    Entry&lt;K,V&gt; before, after; // 双向链表指针    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;        super(hash, key, value, next);    &#125;&#125;\n\n2. 核心特性：两种有序模式LinkedHashMap 通过accessOrder属性控制有序性（默认false）：\n\n插入顺序（accessOrder&#x3D;false）：迭代时与元素插入顺序一致，新增元素放在链表尾部。\n\nMap&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;();map.put(&quot;b&quot;, 2);map.put(&quot;a&quot;, 1);map.put(&quot;c&quot;, 3);// 迭代结果：b→a→c（与插入顺序相同）\n\n\n访问顺序（accessOrder&#x3D;true）：调用get、put等方法访问元素后，该元素会被移到链表尾部（最近访问的元素在尾部），天然适配 LRU（最近最少使用）缓存场景。\n\n3. 关键方法：实现 LRU 缓存通过重写removeEldestEntry方法，可自定义 “当新增元素后是否删除最老元素”：\n// 实现容量为3的LRU缓存Map&lt;String, Integer&gt; lruCache = new LinkedHashMap&lt;&gt;(16, 0.75f, true) &#123;    @Override    protected boolean removeEldestEntry(Map.Entry&lt;String, Integer&gt; eldest) &#123;        return size() &gt; 3; // 超过3个元素则删除最老的    &#125;&#125;;\n\n4. 与 HashMap 的核心差异\n\n\n特性\nHashMap\nLinkedHashMap\n\n\n\n有序性\n无序\n支持插入顺序 &#x2F; 访问顺序\n\n\n性能\n插入 &#x2F; 删除略快\n因维护双向链表，迭代效率更高\n\n\n内存占用\n较低\n较高（多维护双向链表指针）\n\n\n二、HashSet：基于 HashMap 的 “去重容器”HashSet 是专门用于元素去重的集合，底层完全依赖 HashMap 实现，可理解为 “只存 key 的 HashMap”。\n1. 底层实现：HashMap 的包装类HashSet 内部持有一个 HashMap 实例，所有操作均通过该 map 完成：\npublic class HashSet&lt;E&gt; &#123;    private transient HashMap&lt;E, Object&gt; map;    private static final Object PRESENT = new Object(); // 固定value    public HashSet() &#123;        map = new HashMap&lt;&gt;();    &#125;    // 添加元素本质是map的put操作    public boolean add(E e) &#123;        return map.put(e, PRESENT) == null; // key存在则返回false    &#125;&#125;\n\n2. 核心特性\n去重规则：与 HashMap 的 key 一致 —— 两个元素hashCode相等且equals返回 true，则视为重复。\n\n无序性：存储顺序与插入顺序无关（同 HashMap 的 key 特性）。\n\n允许 null 元素：但仅能存一个（null 的 hashCode 固定为 0）。\n\n\n3. 基础用法示例Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;apple&quot;);set.add(&quot;banana&quot;);set.add(&quot;apple&quot;); // 重复元素，添加失败System.out.println(set.size()); // 输出2// 遍历（无序）for (String s : set) &#123;    System.out.println(s); // 顺序不确定&#125;\n\n三、LinkedHashSet：HashSet 的 “有序版”LinkedHashSet 是 HashSet 的子类，底层依赖 LinkedHashMap 实现，同时具备去重性和插入顺序性。\n1. 底层实现：LinkedHashMap 的包装类与 HashSet 类似，LinkedHashSet 通过父类构造器初始化 LinkedHashMap：\npublic class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;    public LinkedHashSet() &#123;        // 调用HashSet的构造器，实际创建LinkedHashMap        super(16, 0.75f, true);    &#125;&#125;// HashSet中对应的构造器HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125;\n\n2. 核心特性\n有序性：默认按插入顺序排序（迭代时与插入顺序一致），且顺序不随元素访问变化（区别于 LinkedHashMap 的访问顺序）。\n\n去重性：与 HashSet 一致，依赖 LinkedHashMap 的 key 去重逻辑。\n\n\n3. 用法示例Set&lt;String&gt; linkedSet = new LinkedHashSet&lt;&gt;();linkedSet.add(&quot;b&quot;);linkedSet.add(&quot;a&quot;);linkedSet.add(&quot;c&quot;);// 遍历（按插入顺序）for (String s : linkedSet) &#123;    System.out.println(s); // 输出：b→a→c&#125;\n\n四、三者对比与实战选型1. 核心差异对比表\n\n\n集合类型\n底层依赖\n有序性\n去重性\n典型应用场景\n\n\n\nLinkedHashMap\nHashMap + 双向链表\n插入顺序 &#x2F; 访问顺序\n键唯一\nLRU 缓存、有序映射、历史记录\n\n\nHashSet\nHashMap\n无序\n元素唯一\n标签去重、快速判重\n\n\nLinkedHashSet\nLinkedHashMap\n插入顺序\n元素唯一\n有序去重（如日志记录、流程步骤）\n\n\n2. 实战选型建议\n需要键值对且有序：用 LinkedHashMap（如配置参数按插入顺序输出）。\n\n仅需元素去重且无序：用 HashSet（如用户标签去重）。\n\n需去重且保留插入顺序：用 LinkedHashSet（如接口调用参数记录）。\n\n高频迭代操作：优先选 LinkedHashMap&#x2F;LinkedHashSet（迭代效率更高）。\n\n内存敏感场景：优先选 HashMap&#x2F;HashSet（内存占用更低）。\n\n\n总结LinkedHashMap、HashSet 和 LinkedHashSet 的设计充分体现了 Java 集合框架的 “复用性” 思想：\n\n给 HashMap 加双向链表，得到支持有序的 LinkedHashMap；\n\n封装 HashMap 的 key，得到用于去重的 HashSet；\n\n用 LinkedHashMap 替代 HashMap，得到有序去重的 LinkedHashSet。\n\n\n理解这种 “基于已有实现扩展功能” 的设计思路，不仅能帮你快速掌握 API 用法，更能在实际开发中学会 “站在巨人肩膀上” 设计简洁高效的代码。记住：没有最好的集合，只有最适合场景的选择。\n","categories":["编程语言"],"tags":["JAVA","集合"]},{"title":"MySQL 5.7 字符集设置指南：从乱码根源到彻底解决","url":"/2025/08/14/MySQL-5-7-%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8E%E4%B9%B1%E7%A0%81%E6%A0%B9%E6%BA%90%E5%88%B0%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3/","content":"MySQL 5.7 字符集设置指南：从乱码根源到彻底解决在 MySQL 使用中，“乱码” 是最让人头疼的问题之一 —— 明明输入的是中文，存储后却变成一堆问号或火星文。其实，这大多是字符集设置不当导致的。本文基于 MySQL 5.7 的字符集配置逻辑，教你从根源解决乱码问题，让数据存储和显示始终 “表里如一”。\n一、先搞懂：字符集到底是什么？简单说，字符集是数据库 “认识” 文字的字典。不同的字符集支持不同的文字范围：\n\nlatin1：只支持英文和少数符号，不支持中文；\n\nutf8：支持中文，但 MySQL 5.7 中的utf8是 “阉割版”，最多支持 3 个字节，无法存储 emoji（如😊）或某些生僻字；\n\nutf8mb4：“完整版” utf8，支持 4 个字节，能完美存储中文、emoji 和各种生僻字，是推荐选择。\n\n\n如果数据库的字符集不支持你要存储的文字，就会出现乱码。比如用latin1存储中文，结果必然是问号 “???”。\n二、MySQL 5.7 的字符集 “三层结构”MySQL 5.7 的字符集设置分为三个层级，层层递进，缺一不可：\n\n服务器级：数据库启动时的默认字符集，影响所有新建的数据库；\n\n数据库级：每个数据库可以单独指定字符集，覆盖服务器级设置；\n\n表 &#x2F; 字段级：创建表或字段时可指定字符集，覆盖数据库级设置。\n\n\n举个例子：如果服务器级用latin1，但某数据库单独设置了utf8mb4，那么该数据库的表默认会用utf8mb4。\n三、一步到位：全局字符集配置（推荐）最省心的方式是在配置文件中统一设置字符集，避免层级冲突。\n步骤 1：找到配置文件\nWindows：通常在 MySQL 安装目录的my.ini（如C:\\Program Files\\MySQL\\mysql-5.7\\my.ini）；\n\nLinux：一般在&#x2F;etc&#x2F;my.cnf或&#x2F;etc&#x2F;mysql&#x2F;my.cnf。\n\n\n步骤 2：修改配置参数用文本编辑器打开配置文件，在对应节点添加以下内容：\n# [mysqld] 节点：服务器级字符集[mysqld]character-set-server=utf8mb4  # 服务器默认字符集collation-server=utf8mb4_unicode_ci  # 对应的排序规则（不区分大小写）# [client] 节点：客户端连接时的字符集（避免连接环节乱码）[client]default-character-set=utf8mb4# [mysql] 节点：mysql命令行工具的字符集[mysql]default-character-set=utf8mb4\n\n关键说明：\n\ncollation-server是字符集的 “排序规则”，utf8mb4_unicode_ci支持多语言正确排序，推荐使用；\n\n必须同时配置client和mysql节点，否则客户端连接时可能用默认的latin1，导致 “写入乱码”。\n\n\n步骤 3：重启服务生效# Windows（管理员CMD）net stop mysql57  # 停止服务（mysql57是服务名，需替换）net start mysql57  # 启动服务# Linuxsudo systemctl restart mysqld  # 或 mysql\n\n四、临时调整：数据库 &#x2F; 表级字符集设置如果不想修改全局配置，也可以在创建数据库或表时单独指定字符集。\n1. 创建数据库时指定CREATE DATABASE mydb   CHARACTER SET utf8mb4   COLLATE utf8mb4_unicode_ci;\n\n2. 创建表时指定USE mydb;  # 切换到目标数据库CREATE TABLE user (  id INT,  name VARCHAR(50)) ENGINE=InnoDB   DEFAULT CHARSET=utf8mb4   COLLATE=utf8mb4_unicode_ci;\n\n注意：如果数据库级已设置utf8mb4，表级可以省略，但明确指定更稳妥。\n五、验证字符集设置是否生效配置后，用以下命令检查是否生效：\n\n查看服务器级字符集：\n\nshow variables like &#x27;character_set_server&#x27;;  # 应显示utf8mb4show variables like &#x27;collation_server&#x27;;      # 应显示utf8mb4_unicode_ci\n\n\n查看当前数据库字符集：\n\nuse mydb;show variables like &#x27;character_set_database&#x27;;  # 应显示utf8mb4\n\n\n查看表字符集：\n\nshow create table user;  # 查看表定义，确认CHARSET=utf8mb4\n\n六、常见问题：设置后仍乱码怎么办？\n连接环节的 “隐形坑”\n\n即使服务器和数据库字符集正确，客户端连接时如果用了其他字符集，仍会乱码。解决方法：连接时显式指定字符集：\n# 命令行连接时mysql -u root -p --default-character-set=utf8mb4# 程序中连接（以Python为例）import pymysqlconn = pymysql.connect(  host=&#x27;localhost&#x27;,  user=&#x27;root&#x27;,  password=&#x27;123456&#x27;,  db=&#x27;mydb&#x27;,  charset=&#x27;utf8mb4&#x27;  # 必须指定)\n\n\n已有数据乱码\n\n字符集修改后，新数据会正常存储，但旧的乱码数据需要重新插入。可以先导出数据，修改字符集后再导入。\n七、最佳实践总结\n优先用 utf8mb4：无论是新库还是旧库，都建议统一为utf8mb4，避免未来兼容问题；\n\n全局配置一步到位：修改my.ini&#x2F;my.cnf是最彻底的方式，减少后续维护成本；\n\n连接时显式指定字符集：程序或命令行连接必须带charset&#x3D;utf8mb4，堵住最后一个漏洞；\n\n新建库表时检查字符集：养成创建时显式指定utf8mb4的习惯，避免依赖默认配置。\n\n\n按照这些步骤操作，MySQL 5.7 的字符集问题就能迎刃而解，从此和乱码说再见。\n以上内容涵盖了 MySQL 5.7 字符集设置的关键要点。若你对某些内容有疑问，或想进一步细化某个步骤，欢迎随时告诉我。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 基础操作与编码设置：从入门到避坑","url":"/2025/08/16/MySQL-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%81%BF%E5%9D%91/","content":"MySQL 基础操作与编码设置：从入门到避坑掌握 MySQL 的基础操作是使用数据库的第一步，而字符集设置不当导致的乱码问题则是新手常踩的 “坑”。本文从实际操作出发，带你快速上手数据库基本操作，并解决中文存储的常见问题。\n一、MySQL 基础操作：从数据库到表的核心命令1. 查看所有数据库登录 MySQL 后，首先可以查看当前服务器中的所有数据库：\nSHOW DATABASES;\n\n系统默认包含 4 个核心数据库：\n\ninformation_schema：存储数据库元信息（如库名、表名、字段类型等）；\n\nperformance_schema：用于监控数据库性能；\n\nsys：简化性能监控的视图集合；\n\nmysql：存储用户权限、系统配置等核心信息。\n\n\n2. 创建自己的数据库使用create database命令创建自定义数据库，名称需唯一：\n-- 创建名为cyforkkdb的数据库CREATE DATABASE cyforkkdb;\n\n3. 切换到目标数据库对数据库操作前需先指定目标库，使用use命令：\n-- 切换到cyforkkdb数据库USE cyforkkdb;\n\n\n提示：若未执行use命令直接操作表，会报错No database selected。\n\n4. 查看数据库中的表切换到目标库后，查看所有表：\n-- 查看当前数据库的表show tables;SHOW TABLES;-- 查看指定数据库的表（无需切换库） SHOW TABLES FORM 数据库名;\n\n5. 创建数据表使用create table定义表结构，需指定字段名和数据类型：\n-- 创建student表（包含id和name字段）CREATE TABLE student(  id int,  -- 整数类型  name varchar(20)  -- 字符串类型，最长20个字符);\n\n6. 查看表数据新表默认无数据，可通过select命令查看：\n-- 查看student表的所有数据SELECT * FROM student;\n\n7. 插入数据使用insert into添加记录：\n-- 向student表插入两条记录INSERT INTO student VALUES(1, &#x27;张三&#x27;);INSERT INTO student VALUES(2, &#x27;李四&#x27;);\n\n\n注意：若插入中文时出现Incorrect string value错误，大概率是字符集不支持中文，需按后文方法配置。\n\n8. 查看表 &#x2F; 库的创建信息通过show create命令可查看表或数据库的详细配置（包括字符集）：\n-- 查看student表的创建信息（\\G用于格式化输出）SHOW CREATE TABLE student\\G-- 查看cyforkkdb数据库的创建信息SHOW CREATE DATABASE cyforkkdb\\G\n\n9. 删除表和数据库删除操作需谨慎，执行后数据无法恢复：\n-- 删除student表DROP TABLE student;-- 删除atguigudb数据库DROP DATABASE cyforkkdb;\n\n二、字符集设置：解决中文乱码问题1. 问题表现插入中文时提示ERROR 1366 (HY000): Incorrect string value，或查询时显示乱码，本质是字符集不支持中文（默认latin1）。\n2. 查看当前字符集通过以下命令检查字符集配置：\n-- 查看字符集相关变量SHOW VARIABLES LIKE &#x27;character_%&#x27;;SHOW VARIABLES LIKE &#x27;collation_%&#x27;;\n\n3. MySQL 5.7 配置方法步骤 1：修改配置文件my.ini找到安装目录下的my.ini（默认路径：C:\\ProgramData\\MySQL\\MySQL Server 5.7），添加以下配置：\n[mysql]default-character-set=utf8  -- 客户端默认字符集[mysqld]character-set-server=utf8  -- 服务器默认字符集collation-server=utf8_general_ci  -- 服务器默认排序规则\n\n步骤 2：重启服务-- 停止服务（mysql57是服务名）net stop mysql57-- 启动服务net start mysql57\n\n步骤 3：验证配置重新登录后执行show variables like ‘character_%’;，确认character_set_server等参数为utf8。\n4. MySQL 8.0 的优势MySQL 8.0 默认字符集为utf8mb4（支持所有中文、emoji 和生僻字），无需手动配置即可正常存储中文，从根源解决乱码问题。\n5. 已有库 &#x2F; 表的字符集修改若修改配置前已创建库或表，需手动调整：\n-- 修改数据库字符集ALTER DATABASE 数据库名 charset utf8;-- 修改表字符集（仅影响新字段）ALTER TABLE 表名 charset utf8;-- 修改字段字符集（需指定字段类型）ALTER TABLE 表名 MODIFY 字段名 varchar(20) charset utf8;\n\n总结MySQL 基础操作围绕 “库 - 表 - 数据” 三层结构展开，核心命令包括create、use、insert、select等。中文乱码问题的关键是字符集配置，MySQL 5.7 需手动修改my.ini为utf8，而 8.0 默认utf8mb4更省心。掌握这些内容，即可完成日常数据存储与查询需求。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 安装避坑指南：服务启动与登录问题全解析","url":"/2025/08/14/MySQL-%E5%AE%89%E8%A3%85%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98%E5%85%A8%E8%A7%A3%E6%9E%90/","content":"MySQL 安装避坑指南：服务启动与登录问题全解析MySQL 作为最流行的关系型数据库之一，安装过程中难免遇到各种问题，尤其是服务启动失败和登录报错，常常让初学者头疼。本文结合实战经验，总结了 MySQL 安装后服务启动与用户登录的常见问题及解决方案，帮你快速排查故障，顺利开启数据库之旅。\n一、服务启动常见问题与解决方法MySQL 安装完成后，首先需要启动服务才能正常使用。服务启动失败是最常见的 “拦路虎”，主要集中在这几个场景：\n1. 服务未安装或安装失败现象：执行net start mysql时提示 “服务名无效”，或安装过程中提示 “服务安装失败”。\n原因：\n\n安装包损坏或权限不足；\n\n之前的 MySQL 服务未彻底卸载，残留注册表信息冲突。\n\n\n解决步骤：\n\n手动安装服务：\n\n以管理员身份打开命令提示符（CMD），进入 MySQL 的bin目录（如C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin），执行：\nmysqld --install [服务名]  # 服务名默认是mysql，可自定义\n\n提示 “Service successfully installed” 即为成功。\n\n彻底卸载残留服务：\n\n\n若提示 “服务已存在”，先删除旧服务：\n\nsc delete mysql  # 删除默认服务名mysql\n\n\n清理注册表：按下Win+R输入regedit，删除HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services中与 MySQL 相关的项。\n\n2. 端口被占用现象：服务启动后立即停止，查看错误日志（data目录下的.err文件）提示 “Port 3306 is already in use”。\n原因：默认端口 3306 被其他程序（如其他 MySQL 实例、Docker 容器）占用。\n解决步骤：\n\n查找占用程序：\n\nnetstat -ano | findstr 3306  # 找到占用3306端口的进程ID（PID）\n\n在任务管理器中结束对应 PID 的进程（若为无关程序）。\n\n修改 MySQL 端口：\n\n打开配置文件my.ini（或my.cnf），在[mysqld]下添加：\nport=3307  # 改为未占用的端口（如3307）\n\n重启服务后，登录时需指定端口：mysql -u root -P 3307 -p。\n3. 配置文件错误现象：服务启动失败，日志提示 “Unknown variable” 或 “Invalid configuration”。\n原因：my.ini配置文件存在语法错误（如拼写错误、参数值格式错误）。\n解决步骤：\n\n检查核心配置：确保[mysqld]下的基础配置正确：\n\nbasedir = C:/Program Files/MySQL/MySQL Server 8.0  # 安装目录（注意用斜杠/）datadir = C:/Program Files/MySQL/MySQL Server 8.0/data  # 数据目录default-character-set = utf8mb4  # 字符集\n\n\n恢复默认配置：若无法定位错误，可删除自定义配置，使用安装包自带的默认my.ini（通常在ProgramData目录下）。\n\n二、用户登录常见错误与解决方案服务启动成功后，登录时可能遇到密码错误、权限不足等问题，以下是高频场景的处理方法：\n1. 密码错误或忘记密码现象：登录提示 “Access denied for user ‘root‘@’localhost‘ (using password: YES)”。\n原因：密码输入错误，或安装时未记录随机密码（MySQL 8.0 + 默认生成随机密码）。\n解决步骤：\n\n重置 root 密码：\n\n\n停止服务：net stop mysql\n\n跳过权限验证启动：\n\n\nmysqld --console --skip-grant-tables --shared-memory\n\n\n新打开一个 CMD 窗口，无密码登录：\n\nmysql -u root  # 直接回车，无需输入密码\n\n\n刷新权限并修改密码（MySQL 8.0 + 语法）：\n\nFLUSH PRIVILEGES;  # 刷新权限ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;新密码&#x27;;  # 新密码需包含大小写、数字和符号\n\n\n重启服务：关闭所有窗口，执行net start mysql，用新密码登录。\n\n2. 主机访问权限限制现象：远程登录提示 “Access denied for user ‘root‘@’192.168.1.100‘ (using password: YES)”。\n原因：默认情况下，root 用户仅允许localhost（本地）登录，未授权远程主机访问。\n解决步骤：\n\n本地登录 MySQL：\n\nmysql -u root -p  # 输入密码登录\n\n\n授权远程访问：\n\n-- 允许root从任意主机登录（生产环境不建议，可指定具体IP如192.168.1.%）CREATE USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;密码&#x27;;  GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; WITH GRANT OPTION;  FLUSH PRIVILEGES;  # 刷新权限\n\n3. 字符集或编码错误现象：登录后执行 SQL 提示 “Illegal mix of collations”，或中文显示乱码。\n原因：客户端与服务器字符集不一致。\n解决步骤：\n\n查看服务器字符集：\n\nSHOW VARIABLES LIKE &#x27;character_set_%&#x27;;\n\n\n统一字符集：在my.ini中添加：\n\n[mysqld]character-set-server = utf8mb4collation-server = utf8mb4_unicode_ci[client]default-character-set = utf8mb4\n\n重启服务后生效。\n三、最佳实践：避免问题的预防措施\n安装时注意事项：\n\n\n选择 “Custom” 自定义安装，明确记录basedir和datadir路径；\n\n若为 MySQL 8.0+，安装后及时记录临时密码（在data目录的.err文件中）。\n\n\n\n配置文件管理：\n\n\n备份my.ini，修改前复制一份副本；\n\n路径使用斜杠&#x2F;而非反斜杠\\（避免转义字符问题）。\n\n\n\n服务与端口管理：\n\n\n定期检查 3306 端口占用情况，避免与其他程序冲突；\n\n非必要不开放 root 用户远程访问，创建专用用户并分配最小权限。\n\n\n\n密码管理：\n\n\n使用强密码（长度≥8 位，包含大小写、数字和特殊符号）；\n\n定期通过ALTER USER命令修改密码，避免明文存储。\n\n\n总结MySQL 服务启动与登录问题多源于配置错误、资源冲突或权限设置，解决的核心是：善用错误日志定位原因，通过规范配置和权限管理预防问题。本文涵盖的场景和方法适用于 MySQL 5.7 和 8.0 版本，遇到问题时先查看data目录下的错误日志（.err文件），大部分故障都能从中找到线索。\n掌握这些技巧后，不仅能快速解决安装后的问题，更能培养排查数据库故障的思路，为后续的 MySQL 学习和使用打下坚实基础。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"SQL 概述与分类：零基础也能懂的核心知识","url":"/2025/08/14/SQL-%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%88%86%E7%B1%BB%EF%BC%9A%E9%9B%B6%E5%9F%BA%E7%A1%80%E4%B9%9F%E8%83%BD%E6%87%82%E7%9A%84%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/","content":"SQL 概述与分类：零基础也能懂的核心知识无论学习哪种数据库（MySQL、Oracle、SQL Server），SQL 都是绕不开的基础。它是操作数据库的 “通用语言”，掌握其核心概念和分类，能让你在写代码时思路更清晰。本文用最简单的语言讲解 SQL 的本质和分类，新手也能快速入门。\n一、什么是 SQL？一句话讲明白SQL（Structured Query Language，结构化查询语言）是一种专门用来操作数据库的编程语言。它的作用就像 “数据库的遥控器”—— 通过简单的命令，你可以让数据库执行 “查数据”“存数据”“建表”“改权限” 等操作。\nSQL 的 3 个核心特点：\n标准化：几乎所有数据库（MySQL、Oracle 等）都支持 SQL，学会一种，其他数据库的 SQL 用法也大同小异。\n\n非过程化：你只需要告诉数据库 “要做什么”（比如 “查所有学生的名字”），不用管 “怎么做”（数据库会自己优化执行步骤）。\n\n简单易学：基本命令都是英文单词（如SELECT“查询”、INSERT“插入”），逻辑和日常语言接近。\n\n\n二、SQL 分类：5 大类命令，各司其职根据功能不同，SQL 可以分为 5 大类。记住每类的核心命令和作用，写 SQL 时就不会 “无从下手”。\n1. 数据查询语言（DQL）：查数据的 “放大镜”作用：从数据库中查询数据（最常用的一类命令）。\n核心命令：SELECT（唯一命令，但用法灵活）。\n示例：\n-- 从student表中查询所有学生的姓名和年龄SELECT name, age FROM student;-- 查询年龄大于18的学生SELECT * FROM student WHERE age &gt; 18;\n\n2. 数据操纵语言（DML）：改数据的 “编辑工具”作用：对表中的数据进行 “增删改”（不改变表结构，只改内容）。\n核心命令：INSERT（新增）、UPDATE（修改）、DELETE（删除）。\n示例：\n-- 新增一条学生数据INSERT INTO student (name, age) VALUES (&#x27;张三&#x27;, 20);-- 修改张三的年龄为21UPDATE student SET age = 21 WHERE name = &#x27;张三&#x27;;-- 删除年龄小于18的学生DELETE FROM student WHERE age &lt; 18;\n\n3. 数据定义语言（DDL）：建结构的 “建筑师”作用：创建、修改、删除数据库或表的结构（比如建表、删库、改字段类型）。\n核心命令：CREATE（创建）、ALTER（修改）、DROP（删除）。\n示例：\n-- 创建名为school的数据库CREATE DATABASE school;-- 在school库中创建student表（包含id和name字段）CREATE TABLE student (  id INT,  name VARCHAR(20));-- 给student表增加age字段ALTER TABLE student ADD age INT;-- 删除student表（谨慎使用！数据会丢失）DROP TABLE student;\n\n4. 数据控制语言（DCL）：管权限的 “保安”作用：控制用户对数据库的操作权限（比如 “允许张三查 student 表，不允许他删表”）。\n核心命令：GRANT（授权）、REVOKE（收回权限）。\n示例：\n-- 允许用户zhangsan查询student表GRANT SELECT ON school.student TO &#x27;zhangsan&#x27;@&#x27;localhost&#x27;;-- 收回zhangsan查询student表的权限REVOKE SELECT ON school.student FROM &#x27;zhangsan&#x27;@&#x27;localhost&#x27;;\n\n5. 事务控制语言（TCL）：保安全的 “后悔药”作用：管理数据库事务（确保一组操作要么全成功，要么全失败，比如转账时 “扣钱” 和 “加钱” 必须同时成功）。\n核心命令：COMMIT（提交事务）、ROLLBACK（回滚事务，即 “撤销操作”）。\n示例：\n-- 开启事务（MySQL默认自动提交，需手动关闭）SET autocommit = 0;-- 执行转账操作（扣A的钱，加B的钱）UPDATE account SET money = money - 100 WHERE name = &#x27;A&#x27;;UPDATE account SET money = money + 100 WHERE name = &#x27;B&#x27;;-- 确认操作无误，提交事务（数据永久生效）COMMIT;-- 若操作出错，回滚事务（恢复到操作前的状态）ROLLBACK;\n\n三、总结：记分类，更要会用SQL 分类的核心是 “按功能记命令”：\n\n查数据 → 想SELECT（DQL）；\n\n改数据内容 → 想INSERT&#x2F;UPDATE&#x2F;DELETE（DML）；\n\n改表 &#x2F; 库结构 → 想CREATE&#x2F;ALTER&#x2F;DROP（DDL）；\n\n管权限 → 想GRANT&#x2F;REVOKE（DCL）；\n\n保证操作安全 → 想COMMIT&#x2F;ROLLBACK（TCL）。\n\n\n掌握这些分类，后续学习复杂 SQL 时会更有条理。下一篇我们会深入讲解最常用的 DQL（查询命令），带你搞定各种数据查询场景。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 基础：SELECT 语句的核心语法与规范","url":"/2025/08/16/MySQL-%E5%9F%BA%E7%A1%80%EF%BC%9ASELECT-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B8%8E%E8%A7%84%E8%8C%83/","content":"MySQL 基础：SELECT 语句的核心语法与规范SELECT 语句是 MySQL 中最基础也最常用的查询命令，掌握其语法规则和使用规范，是高效处理数据的第一步。本文将聚焦 SELECT 语句的基本结构、关键规范及实用功能，帮助初学者建立扎实的 SQL 基础。\n一、SELECT 语句的基本语法结构1. 核心语法框架SELECT 语句的最基础结构用于从表中提取指定字段的数据，语法如下：\n-- 选择指定字段SELECT 字段1, 字段2, ... FROM 表名;-- 选择所有字段（不推荐在生产环境使用）SELECT * FROM 表名;\n\n2. 关键说明\nSELECT 后接需要查询的字段名，多个字段用英文逗号分隔；\n\nFROM 后必须指定数据来源的表名，否则会触发语法错误；\n\n语句必须以英文分号 ; 结束，这是 MySQL 语句的通用规则。\n\n\n二、SELECT * 的使用禁忌与替代方案SELECT * 能快速返回表中所有字段，但在实际开发中存在明显弊端，需谨慎使用：\n1. 不推荐使用的原因\n效率低下：会返回无关字段，增加数据库 IO 压力和网络传输成本，尤其对包含大量字段的大表影响显著；\n\n稳定性差：当表结构变更（如新增 &#x2F; 删除字段）时，查询结果会意外包含或丢失数据，可能导致依赖查询结果的应用程序出错；\n\n可读性低：无法直观判断查询的具体字段，不利于代码维护。\n\n\n2. 推荐做法明确指定所需字段，例如：\n-- 推荐：只查询必要字段SELECT id, username, register_time FROM user;-- 不推荐：返回所有字段SELECT id, username, register_time, password, email, phone, ...  -- 字段过多时可换行FROM user;\n\n三、SQL 大小写规范与书写建议MySQL 对大小写的敏感性随操作系统不同而变化，遵循统一规范可避免低级错误：\n1. 大小写规则\nWindows 环境：大小写不敏感（SELECT 与 select 等效）；\n\nLinux 环境：大小写敏感（数据库名、表名、表别名严格区分大小写）。\n\n\n2. 通用书写规范\n关键字（如 SELECT、FROM、WHERE）全部大写；\n\n表名、字段名、别名等全部小写；\n\n多字段或复杂语句分行书写并缩进，提升可读性：\n\n\n-- 规范示例SELECT     id,     product_name,     price FROM     product WHERE     stock &gt; 0;\n\n四、列别名：提升结果可读性的实用技巧列别名用于给查询结果中的字段临时命名，让输出更直观，不影响原表结构。\n1. 语法格式-- 格式1：使用 AS 关键字（推荐，可读性强）SELECT 字段名 AS 别名 FROM 表名;-- 格式2：省略 AS（需在字段名与别名间加空格）SELECT 字段名 别名 FROM 表名;\n\n2. 注意事项\n若别名包含空格、特殊字符（如括号、中文），需用双引号 “ 或反引号 &#96; 包裹：\n\nSELECT     user_id AS &quot;用户 ID&quot;,  -- 别名含空格    order_no `订单编号(2023)`  -- 别名含特殊字符FROM order;\n\n\n别名仅在当前查询结果中生效，不会修改表中实际字段名。\n\n五、去重查询：DISTINCT 关键字的正确用法DISTINCT 用于提取唯一值，消除结果中的重复记录，适用于统计不重复数据的场景。\n1. 基本语法SELECT DISTINCT 字段名 FROM 表名;\n\n2. 关键特性\nDISTINCT 作用于其后的所有字段，而非单个字段。例如 SELECT DISTINCT a, b 会对 a 和 b 的组合去重；\n\n若字段包含 NULL，DISTINCT 会将所有 NULL 视为相同值，仅保留一条。\n\n\n3. 示例-- 对单个字段去重：查询所有不重复的部门 IDSELECT DISTINCT department_id FROM employee;-- 对多个字段去重：查询不重复的&quot;部门-职位&quot;组合SELECT DISTINCT department_id, job_title FROM employee;\n\n六、空值（NULL）的特殊处理规则NULL 表示 “未知值”，与空字符串 “” 完全不同（空字符串长度为 0，NULL 长度未知且占用存储空间），处理方式需特别注意：\n1. 核心规则\n不能用 &#x3D; 或 !&#x3D; 判断 NULL，必须使用 IS NULL（判断为空）或 IS NOT NULL（判断非空）；\n\nNULL 与任何值运算的结果都为 NULL（如 NULL + 1、NULL || ‘abc’ 均返回 NULL）。\n\n\n2. 示例-- 查询未填写邮箱的用户SELECT username FROM user WHERE email IS NULL;-- 查询已填写手机号的用户SELECT username FROM user WHERE phone IS NOT NULL;\n\n七、着重号：解决关键字冲突的必备技巧若表名、字段名与 SQL 关键字（如 order、select）重名，需用反引号 &#96; 包裹，避免语法错误。\n-- 表名是关键字 order，用着重号包裹SELECT * FROM `order`;-- 字段名是关键字 desc，用着重号包裹SELECT `desc` FROM product;\n\n八、常数查询：为结果添加固定标识SELECT 语句支持直接查询常数，在结果中增加固定值列，常用于标记数据来源或整合多数据源。\n1. 应用场景\n区分不同表的查询结果（如多表数据合并时）；\n\n为结果添加业务标识（如数据归属、统计版本）。\n\n\n2. 示例-- 为员工表查询结果添加公司标识SELECT     &#x27;技术部&#x27; AS department,  -- 固定常数列    emp_name,     hire_date FROM employee;\n\n查询结果：\n\n\n\ndepartment\nemp_name\nhire_date\n\n\n\n技术部\n张三\n2023-01-15\n\n\n技术部\n李四\n2023-03-20\n\n\n九、显示表结构：DESCRIBE &#x2F; DESC 命令使用 DESCRIBE 或 DESC 可查看表的字段详情，是分析表结构的常用工具。\n1. 语法-- 完整写法DESCRIBE 表名;-- 简写DESC 表名;\n\n2. 输出字段含义执行 DESC user; 后，输出结果包含以下信息：\n\nField：字段名称；\n\nType：字段数据类型（如 INT、VARCHAR(50)）；\n\nNull：是否允许存储 NULL 值（YES 表示允许）；\n\nKey：索引类型（PRI 为主键，UNI 为唯一索引）；\n\nDefault：字段默认值；\n\nExtra：附加信息（如 AUTO_INCREMENT 表示自增）。\n\n\n十、条件过滤：WHERE 子句的基础用法WHERE 子句用于筛选符合条件的记录，必须紧跟 FROM 子句，是数据过滤的核心工具。\n1. 语法结构SELECT 字段名 FROM 表名 WHERE 条件表达式;\n\n2. 示例-- 查询价格大于 100 且库存大于 0 的商品SELECT name, price FROM product WHERE price &gt; 100 AND stock &gt; 0;-- 查询注册时间在 2023 年的用户SELECT username FROM user WHERE register_time BETWEEN &#x27;2023-01-01&#x27; AND &#x27;2023-12-31&#x27;;\n\n总结：核心要点速览\n避免SELECT *，明确指定需要的字段，提升效率和稳定性；\n\n善用列别名让结果更易读，特殊别名用双引号包裹；\n\nDISTINCT对其后所有字段去重，注意NULL的处理；\n\nNULL需用IS NULL判断，与空字符串不同；\n\n关键字冲突用着重号（&#96;）解决；\n\n常数查询可标记数据来源，DESC用于查看表结构；\n\nWHERE子句紧随FROM，用于筛选符合条件的记录。\n\n\n掌握这些技巧，能让你的 SQL 查询更高效、更易维护，为复杂查询打下坚实基础。\n","categories":["数据库"],"tags":["MySQL"]},{"title":"Hello World","url":"/2025/07/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["Markdown","教程"]},{"title":"SQL 语言规范与基础操作指南","url":"/2025/08/16/SQL-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E4%B8%8E%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/","content":"SQL 语言规范与基础操作指南SQL 作为数据库操作的核心语言，遵循规范的语法和书写习惯不仅能提高代码可读性，还能减少错误。本文整理了 SQL 的基础规则、书写规范及常用操作，适合初学者快速上手。\n一、SQL 基本规则1. 书写格式\nSQL 语句可写在一行或多行，推荐各子句分行书写并适当缩进，例如：\n\nSELECT id, name FROM student WHERE age &gt; 18;\n\n\n每条命令必须使用下列其中一个用在末尾用结束语句（; 最常用）\n; \n\\g\n\\G\n\n\n\n2. 关键字与标点\n关键字（如SELECT、FROM、WHERE）不可缩写或分行，需完整书写。\n\n标点符号必须使用英文半角（如’、”、()），且需成对出现（如引号、括号不能遗漏闭合）。\n\n字符串和日期时间类型的值需用单引号（’ ‘） 包裹，例如 ‘2023-01-01’。\n\n列的别名建议用双引号（” “），且AS关键字可省略（但不建议），例如：\n\n\nSELECT id AS &quot;编号&quot;, name &quot;姓名&quot; FROM student; -- 正确\n\n二、大小写规范MySQL 的大小写敏感性与操作系统相关，遵循以下规则可避免混淆：\n\nWindows 环境：大小写不敏感（例如select和SELECT等效）。\n\nLinux 环境：大小写敏感（数据库名、表名、表别名严格区分大小写）。\n\n\n推荐书写规范：\n\n数据库名、表名、字段名、别名等全部小写（如student_info、user_id）。\n\nSQL 关键字、函数名全部大写（如SELECT、INSERT、COUNT()）。\n\n\n示例：\n-- 推荐写法SELECT id, name FROM student WHERE age &gt; 20;-- 不推荐（大小写混乱）Select ID, Name from Student where Age&gt;20;\n\n三、SQL 注释用法注释是代码的 “说明书”，SQL 支持三种注释方式：\n\n单行注释（#）：MySQL 特有的方式，#后直接写注释内容\n\n# 查询所有学生信息SELECT * FROM student;\n\n\n单行注释（– ）：通用方式，–后必须加空格\n\n-- 查询年龄大于18的学生SELECT * FROM student WHERE age &gt; 18;\n\n\n多行注释（&#x2F;* *&#x2F;）：适合大段说明\n\n/*功能：查询学生表中年龄大于20且性别为男的记录*/SELECT * FROM student WHERE age &gt; 20 AND gender = &#x27;男&#x27;;\n\n四、命名规则合理的命名是规范的核心，需注意以下几点：\n\n长度限制：数据库名、表名最多 30 个字符，变量名最多 29 个字符。\n\n允许字符：只能包含 A-Z、a-z、0-9、_（下划线），不可包含空格。\n\n唯一性：\n\n\n\n\n同一 MySQL 实例中，数据库名不可重复；\n\n\n\n同一数据库中，表名不可重复；\n\n\n\n同一表中，字段名不可重复。\n\n\n\n\n避免保留字：若字段名与关键字（如order、select）重名，需用 ** 着重号（&#96;）** 包裹：\n\n-- 正确：用`包裹关键字作为表名CREATE TABLE `order` (  id INT,  order_no VARCHAR(20));\n\n\n类型一致性：同一字段在不同表中类型需一致（如user_id在 A 表是INT，在 B 表也应是INT）。\n\n五、数据导入指令当需要批量导入数据时，可通过source命令导入 SQL 文件，步骤如下：\n\n打开命令行客户端，登录 MySQL：\n\nmysql -u 用户名 -p\n\n\n输入密码后，使用source指令导入（文件路径需用绝对路径）：\n\nsource D:\\data\\mydb.sql; -- Windows系统-- 或source /home/user/data/mydb.sql; -- Linux系统\n\n六、基础 SELECT 语句SELECT是 SQL 中最常用的查询语句，基础语法如下：\n1. 选择全部列SELECT * FROM 表名; -- 查询表中所有字段的所有记录-- 示例：查询student表所有数据SELECT * FROM student;\n\n2. 选择指定列SELECT 列1, 列2, ... FROM 表名;-- 示例：查询student表的id和name字段SELECT id, name FROM student;\n\n3. 列的别名规则\n别名无空格时，可省略双引号：\n\nSELECT id AS 编号, name 姓名 FROM student; -- 正确\n\n\n别名有空格时，必须加双引号：\n\nSELECT id AS &quot;学生编号&quot;, name &quot;学生姓名&quot; FROM student; -- 正确SELECT id AS 学生 编号; -- 错误（空格未加引号）\n\n总结遵循 SQL 规范不仅能让代码更易读、易维护，还能减少因语法问题导致的错误。核心要点包括：统一大小写、规范命名、正确使用注释、遵循标点规则。熟练掌握这些基础，能为复杂的数据库操作打下坚实基础。                                                    \n","categories":["数据库"],"tags":["MySQL"]},{"title":"在 Hexo 博客中插入图片的完整指南","url":"/2025/07/28/%E5%9C%A8-Hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","content":"在 Hexo 博客中插入图片的完整指南Hexo 是一个基于 Node.js 的静态博客生成器，因其灵活性和扩展性而广受欢迎。然而，在使用 Markdown 编写博客时，插入图片可能会遇到路径问题或格式限制。本文将详细介绍如何在 Hexo 中插入图片的多种方法\n\n一、插入图片的三种种方法方法 1：使用文章资源文件夹（推荐）Hexo 提供了一个 post_asset_folder 功能，允许为每篇文章创建独立的资源文件夹。修改 Hexo 根目录下的 _config.yml 文件：\npost_asset_folder: truemarked:  prependRoot: true  postAsset: true \n\n\n说明：此配置会为每篇新文章自动生成一个与文章同名的文件夹，用于存放图片等资源。\n\n\n创建新文章：\nhexo new &quot;你的文章标题&quot;\n\n这会在 source/_posts/ 目录下生成一个同名文件夹（如 你的文章标题）和 .md 文件。\n\n存放图片：将图片放入生成的文件夹中（例如 source/_posts/你的文章标题/）。\n\n插入图片：在 .md 文件中使用以下语法：\n![替代文字](图片名.jpg)\n\n\n提示：如果图片无法显示，检查路径是否正确（图片名.jpg&#96;）。\n\n\n\n\n方法 2：使用固定资源文件夹（最简单）\n创建统一图片文件夹：在 source/ 目录下新建一个文件夹（例如 images/），用于存放所有文章的图片。\n\n插入图片：在 .md 文件中使用以下语法：\n![替代文字](/images/图片名.jpg)\n\n\n说明：/images/ 表示从 Hexo 根目录的 source/ 文件夹开始查找图片。\n\n\n\n\n方法 3：使用网络图床（氪金玩家）如果不想将图片存储在本地，可以使用图床服务（如阿里云 OSS、GitHub Pages）：\n\n上传图片：将图片上传至图床，并获取图片的 URL（例如 https://example.com/images/图片名.jpg）。\n\n插入图片：在 .md 文件中使用以下语法：\n![替代文字](https://example.com/images/图片名.jpg)\n\n\n隐私保护建议：  \n\n避免使用第三方图床（如免费图床服务），以防图片被他人盗用或丢失。  \n推荐使用私有对象存储（如阿里云 OSS、AWS S3）或 GitHub Pages 搭建私有图床。\n\n\n\n参考链接：\n\nHexo 官方文档\nTypora 图片管理指南\nhexo-asset-img GitHub 仓库\n\n\n希望这篇指南能帮助你更好地管理 Hexo 博客中的图片资源！\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"内外兼备的得分后卫都在用!1.5motion新单动投篮","url":"/2025/07/19/%E5%86%85%E5%A4%96%E5%85%BC%E5%A4%87%E7%9A%84%E5%BE%97%E5%88%86%E5%90%8E%E5%8D%AB%E9%83%BD%E5%9C%A8%E7%94%A8!1.5motion%E6%96%B0%E5%8D%95%E5%8A%A8%E6%8A%95%E7%AF%AE/","content":"\n  07d75588653f466133359cc81f040bdca1bcf910cd813fa7632e0918d7ee55dc1bfabedf5a51e237502b87e85f90176b395c433c69e338c820b7e4d8f2113ae88a3c8b7ab31040b3f22d17f64f07bcdef92fd5bc3eaa572b83fe2cc0b450c8a70eddec29f505e3a5f3b614339f5f3b7067ad47bab4674a57dc1e2c954766174efa19f81e6ff852bcffdd39792a27f43c7d12782501f1e2835ebbbe63b156f97a816e0f56fc19bde4ba139bd901267278dab20b18cdeed4adcf91438541e957183628e922a04cda71dda65652a30feac11151e84d62991fad52ce2249d7e785b4f698e0c0cf27b34aa712c05eb9b3abdef7b19f071f89881e44ce52419b6e9d1a4b09e86e6dc69e9708a8f87e4b9a60b403612d6d30c152555c98f7960c600c9b20fb43504ded10e103b45d85d780d19ce432d06867849f8258c1654c4239784395aa36c0efc963fcb0648e70df5cde5479bb1689458b0964a79cb08d2239c746031177adfea43f0f18dc4ab9986bec189a3107ab0406e9211f3a925a820e803f2ce3dbd1dd784be89012050d54b47f1eaf25fb92ad304565a51a7cc53c98dfb667249379b52fa58c848d65f32b6e7905cb0a09a3ea320cb710de3482f065aab1a932a1b2850f173de4fae0ceeaf9e0efd0b3073857006ed719b74be524d126a4fbe63480aae03909f521a3f788df7b0f708f2b29dff0ec4152a6bf226de77ee8ef3958d97fc829ee7391fc8e09129a3636a158d1a848d6da94e087065a8812bdfec5b665d067bb4c0cf8301c0fd7e1c729402fc6b908ac45f30f22df83e5c1d9db0039e6c6dd9159dbe45cf690390f64a65a00715f9da5239e3d718c45398215e02bc15fc6abee70922e639a7b63a5d55a66f12e6c0dfef949565910fe27a20e802a2a2959f6f5af3ba6b37008195aa50bac5b89473b3a8a8403ba8b62fb9f2d8335b99b49f8aecb4b00ef18dcb0e5b3965a2202d241af16edbb3279657a89d498a588a892f51cb8abf62db828f16eecf44278d9051c7243672bc0b7dad81c3c94d094b314bd02f6d5444bdfc16dc70711ec562f847d4d0b6d8d3943ddee4342b4b5c3ca6ce5803c2fd95e9ff0d763270f77db0db02087a7f697e2f1afb448ab950ce6a26065fc1a269896e6bb4963b0d85b0d23a83efaaea4e68d9eaa58782da1c5aadd1beb7a17aa56009e32fe319cc2262e71dca73ac5d056c0b27e95f04636ce7df148ed5b3fb48e66e10e0257bf0de42f57cff4139a8e6337bab0d011d9357117ee23f651b8b07279a6454570483f6bd936c8dbabe991e9d02132a2afe626a37b87fb6018d6624f93efc01f5c82cb07e0abfaf29bbe46671f617799600cfd58800015a5701f2d7ccc58c27257f32df855e6576895dc1bd284daaeef4a5fd53c382006c06260bfba9cc1e1de32f9f96a3b5abf12920f4d901478bbc58c9fb17674b54a9e602d0839f5983f77857556f181e58ba52f0d067b5c3dd9d131a4ec8d5909acdfff341a466fdea7e15cfe80460eb2154c99d723b93ab5672d3605c956414f592cc92b9133a8825c142a4d1d9359b1dd4baf7fcb044b218cd910c6a08284c5bab965bc362d1fa317f82f6cfaf97cad6995b63adb9088c3c62b989ecf46c6b9bd758c83aa183232ba2793a4c3c806a018425dc61f90348c7110be6fa95b1c5f3d20a8bcc8b942bafbeb5edfdd39651bd91147d56e36fa08359f7fea1324e059fc10f40a8361c780d9157e72aa8a0536469407c13aed4162a7155226429c86901dec42567ad44ca19f1f43473f0068561073620b2c1b4826f5c61e33718a4a9dfdfa980b2b2eeaa7d1b768ac52650e7caf9a2f825b94ffb411b6da1ebf5f877f37597febee2f759641ffe9e723e15a87d5366839f4860fd61f5da8720ec50ce6df50d2ca97361523eabbcaf1d5fa0b303cd4452c49a6abe3d1890a0868e583b8a566ea4d4281c0ed241ba03622298af7a5b6b2aa7656527a2c4752181adc088dceff6cb6601b3464a015ae75fc54818b18a8db0947b4e1b36bd55dcb75075a525fb74506e6968e13f66733d2fbdfe98f0a260e1859786a81e29cd41d0bc24c0d58be8fab1a701e1216bdbde2e74dbc129dbc4a9c6e93b462b244cd21119462691437a6d4ad486601b234b2d1bd34b9a953eb357af998279a54d697b1bf34d009c2bf1bed928efecc01e19c72be4e41a83f39c20edc0d0aec83ce06bb868ba51f5227ac3dfec4eeb2853cddc949c749721a75010ac7e62ef96f8a2c0d86552660e55ae872cec3bd1c9a55ba3cbdbefe8f23ddd042f532ea0196d99b60f3d2ef48cdf7b128f1541b431eb5c266aec7e39895aff5331a0bb71114563fea84b86039c8e815c0933728ab86e4d19c144fb75859c2aa7bc0f69469ff26f6b778e54d666e78c4fafef51030471c15fc48d323e3bf147c498d6061bba5ff11b46b9a1cf3dd0fd3982a063ce093d5a4e5d4ca9174c4e8b234f7d5ac4868c21a2f7b3ff9afa4217783babc199c74c0a2bd64606527346d597d5c3a2889711d1efd342ff28c5b11d5f3fbb69ce7293f953a6bd2b26df0325ecfac6a6a84a4462d057eb889e94fbf1014974293060ce6ccd23eb6487073a1ddd003b42af611455b1f175ce669f7089e66c9637ec785d7df213898611e12fd791cc69783a50b9e1e14aa952ace6e56c30e146d1c21e888815b14d17e77038a38f0433e9cf4c922e27f851a4ea1052aee460d741dfff1060c3c7204c64104d9a0a1bc9aff154a2a531bfdd3f6567b5f56c8f8193ba129cfc1486876c6b81a6e4f4b7bf6d4197caf1126a763eba58aae635ff90c2cd35b124b54e3a99745464c103cd46db17714811e5a1ab03afb56e0ad8de48655962c2a2fc99116f8e9a1a7e991ff7b1e7ed5cfa4a8714ffc1800c3574bc63dc9c8b343fa155cd93205a17150185c4eea8654128aa9d02eedcb17a739fdaf7de68e0236be8776216e822e71fea77f566838fa27f3e35bade7960687aed8af4851c77fdbd7704b6445e8200230bc796c1cf724be9241430047eddfd1077a9cf6c9876d396eee80b31864639305591002f0ae195f3e351c965a27a5274cc3725a6e5c27109d72e6dfc6e2cb89a0ccc94b412c1edc1f645a469f265dbf6c7ac6f5fd7a7155396ba3d78306b97aec81f7e5de52faec8a4e14a2b118de05553b030fbe84bf45291b5461417888e48e27c6bd0df8d52ad5608885f983aaa5f05d018e05f4b00949e3bc06383d16adaae778e54a9304c29ae7edc7fd267c9843bad0846284928e08019ffdf5ca3b7f574d05f4ef55e0de7cb0ecfc1f9b52087d4786659fa51ac33a6feda1280994c93dda754e310585e315d3b1e9da0bbd6e85da1ed474fb0f26da94b018bc662b1d940b492f901182b1b4e675fd2eb057d8d3c4ebfcd1420a3e3326640f9ccc4a7fef24dd35c44e155bc18b729b205e0940532a08804aa84f99ac2bd43526b4900ba0386552bf70d91a6aadd7fb4eee3437e6a4ab3225ac5bf6e223a859795ddd883349fce2fe5047d82f8f80a220034837c3c2db2aa852ea45093c596ea6e2ca2b7760e38dde68f03cc107892b55748da3103568ae7c7b14995f75fc73373896bdfd25b8c76fd599fa71f2e00e27f058c5f6d65b42d0e3dd305db455d0dee7350f6fde529b454ddaa6a941ef4e067464ba1930b5e7ece89a53f0465adc1b1e148b7f620532043b3624b47545f3d6c8b807bf693d05f1c77325017fca1fc2f1b49b409c19842530bb83742eb2f8770c8e6b82d11f7c1a1b88b7155a13a9e2494d286c06ada635a29afa71c09fc9890289ee0e013e89d3e288c4950701796c99d7e505364699db434b26cdc581732c7eecddb8d0d2fb5eb0d415b73ca7fdfcf538dd230628a67404703756490d4f42b306bd3624c6cd879d37aa96a4deed357d8b9bb88b94e995652177ae8985a4559eb6f75b55109b3a7904e0c93bfc5ea4ed95928278c6075c273d97f3addedfe388708cafd14cb0338a5eaa7db07c07004b5945e23c39eb37276bbdf672e53c0fc6d989f23d03d4cca8c3aee9f769a2f841f720893242cf12ed99fca277f44038ee7ea412330aa8791aa81acfff91e4b500bfc59d80db7de8ef68173d3a3e2dcd3d3327ef327b761ee769224a9dc2b8641cd097a495da7e4cee138ee580a2ad6ef085bcab26a169e3e11d067908748a7d50097d9cd1ebf6d36d92b3c80b8079e9365d60c7d8829fd4b64a12e19fea2d0e08a66e4355ce994e9c8bf34217d944e21a7a147e056ede4e3e23e84105561eef675df53aa2d65dba7497ad8066532d160c82c70e8222e33e5b01d2d5325d8ebbabca9cf01f2dac0b5553726006a2d1a0eccac58f2f3b35f0ba1dc0294908c97254c25e7fdf64acfc827bacd29dd3882833c591e525f95f2ee7143d5598ceedc88ce5abba82274fde417dd866d226e191f64ea3b5b4a8a714505166cff91db24e4f842bd3368ff66cf68cb202bc016b1bafc4a5248c9298183130683e313026532d8e995d419b9cd37d97567cbedd6928028645a83b8647052cd73df3f7210032a368df99aab9c19ffe71a021d43bad34d6f43f8db87a6542c68f6249827b36f25a8daad55aace8b9438ee21267cb874106ff4a261e65a5169470645d86f47d50baf155c313f1675d565cc803e13b9e8aded147c8bd70f750c7777ee540541fdcbca045e4522820fd6707ce13328e3227a42ed90d39ac32f6ac3a52a65d282e3fe9d1b53eee4942a74f15d5e28cf13e972e3512527d9cc8812571a612a9834ffa9afa4c4e785d1dc51abfff8d1c69638917b3ebe5d243cd3f4a3560ab118d1a7168a0e0d9f01d824166408d321272a7a694b822e03dc493b0422366481eee7c987d4c946278b3d0eece4566964ac83a5f65adeaec5576d84e8df5ae58cfaaa025b610f9b34b29da4ead62bcea406a4c9548fcb5bee8d7527fea7cb27434102df8805d9404f5965e8ca0eb9e57b4a9f825dd597a131542691782c80dfdda2d3c6dd40c3ee817c3d53eb42699e4702ee3d3aef317bd8b81ae3cda82daaa34206b896b44b8452f447f051ed8e56965d3eda6fe7af5c2ae1e3006daecfb00af31b1eea041468283c5f9623e1380eb6f13104850d8c349dafe4750c6a12c84dbd538b7ec21655fd10671b270782f34533a9de1f6bb08d9b6bfbebc094e2e3e5c437ed3a8963938fe7db5097dbc463dc4498298d3db880373104be88544a594bab25e93ff5dbb501094fc08fe33e771abc186e3f123c2c436025366a6b9d05472092269b8f1bcd7c5a689f31e0c885d65708dec30ef3a47bc95c77ab7ef121b1c98ea0dbb19dd848e41f1a173dfed7c51248fb7b92393986762ff96bbf9dc4b223715a8a5f90ffa7b4c6032476ef79ca3b79fe433a72e3f91e08036ecc088d8fb57f05d8fc94286cee507eceb7d83f38feb75528a472a11908b4edf87b0e8246435f650ff9c180e576d366a466b66b111f447f40ac054d1d0fa600b18cec1917ede8dde9751eca7c0dc0e407a58ecd31bec15bed8a900753a7f38e334e2228b177c8a7ee91d75969fc6aaf1d29dc5b9202d1dbdcd688ff56a652ccceb7eaf4e7528d005f020a4955d1deccefd3135028e45319fd53375a327d8e38872c8f4e130f9aed82e697aaf25d12e03158ae2d120d9d1c13763176f1a0d37cdb516aa2b4304c815fbd5a68dbf95a15b196cf2fc63dbb40a60c31af8610ee99a3ab338c208c41d551490cc3b9e4e485212081b7a157397a3c2525bc1b6cfe47020bc6e0930ad01465c5bf11a976ad78d13b8653ee3dcabf40005afc453978c1e4bc64e90648293eebb40431ff9ee42bf157f7495283de14876168536cab3476a7296eb1f21d4e5e24d1ef1f408cef7ef595f664d718ad77e50526d1a371120e0ae7faaa4b52b272214548a91d6c5aa43f06f3551b4150d18b1b5dc11f3321fa7ec455bcb1d26500ea959b004bbe7c5f9fde3c03bb5eb106dc71663fe167a5045e0f8a455fd3790faa3c4d91eb64406356944eb393bab69c631a78c24bd5e70ac2c9126a635d73730fa1ec2134fcd3d902eb03b90d4740751e6b9f6f386e664491e9a752b545792941bf20e4a91997a5a005ef6732c6f632a2ce634aa22c4ca4b6c33129b695dcf32a31929e8118981ec95a2f1012cf924c48255edfe525717fc6f598d3c33d9eb15ad53ffa9b555d898f7342df4b47a2044a967d0dbbedce353c9e8fd209acb7de7347d4442bfcc13421a433a5ea70fb4de9caa5c3a0cf7fe3fba1a459fbef50ec43251e3d946d62fbfaf6eeb5fad17c3c866fea36b0dd22d8ab862cc8eb3356e11db8b49e21dd1c0cb2ba9425b5bfe5d30e7a4a960ab0dbb05e44d986344638b43f129d74c9375a233db7d47897360ef75457d0145aaf934c9e1ced77eae3e4b6243b5abd6faa226a0ca6d9f8131b71d1d2610633c1f627b2f4b82e002fb9be767cd6a1d6cdcc5147edfb3296255f67d17bbbbd4d2500dfbc04455549084306c0205b4862140a2df79487629cb8b17a6ce384d02c67e4ce78ab2a5d2b9e9c3b9fc0a9a92c0c3d882af442df0c3417b5d35cb12a169fe164319153f762d637d1774c75d74136599130c103ec1b6e454fb01fa6997e388e231504f0226154fcbc179ba90c89c8e70739b0d0fdfdc8423104c4caa896824f4101c35dcab4055d7320eaa856c0921dca8a2fe31173f2f97b5a5a3b9d9eae2d858e64436c29987a17f2530d6a455d8da954ed15e17bd1a0809f0a91549b36fe6d2458246e840e38f70b93c17d2fe6c109fef203494b3b8e59916c710820fe944956634d7cdb1f34d80489f6a2a2ece62c8a2f9ae1a31de37d323dc082abb39d960a787b6454890c137b087365b00f38403ee1ed035837ab4880a81d9488c4ee625be395c5b5a677e3b23c7afc9f7cb9b82133cbc00ae8b82829f5fe82d8d86038deb03f634b560a8587ec7db8ede62716b3a847dfac7c1c61c02906154d8ab8a8134418cefa5f50fa39985c718f84b2277cb88ae60b8c7bcdf34b733ac537a414a69bd9b2ae3d5c433b46494d04c7e7c069391518c26c470b4be9092951f34542ab6e73fe761fcb608abcefc5fc7ce29f1e7905ca0ff4150766e9f1ec263e16714cae164520045464f824759ee466264ffcb021cb21fa9a1ad628651011e122c36a347129fa29e2059d7b4d57048378d3fd8d2e3b04a0f33cb5dfb38356e9744ff4503e75954e04e0a32622ef65da3a684b5091caf44fc242dc1bf18ec9428f0d3acb2341157a933657ede9363a94ab44888afde9391fbeefdb41f103fd1bbd6f9a6a525cf8b9e9a7fb68d99c5977ac7867f45ef8968868a9cd5bec00bab8f6136fb4bad469419e211b4c45481e0158c385cec2a5da88d85d6ba3d76a0d369f573b33ba132e270f3b8455f33b21e4b8ec106fd871ab19ce4016dcf9b404fab11bed8ff82cfdd414f81311c14947d34b40cdd56344f29602532086bef96c0717a7b7b2aaef2d6e66f13251dc6fe6d2e606006e9bb76b1971770ee226390ef650265e7b41e1f305b696a347e95515541bf22c900773f840c209f3da1125a9f429551506a72be51fd40df320a38cf8c5ef39c2040936840cf1329a8ea9c3706c64437e93badd7ec4ce6270dd722c7c2eb7c61e22f2107a17d3d51f7e2301ab6af83365af0ea9827fb0b53356c59b032d809e1be7a9927ba9cf0505a6b7930dfb52f4d83011ab0a20a5c773f2f40288a99f38c77e9e2e2224e050b36cf5d4ee16bf806cc5ccbd2ec5cbb0ce6713b0addac18129332513011409ff4641bfa0623f46394fefb537599fa7e3b9945accea5177d726bd9e63c83baa5549dc9432a6825c938a52b8fc925f878efa70f0a498142be8c3c3e4553086bb4e3f62ea160f198a2eb7c195999d5798864f7209de3ab43b9e55caed79bdcd39892d4f49b502da68faeefc6908852dcdd43624ffe9d3443038380e6d72f015d07279fdd5659801b5711fb788d34407b8646e3dda04d4bf22567b04cc5754510ed70fba7fefca609eeaa7a4ac7686c4c10a991ed48213b63a93ddf9ca95d663aece69fad5a9b417aca62a9f37b25d9c7320c1803842b8960a04f4c77cfea4816f1d8753593c74bd1a66c44e76772b90f6705c0a27a89ded90d8f9a62b872a93bbaa7a83a4a8e5b430e4ac28e2a876abd21c23be290a39ba204fd8e05c684fbca40a62823871343cb2983e1762eb789909cda8115d43f622b8e71d8430f60c5bb9bf95afe0092b9ad633d2b71e27f7b962e4952b3dcaf990b752903fd068562592e6937abda705f283a3c7922d616e18f7ed573b833c33edea21efc4b1480a8e68ad7971d01273c55bafc7ccc9e4aa67bebc8b3b5c743ded828bc99e60e3a080277fa99ddb2a6ed104cebeb771c9845a3e039d2a6183f07285c12588bffc263dd51e8c7e9a3362b10b5d901a0c95da0fca4e73e62f4623564da1d340da9b17e326c5cfa5d0f98505b15333095e18ea7ac5df87901a9ce4c406ff888a5400f7a8599cfa785d99f3a24ed5930fdc267e94c293dc1b8fdf9ee2364505d354e257aa8bd078ac07262f60229693e20f9c2c2b1ad02df97f134b4ef13aa0ea4f190cabccf2f836a8d91a6eb3bbd9117c32642ecde43d6f8854556813bac2a442b2ab99d6574330f792659727be748a5952b8d44e3b015ee0865b063ee113a8779d95ff38854fd934f71dc6241ad92616b8c499a5faabf2fd8e535542a85802979574420b64e86ac4850b04ec823fe5e48071aa178defc050733be8dc364733f4f5037b4bd7e71dbb960b44605aa4c0f8820f2da740479adb930d1a65930e78f4e4ccdbe402e50d69d8e928a34ee2cd9a41d8d9799b7d970e5973276722f6e8487fec2edbdb448858d3e1e0ec1e2c4c59fe6a7e4256c21515bdaabb5d2f44bee671d5b6fb5f0f9dd981743ff497f925f5a13eb462463fb6dc9108401c646f0ffd58f3e620faa2f82a0502eef4636eb597c3413ba04fbbce052829f2258be89d87e66edb390de5a56b54f6004cb9bc5928f39532e00f78cee9953a8c4e6df3b85541b114513b5c76772bf445942955a6c2af71a180411f31b6bb7059a248563220cc8537de0d42b4942fcb7ef2515fe31d0306ad284fd4d96627cd52b6a7cf3ef8d48cd1912340c67b0f0e3f330da67d667060f0fb9b327b230ff4304db03bd5e9a284003d9dbd46da02965cae2f66510da6e66742399cabdc01bc5a8f85cd324eab2090b4a23dcfce5806d196e1d2222afc19e089dcd06176931ddd80c7e81fd605b173c3a86c93781bfbb70ca60670e7e0ca9818802a4a54cdac756e948794826007e32c00e71fe65eea62e4a2acc37d99e2a9f7f5efca84fe1032268bf2298f8517888\n  \n    \n      \n      \n        当前文章暂不对外可见，请输入访问密码后查看！\n      \n    \n  \n\n","categories":["篮球"],"tags":["投篮"]},{"title":"详解 Hexo 部署：GitHub 手动提交与 hexo -d 的区别及常见问题解析","url":"/2025/08/16/%E8%AF%A6%E8%A7%A3-Hexo-%E9%83%A8%E7%BD%B2%EF%BC%9AGitHub-%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%B8%8E-hexo-d-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/","content":"详解 Hexo 部署：GitHub 手动提交与 hexo -d 的区别及常见问题解析在使用 Hexo 搭建博客并部署到 GitHub 的过程中，很多人会遇到这样的困惑：手动提交 GitHub 有记录，hexo d却没有；仓库里找不到public文件夹，博客却能正常显示。本文将从核心区别、原理分析到问题排查，帮你彻底理清 Hexo 与 GitHub 的部署逻辑。\n一、GitHub 手动提交 vs hexo d：核心区别两者看似都是 “提交到 GitHub”，但本质上是操作对象和目标分支的不同，具体区别如下：\n\n\n\n维度\nGitHub 手动提交（git push）\nhexo d（hexo deploy）\n\n\n\n提交内容\n提交 Hexo 源码（source文件夹、themes主题、_config.yml配置等）\n仅提交public文件夹中的静态文件（HTML&#x2F;CSS&#x2F;JS 等可直接访问的网页文件）\n\n\n目标分支\n通常是main或master分支（源码分支）\n通常是gh-pages分支（GitHub Pages 专用部署分支）\n\n\n依赖配置\n无需特殊配置，仅需 Git 基础命令\n必须在_config.yml中配置deploy字段（指定仓库和分支）\n\n\n提交记录可见性\n提交记录显示在源码分支（如main）的 Git 历史中\n提交记录显示在部署分支（如gh-pages）的 Git 历史中\n\n\n典型用途\n备份源码、多设备同步开发\n快速发布博客（将静态文件部署到可访问的分支）\n\n\n关键原理：Hexo 的 “源码 - 静态文件” 分离机制Hexo 是静态博客生成器，工作流程分为两步：\n\nhexo g（hexo generate）：将source中的 Markdown 文章、主题配置等源码，生成可直接在浏览器中访问的静态文件（存放在public文件夹）；\n\nhexo d：将public文件夹的内容推送到部署分支（如gh-pages），供 GitHub Pages 展示。\n\n\n而手动提交通常是将源码推送到源码分支（如main），两者操作的是不同的 “内容” 和 “分支”。\n二、为什么 GitHub 仓库没有public文件夹？public文件夹是 Hexo 生成的静态文件目录，但它通常不会出现在你的源码仓库中，原因有三：\n1. .gitignore文件默认排除了publicHexo 初始化项目时，会自动生成.gitignore文件，其中包含一行：\npublic/  # 忽略public文件夹\n\n这是因为public是动态生成的文件（每次hexo g都会重新生成），无需纳入源码版本管理（避免冗余和冲突）。\n查看你的.gitignore文件即可验证：\ncat .gitignore  # 终端中执行，查看是否包含public/\n\n2. public文件被部署到了其他分支hexo d推送的public文件，默认会被推送到_config.yml中配置的部署分支（如gh-pages），而不是你日常提交源码的main分支。\n例如，你的配置可能是：\n# _config.ymldeploy:  type: git  repo: https://github.com/你的用户名/你的仓库名.git  branch: gh-pages  # public文件被推送到gh-pages分支\n\n此时，public文件只存在于gh-pages分支，而你查看的main分支自然没有这个文件夹。\n3. 自动化部署工具隐藏了public如果使用 GitHub Actions 等自动化工具，流程通常是：\n\n你提交源码到main分支；\n\nActions 自动执行hexo g生成public；\n\nActions 将public推送到gh-pages分支（全程在云端完成）。\n\n\n这种情况下，本地和源码仓库（main分支）都不会出现public文件夹，但gh-pages分支中存在（用于展示）。\n三、为什么hexo d没有提交记录？手动提交有记录，hexo d却没有，核心原因是提交记录在你没注意的分支中，具体排查方向：\n1. 检查hexo d的目标分支hexo d的提交记录会出现在部署分支（如gh-pages），而不是源码分支（main）。\n在 GitHub 仓库页面切换到部署分支（如gh-pages），即可看到hexo d的提交记录：\n2. 排查hexo d是否实际执行成功如果hexo d执行失败（如配置错误），则不会产生提交记录。检查终端输出：\n\n成功提示：Deploy done: git\n\n失败提示：可能包含 “Permission denied”（权限问题）、”Repository not found”（仓库地址错误）等。\n\n\n常见失败原因及解决：\n\n仓库地址错误：修正_config.yml中的repo字段；\n\n权限不足：配置 SSH 密钥（推荐）或使用 HTTPS 时输入正确的账号密码；\n\n未安装部署插件：执行npm install hexo-deployer-git –save安装。\n\n\n3. 确认部署配置是否指向正确仓库如果_config.yml中的repo配置指向了其他仓库（如测试仓库），hexo d的记录会出现在该仓库中，而非你当前查看的仓库。\n检查配置：\n# _config.ymldeploy:  type: git  repo: 你的仓库地址  # 确认是否与你查看的仓库一致  branch: gh-pages # # 确认是否与你查看的分支一致\n\n四、实用技巧：正确管理提交记录和部署流程1. 同时管理源码和部署记录\n源码分支（main）：手动提交git add . &amp;&amp; git commit -m “更新文章” &amp;&amp; git push，备份源码；\n\n部署分支（gh-pages）：执行hexo clean &amp;&amp; hexo g -d，自动部署静态文件，记录在gh-pages分支。\n\n\n2. 快速查看hexo d的提交记录通过终端命令查看部署分支的历史（以gh-pages为例）：\n# 克隆仓库并查看gh-pages分支git clone https://github.com/你的用户名/你的仓库名.gitcd 你的仓库名git checkout gh-pages  # 切换到部署分支git log  # 查看hexo d的提交记录\n\n3. 避免混淆的最佳实践\n给源码提交和部署提交添加区分性备注：\n\n\n源码提交：git commit -m “feat: 添加Hexo主题配置”\n\n\n\n部署提交：在_config.yml中配置message（自定义部署提交信息）：\n\n\n\ndeploy:  type: git  repo: 你的仓库地址  branch: gh-pages  message: &quot;deploy: 发布新文章 &#123;&#123; now(&#x27;YYYY-MM-DD&#x27;) &#125;&#125;&quot;  # 自动添加日期\n\n\n在 GitHub 仓库的 “Settings-Pages” 中，明确记录部署分支（如 “Deploy from branch: gh-pages”），方便后续查阅。\n\n五、总结：核心要点速览\n\n\n问题\n本质原因\n解决 &#x2F; 验证方法\n\n\n\n手动提交与hexo d的区别\n提交内容（源码 vs 静态文件）和目标分支不同\n查看.gitignore和_config.yml的deploy配置\n\n\n仓库没有public文件夹\n被.gitignore排除，或存在于部署分支\n切换到gh-pages分支查看，或检查.gitignore\n\n\nhexo d没有提交记录\n记录在部署分支，或部署失败\n切换到部署分支查看历史，或检查终端错误信息\n\n\n理解 Hexo 的 “源码 - 静态文件分离” 和 GitHub 的 “分支部署机制”，是解决这些问题的关键。记住：public是临时生成的展示文件，源码才是需要长期管理的核心；hexo d的记录藏在部署分支里，切换分支就能找到。按本文的方法排查，你就能清晰掌控博客的部署流程了。\n","categories":["Hexo博客"],"tags":["Hexo+Butterfly"]},{"title":"键盘灯光切换和系统切换的基本使用","url":"/2025/07/22/%E9%94%AE%E7%9B%98%E7%81%AF%E5%85%89%E5%88%87%E6%8D%A2%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%88%87%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"RK-G98 键盘灯光切换和系统切换的基本使用涵盖灯光控制、系统切换、连接方式等实用操作，、系统切换与键位适配\n1. Windows 与 Mac 模式切换\n切换至 Windows 系统：Fn + A\n\n适配 Windows 快捷键（如Win键、Ctrl+C&#x2F;V等）。\n\n切换至 Mac 系统：Fn + S\n\n适配 Mac 快捷键（如⌘键、⌥键映射等）。\n\n模式切换验证：\n\n切换后键盘指示灯会闪烁 3 次，部分功能键（如Caps Lock）逻辑会自动调整。\n2. 特殊键位互换\nCaps Lock 与左 Ctrl 互换：Fn + Caps\n\n适合习惯使用Ctrl键位于左下角的用户。\n\nWin 键屏蔽 &#x2F; 开启：Fn + Win\n\n游戏时防止误触 Win 键导致卡顿。\t\t\t\n二、灯光控制与自定义1. 基础灯光调节\n亮度调节：\n\n\n增加亮度：Fn + ↑（共 5 档，最大亮度时指示灯闪烁）。\n\n\n\n降低亮度：Fn + ↓（可关闭背光，指示灯闪烁提示最小值）。\n\n\n动态速度调节：\n\n\n减慢速度：Fn + ←（适用于跑马灯、呼吸灯等动态模式）。\n\n\n\n加快速度：Fn + →（最高速时指示灯闪烁）。\n\n\n\n2. 预设背光模式切换(有两种版本)\n全模式循环  Fn + prtsc（ps） 或者 Fn + \\| 遍历所有预设背光模式\n\n","categories":["其他"]}]